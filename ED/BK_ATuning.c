/***********************************************************************/
/*                                                                     */
/*  FILE        :hwsetup.c                                             */
/*  DATE        :Fri, Aug 12, 2005                                     */
/*  DESCRIPTION :Hardware Setup file                                   */
/*  CPU TYPE    :SH7149                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.0).     */
/*                                                                     */
/***********************************************************************/
#ifndef  _ATUNING_C
    #define  _ATUNING_C
#endif

#include "ProgHeader.h"

#include "PR_SinTable.h"

#define LFSL_LPF_ON     1
#define CALC_X_METHOD   1

void DBC_Init(void)
{
    tun_status.ub.low = 0;
                                   
    TUN_START = 1;
    TUN_OK = 0;                
            
	TUN_slIphS1 = 0;
	TUN_slUphS1 = 0;
	DBC_slCMPUaInt = 0;
		
	TUN_slUdIntPu = 0;
	TUN_swUoutPu = 0;

	TUN_TuningCNT = 0;
	TUN_DBC_OK = 0;
}

void DBC_VarInit(void)
{
    DBC_slUdc_10KI1 = 0;
	DBC_slUdc_10KI2 = 0;
	DBC_slUdc_5KI1 = 0;
	DBC_slUdc_5KI2 = 0;
	DBC_slDuty_10KI2 = 0;
    DBC_slDuty_10KI1 = 0;
    DBC_slDuty_5KI2 = 0;
    DBC_slDuty_5KI1 = 0;
	
	DBC_uwDuty_t_10K = 0;
	DBC_uwD_u_10KUcom = 0;
	               
}


void DBC_HandelOK(void)
{
    UWORD Udc_DBC_av, Duty_10K, Duty_5K, Duty_u_10K;	
    
    //------ to get the average of DCbus value ----------------------------------------//
    // 512 point intergration. so 4*512=2048. so Udc_DBC =10*Udc
	Udc_DBC_av = (UWORD)((SLONG)(DBC_slUdc_10KI1 + DBC_slUdc_10KI2 + DBC_slUdc_5KI1 + DBC_slUdc_5KI2)>>11);

    //	512 point intergration, double voltage Duty_u and Duty_t in DBC self_calibration 
    //	so /1024 is ok, but save *16,so /64 is ok
	// 2 * Ton2 - Ton1
	Duty_10K = (UWORD)(2 * DBC_slDuty_10KI2 - DBC_slDuty_10KI1)>>6;
	// 2 * Ton4 - Ton3
	Duty_5K = (UWORD)(2 * DBC_slDuty_5KI2 - DBC_slDuty_5KI1)>>6;
	//2 * Ton4 - Ton3 - 2 * Ton2 + Ton1
	
	Duty_u_10K = Duty_5K - Duty_10K;	
	/*	2*Ton2 - Ton1 - 2*Ton4 + Ton3 + 2*Ton2 - Ton1
		= 4*Ton2 + Ton3 - 2(Ton1 + Ton4)				*/
	DBC_uwDuty_t_10K = Duty_10K - Duty_u_10K;
	
    //T12 = (2*Ton2 - Ton1)/2
	//T34 = (2*Ton4 - Ton3)/2
	//Tvmark = Vdc/Vcom * 5(T34 - 5T12)/5
	if ((pr[HPSPEC]&VFD440V)==VFD220V) {
		DBC_uwD_u_10KUcom = ((SLONG)Duty_u_10K * Udc_DBC_av/3110);
	}
	else {
		DBC_uwD_u_10KUcom = ((SLONG)Duty_u_10K * Udc_DBC_av/5370);
	}
}

void DBC_Calibration(void)
{
	SWORD TUN_swIerrPu = 0;
	UWORD TUN_uwKp, TUN_uwKi;
    
    TUN_uwKp = pr[DCTUN_P];
	TUN_uwKi = pr[DCTUN_I];

//	TUN_swIdseFdbPu = AD_swIAPu;	
	TUN_swIdseFdbPu = AD_swIAPu;	
    
    TUN_swIerrPu = TUN_swIdseRefPu - TUN_swIdseFdbPu;
	    
    //------ Current Regulator PI --------------------------------------//	
	TUN_slUdIntPu = TUN_slUdIntPu + (((SLONG)TUN_swIerrPu * TUN_uwKi)>>8);
	if ((SLONG)TUN_slUdIntPu > 0){	    
	    if (TUN_slUdIntPu >= 24576)
	        TUN_slUdIntPu = 0x6000;
	}
	else{
	    TUN_slUdIntPu = 0;
	    TUN_TuningCNT = 0;
	}
	
	TUN_swUoutPu = TUN_slUdIntPu + (((SLONG)TUN_swIerrPu * TUN_uwKp)>>8);
	if ((SWORD)TUN_swUoutPu > 0){
	    if (TUN_swUoutPu >= 0x6000)
	        TUN_swUoutPu = 0x6000;
	}
	else{
	    TUN_swUoutPu = 0;
	    TUN_TuningCNT = 0;
	}
	
    //------ Wave Form processing --------------------------------------//       
    
    PWM_swTaInPu = (DBC_period >> 1) - (((SLONG)TUN_swUoutPu * DBC_period)>>15);
    PWM_swTbInPu = (DBC_period >> 1);
    PWM_swTcInPu = (DBC_period >> 1);
    PWM_GEN();
    
    if ((TUN_TuningCNT > 3400)&&(TUN_TuningCNT <= 3912)){
        // Catch 512 points
    	TUN_slIphS1 += AD_swIAPu;   //Q15 and integral 512 times
    	TUN_slUphS1 += dcbusDC;     //Q0 and intergral 512
    	DBC_slCMPUaInt += (((SLONG)TUN_swUoutPu * DBC_period)>>15); //Q0 and integral 512 times
    }
    TUN_TuningCNT ++;
    
    if (TUN_TuningCNT >= 4000){
    	TUN_DBC_OK = 1;
    	ZeroPWM();
    }
}

void DBC_PROCESS_TB2(void)
{
    
    if ((RUNNING==RUN)&&(Error==0)){
    	switch(TUN_Sector){
    	    case DBC_IDLE0:
    		    TUN_TuningCNT ++;
    		    WGOFF;
    		    if (TUN_TuningCNT>=2000){
    		        WGON;
    		    	TUN_TuningCNT = 0;
                    TUN_Sector = DBC_HiF_S1;
                    ZeroPWM();
    		    } break;    	        
    		case DBC_HiF_S1:
    		    if (TUN_DBC_OK==0){
    		        WGON;
    		    	TUN_swIdseRefPu = 6000;
    		    	DBC_period = 2000;                      //10K   		    	
    		    	DBC_Calibration();
    		    }
    		    else{
    		        DBC_slDuty_10KI1 = DBC_slCMPUaInt;
    		        DBC_slUdc_10KI1 = TUN_slUphS1;    		        
    		        DBC_Init();
    		        TUN_Sector = DBC_IDLE1;
    		    } break;
    		    
    		case DBC_IDLE1:
    		    TUN_TuningCNT ++;
    		    WGOFF;
    		    if (TUN_TuningCNT>=2000){
    		        WGON;
    		    	TUN_TuningCNT = 0;
                    TUN_Sector = DBC_HiF_S2;
                    ZeroPWM();
    		    } break;
    		    
    		case DBC_HiF_S2:
    		    if (TUN_DBC_OK==0){
    		        WGON;
    		    	TUN_swIdseRefPu = 3000;    		    	    		    	   		    	
    		    	DBC_Calibration();
    		    }
    		    else{
    		        DBC_slDuty_10KI2 = DBC_slCMPUaInt;   		        
    		        DBC_Init();
    		        TUN_Sector = DBC_IDLE2;
    		    } break;

    		case DBC_IDLE2:
    		    TUN_TuningCNT ++;
    		    WGOFF;
    		    if (TUN_TuningCNT>=2000){
    		        WGON;
    		    	TUN_TuningCNT = 0;
                    TUN_Sector = DBC_LoF_S1;
                    ZeroPWM();
    		    } break;
    		
    		case DBC_LoF_S1:
                if (TUN_DBC_OK==0){
                    WGON;
    		    	TUN_swIdseRefPu = 6000;
    		    	DBC_period = 4000;                      //5K
    		    	DBC_Calibration();
    		    }
    		    else{
    		        DBC_slDuty_5KI1 = DBC_slCMPUaInt;
    		        DBC_slUdc_5KI1 = TUN_slUphS1;
    		        DBC_Init();
    		        TUN_Sector = DBC_IDLE3;
    		    } break;
    		    
    		case DBC_IDLE3:
    		    TUN_TuningCNT ++;
    		    WGOFF;
    		    if (TUN_TuningCNT>=2000){
    		        WGON;
    		    	TUN_TuningCNT = 0;
                    TUN_Sector = DBC_LoF_S2;
                    ZeroPWM();
    		    } break;
    		    
            case DBC_LoF_S2:
                if (TUN_DBC_OK==0){
                    WGON;
    		    	TUN_swIdseRefPu = 3000;
    		    	DBC_Calibration();
    		    }
    		    else{
    		        DBC_slDuty_5KI2 = DBC_slCMPUaInt;
    		        DBC_slUdc_5KI2 = TUN_slUphS1;    		        
    		        DBC_Init();
    		        TUN_Sector = DBC_Calc;
    		    } break;
    		    
    		case DBC_Calc:
    		    DBC_HandelOK();
    		    if ((DBC_uwDuty_t_10K>1200)||(DBC_uwD_u_10KUcom>180)){
          		    DBC_period = 2000;  // 10K
       		        TUN_Sector = DBC_IDLE0;          		         
                    TUN_WAIT = 1;
                    TUN_START = 1;
                    TUN_OK = 0;
    		        DBC_Init();
	                DBC_VarInit();
	                
    		        TUNErrorCnt++;
    		        if (TUNErrorCnt > 3){
    		            stop_status();
    		            if(Error == 0){  //[Other erroe cause AUE_ERR,lyabryan,2016/06/12]
    		                Error = AuE_ERR; 
    		            }
    		        }
    		    }
    		    else{	
	                pr[CTRLM] = (UWORD)CTRLM_buf;	
	                WRITE_DBCPR = 1;
    		        TUN_START = 0;
    		        TUN_OK = 1;
    		        stop_status();
    		    }
    		default:
    		    break;
    	}
    }
}

void TUN_StartInit(void)
{
    tun_status.uw &= 0xC200;  /*
	TUN_START=0
	TUN_OK=0
	TUN_DC_OK=0
	TUN_HFSS_OK=0
	TUN_ROTARY_OK=0
	TUN_WAIT=0      
	TUN_IACrossZero=0
	TUN_DBC_OK=0    
	TUN_ROLLING=0
	TUN_SAMPLEON=0
	TUN_LFSL_OK=0   
	TUN_LFSL=0      
	TUN_PMLS_OK=0
	TUN_PMLS_ST=0    
	TUN_POS_DC_OK		
	TUN_PHASEZ_OK	/*  */
    
    Fkeypad_Buf = uwFkeypad;
                                   
//    TUN_START = 1;

	// [ Don't save STtune if pr[PM_AUTO_T]==3, DINO, 05/11/2009
	if (pr[PM_AUTO_T] != 3){
    	STtune_Buf = STtune;    /* dino, 05/15/2007 */
    	STtune = 0;				/* dino, 05/15/2007 */
	}
	// ]

//    TUN_OK = 0;   	 //tun
//    TUN_LFSL_OK = 0;   //tun1          
    TUN_TuningCNT = 0;
    
    TUN_swIdseRefPu = 0;
    TUN_swIdseFdbPu = 0;
    TUN_slUdIntPu = 0;
    
    TUN_swUoutPu = 0;
    TUN_slIphS1 = 0;
    TUN_slUphS1 = 0;
    TUN_slP = 0;
    TUN_slQ = 0;
    
    if (pr[AUTO_T]==10){
        CCB_slIaSum = 0;
        CCB_slIbSum = 0;
        CurGainPWMSetup();
    }
//---ADDED BY SCOTTY 2007/06/01---
	if (pr[PM_AUTO_T]==1 || pr[PM_AUTO_T]==3){  // 08/11/2008
		TUN_Method         	= PGZ_DETECT;
		TUN_STEPANG         = 1;
    	TUN_POS_DC_OK		= 0;	//ADDED BY SCOTTY 2007/06/01
    	TUN_Z_COMFIRM       = 0;	//ADDED BY SCOTTY 2007/06/01
    	TUN_PHASEZ_OK       = 0;	//ADDED BY SCOTTY 2007/06/01
    	TUN_swZANGLE       	= 0;	//ADDED BY SCOTTY 2007/06/13
    	Init_SpDtPG1_pr();			//ADDED BY SCOTTY 2007/06/11
    	SpDt_uwPG1CNT_Org 	= 0;	//ADDED BY SCOTTY 2007/06/13
    	SpDt_uwPG1CNT_Org1	= 0;	//ADDED BY SCOTTY 2007/06/13
    	TUN_Z_CAPTURECNT  	= 0;	//ADDED BY SCOTTY 2007/06/14
    	TUN_Z_CAPTURECNTZ 	= 0;	//ADDED BY SCOTTY 2007/06/14
      	PG_Zoffset 		  	= 0;	//ADDED BY SCOTTY 2007/06/04  	2007/12/06 NEED DEL
      	// [ Move to stop_status(), Modify by DINO, 05/11/2009
//      	STtune_Buf        	= 0;	//ADDED BY DINO   2008/01/29
		// ]
      	REPOS_FAULT_FLAG  	= 1;	//ADDED BY DINO   2008/01/29
      	
      	TUN_uwUVWsector    = 0;
    	SpDt_uwAnglePeriod = (UWORD)((ULONG)(SpDt_ulPG1NpulseNoMx<<1)/pr[PM_POLES]);
    	TUN_STEPANGMAX = U16xU16divU16(32767,COF_ubMPolePair,60000);

    	// [ Only Rotating tuning have to set SCI1_DIR=1, 07/10/2009
    	if (pr[PG_TYPE]==ABZ_UVW && pr[PM_AUTO_T]==1){		//11/06/2007 SCOTTY ABZ TO UVW
    	// ]
    		//MTU2S4.TIER.BYTE &= 0xF7;	// TGIED, Z-pulse capture interrupt disable 
    	    MTU6.TIER.BYTE &= 0xF7;
    		//SCI1_DIR = 1;
    		PGSEL = 0;
//			PFC.PECRH2.WORD &= 0x00ef;	//PGZ to GPIO
//			PFC.PACRL2.WORD &= 0x0010;	//PGA,PGB to GPIO	
		
		}

		uw_SCTEST  = 0;
		uw_SCTEST3 = 0;
    }
	else{
//---END 2007/06/01---------------	
		TUN_Method = DC_TEST;
	}
   
    TUN_DC_OK = 0;

    TUN_HFSS_OK = 0;
    TUN_ROTARY_OK = 0;

//    TUN_ROLLING = 0;  //tun1
//    TUN_LFSL = 0;	  //tun1

    TUN_WAIT = 1;
    
    TUN_IntegralCnt = 0;
//-- ADDED BY SCOTTY ----02/06/2007-----
    TUN_uwPMTunCnt = 0;
    TUNEPMLSLOW_V 	= 1;
//    TUN_PMLS_OK 	= 0;  // tun1
//    TUN_PMLS_ST 	= 0;  // tun1
    TUN_swIhigh 	= 0;		//ADDED BY SCOTTY 2006/09/12
    TUN_swIlow 		= 0;		//ADDED BY SCOTTY 2006/09/12
    TUN_swImid 		= 0;		//ADDED BY SCOTTY 2006/09/12
    TUN_uwLSCNT 	= 0;   		//ADDED BY SCOTTY 2006/09/12
    TUN_uwLSCNT1 	= 0;		//ADDED BY SCOTTY 2006/09/12
    TUN_uwLSTIME 	= 0;   		//ADDED BY SCOTTY 2006/09/12
    TUN_uwVdout 	= 0;		//ADDED BY SCOTTY 2006/11/03
    TUN_Z_COUNT 	= 0;		//ADDED BY SCOTTY 2007/06/04
	TUN_SINDATAMAX 	= 0;		//ADDED BY SCOTTY 2007/06/05
	TUN_COSDATAMAX 	= 0;		//ADDED BY SCOTTY 2007/06/05
	TUN_SINDATAMIN 	= 4096;		//ADDED BY SCOTTY 2007/06/05
	TUN_COSDATAMIN 	= 4096;		//ADDED BY SCOTTY 2007/06/05     
    TUN_TunLSCNT 	= 0;
    TUN_uwLSTmax 	= 0;
    TUN_uwLSTmin 	= 65535;  
//-- END ----02/06/2007-----

}

void TUN_DCVarInit(void)
{
	TUN_TuningCNT 	= 0;
	
	TUN_swIdseRefPu = 0;
	TUN_swIdseFdbPu = 0;
	
	TUN_slUdIntPu 	= 0;
	TUN_swUoutPu 	= 0;
	
	TUN_slUphS1 	= 0;
	TUN_slUphS2 	= 0;
	TUN_slIphS1 	= 0;
	TUN_slIphS2 	= 0;    

    slUalfaPuLPF 	= 0;
    slIalfaPuLPF 	= 0;
    TUN_slFreqPu 	= 0;

    TUN_DCVolt_OK 	= 0;
// [ ADDED BY SCOTTY 02/06/2007
	TUN_swIhigh 	= 0;		//ADDED BY SCOTTY 2006/09/12
	TUN_swIlow 		= 0;		//ADDED BY SCOTTY 2006/09/12
	TUN_swImid 		= 0;		//ADDED BY SCOTTY 2006/09/12
	TUN_uwLSCNT 	= 0;   		//ADDED BY SCOTTY 2006/09/12
	TUN_uwLSCNT1 	= 0;		//ADDED BY SCOTTY 2006/09/12
	TUN_uwLSTIME 	= 0;		//ADDED BY SCOTTY 2006/09/12
    TUN_Z_COUNT 	= 0;		//ADDED BY SCOTTY 2007/06/04	 
	
	TUN_TunLSCNT 	= 0;
	TUN_uwLSTmax 	= 0;
	TUN_uwLSTmin 	= 65535;
// ]
}

void TUN_DC_Cmd(void)
{
	UWORD TUN_uwKi, TUN_uwKp;
	SWORD TUN_swIerrPu;
    SLONG slTemp;
    
	TUN_uwKi = pr[DCTUN_I];
	TUN_uwKp = pr[DCTUN_P];


	if (pr[PM_AUTO_T] == 2){
		// 10000 * 100us = 1s		
		if (TUN_TuningCNT==0){
			TUN_swIdseRefPu = COF_uwMIratePu;
			slIalfaPuLPF = TUN_swIdseRefPu << 16;
		}
		else if (TUN_TuningCNT==10000){
			TUN_swIdseRefPu = (COF_uwMIratePu * 3)>>1;
			slIalfaPuLPF = TUN_swIdseRefPu << 16;
		}
	}
	else{
// [ Modify
		// 10000 * 100us = 1s		
		if (TUN_TuningCNT==0){
		    TUN_swIdseRefPu = ((ULONG)COF_uwMIratePu * 23170)>>16;	/* Item 52.2: TUN_swIdseRefPu = COF_uwMIratePu;	*/
	        slIalfaPuLPF = TUN_swIdseRefPu << 16;
	    }
	    else if (TUN_TuningCNT==10000){    	
		    TUN_swIdseRefPu = ((ULONG)COF_uwMIratePu * 46341)>>16;	/* Item 52.2: TUN_swIdseRefPu = (COF_uwMIratePu * 3)>>1; */
	        slIalfaPuLPF = TUN_swIdseRefPu << 16;	   
	    }	
// ]
	}

	TUN_swIdseFdbPu = AD_swIAPu;
	    	
	TUN_swIerrPu = TUN_swIdseRefPu - TUN_swIdseFdbPu;
// [ Modify
    if (((TUN_TuningCNT>5000)&&(TUN_TuningCNT<10000))||((TUN_TuningCNT>15000)&&(TUN_TuningCNT<20000))){
        if ((abs(TUN_swIerrPu) < 100) && (TUN_DCVolt_OK == 0))  // 32767*0.3%=100
            TUN_DCVolt_OK = 1;
        else if ((abs(TUN_swIerrPu) > 500) && (TUN_DCVolt_OK == 1))   // 32767*1.5%=500
            TUN_DCVolt_OK = 0;
    }
    else{
        TUN_DCVolt_OK = 0;
    }

    //------ Current Regulator PI --------------------------------------//	
    if (TUN_DCVolt_OK == 0){   
        TUN_slUdIntPu = TUN_slUdIntPu + ((SLONG)TUN_swIerrPu * TUN_uwKi); //Q31
        if (TUN_slUdIntPu >= 0x70000000)
            TUN_slUdIntPu = 0x70000000;
        else if (TUN_slUdIntPu <= -0x70000000)
            TUN_slUdIntPu = -0x70000000;

    	slTemp = (SLONG)TUN_swIerrPu * TUN_uwKp; //Q25
    	slTemp = ((TUN_slUdIntPu>>6) + slTemp) >> 10;

    	if (slTemp >= 0x7FFF)
    	    TUN_swUoutPu = 0x7FFF;
    	else if (slTemp <= (-0x7FFF))
    	    TUN_swUoutPu = -0x7FFF;
    	else
            TUN_swUoutPu = slTemp;
    }
// ]
	//------ Wave Form processing --------------------------------------//
	Duty_swTasInPu = TUN_swUoutPu;
	Duty_swTbsInPu = -(TUN_swUoutPu >> 1);
	Duty_swTcsInPu = -(TUN_swUoutPu >> 1);	    

	UabcPu2Duty();

	TUN_TuningCNT ++;

	//------ Integral Uout in 1024 times -------------------------------//
	// 10000 - 8976 = 2^10 = 1024, have 1024 average
	slIalfaPuLPF = lowpass_sl(655, TUN_swIdseFdbPu, slIalfaPuLPF);
	if ((TUN_TuningCNT>=8976)&&(TUN_TuningCNT<10000)){
		TUN_slUphS1 = TUN_slUphS1 + TUN_swUoutPu;
	    TUN_slIphS1 = TUN_slIphS1 + (slIalfaPuLPF>>16);
	}
	else if ((TUN_TuningCNT>=18976)&&(TUN_TuningCNT<20000)){
		TUN_slUphS2 = TUN_slUphS2 + TUN_swUoutPu;
        TUN_slIphS2 = TUN_slIphS2 + (slIalfaPuLPF>>16);
	}

	//------ when CNT over 20010, DC test is finished, Calculate Rs ----//
	if (TUN_TuningCNT > 20010){
		TUN_TuningCNT = 0;
		TUN_DC_OK = 1;
		TUN_uwVdout = TUN_swUoutPu;	//保留額定電流的電壓值 for PM tuning
	    TUN_swUoutPu = 0;
		ZeroPWM();
	}
}

void TUN_DC_CalRs(void)
{	    	
/*	
	單位轉換係數修正
	2500 V.S 220.0 Vac
	TUN_uwRsPu = (TUN_uwRsPu/sqrt(2))*(2200/2500) 	= 1.5R
	TUN_uwRsPu = TUN_uwRsPu * 0.6222				= 1.5R
	TUN_uwRsPu = TUN_uwRsPu * 0.6222 *4/3 			= 2.0R -- display L-L resister
	
	原
	TUN_uwRsPu = S32xS32divS32(TUN_slUphS1,32768,TUN_slIphS1);
	改成
	TUN_uwRsPu = S32xS32divS32(TUN_slUphS1,27184,TUN_slIphS1);
*/
	TUN_slIphS1 = (TUN_slIphS2 - TUN_slIphS1);
	TUN_slUphS1 = (TUN_slUphS2 - TUN_slUphS1);
//#if SCOTTY
	//TUN_uwRsPu = S32xS32divS32(TUN_slUphS1,27184,TUN_slIphS1);//RsPu in Q15
//#else    	
	TUN_uwRsPu = S32xS32divS32(TUN_slUphS1,32768,TUN_slIphS1);//RsPu in Q15 //[IM Autotune Modify,Sampo,2018/07/12]
//	TUN_DCVarInit();		//deleted by scotty  	    		    	
//#endif 
}

//--ADDED BY SCOTTY - 2007/02/06------------
void TUN_PMLS_3Section(void)
{
    UWORD TUN_uwtemp; 
//------ Wave Form processing --------------------------------------//
    switch(TUN_Sector){
        case 1:
            CRM_uwSinIndex = (0);
            break;
            
        case 2:
            CRM_uwSinIndex = ((171) & 0x03ff);               
            break;
        
        case 3:
            CRM_uwSinIndex = ((341) & 0x03ff);               
            break;            

        case 4:
            CRM_uwSinIndex = ((512) & 0x03ff);               
            break;
            
        case 5:
            CRM_uwSinIndex = ((683) & 0x03ff);               
            break;                        

        case 6:
            CRM_uwSinIndex = ((854) & 0x03ff);               
            break;
                        
    	default:
    	    break;            
    }
    CRM_uwCosIndex = ((CRM_uwSinIndex + 256) & 0x03ff);    
    SinValue = sine[CRM_uwSinIndex];
    CosValue = sine[CRM_uwCosIndex];
//-- current feedback 3phase->sy----//    
    T32_swIasInPu = AD_swIAPu;
    T32_swIbsInPu = AD_swIBPu;
    abc2dq();
    
    TsE_swIdssInPu = T32_swIdssOutPu;
    TsE_swIqssInPu = T32_swIqssOutPu;
    Stat2Syn_s2e();  
    TUN_swIdseFdbPu = TsE_swIdseOutPu; 
    if (TUN_swIdseFdbPu<0){TUN_swIdseFdbPu= -TUN_swIdseFdbPu;}
//-- voltage output sy->3phase ----//           

    if (TUNEPMLSLOW_V){
    	TUN_swUoutPu = TUN_uwVdout>>2;
    }	//決定輸入電壓
    else{
    	TUN_swUoutPu = TUN_uwVdout;
    }
    
    TeS_swUdseInPu = TUN_swUoutPu;
    TeS_swUqseInPu = 0;    
    Syn2Stat_e2s();
    
    T23_swUqssInPu = TeS_swUqssOutPu;
    T23_swUdssInPu = TeS_swUdssOutPu;
    dq2abc();
    
    Duty_swTasInPu = T23_swUasOutPu;
    Duty_swTbsInPu = T23_swUbsOutPu;
    Duty_swTcsInPu = T23_swUcsOutPu;    
    UabcPu2Duty();     

    TUN_uwPMTunCnt ++;
//current raising time must be sufficient(large inductance)
	if (TUN_uwPMTunCnt < 3000){	//2000
		if (TUN_uwLSCNT==1){
			if (TUN_uwPMTunCnt>2871){TUN_slIphS1 = TUN_slIphS1 + TUN_swIdseFdbPu;} //2871
		}
		if (TUN_uwLSCNT == 4){
			TUN_PMLS_ST = 0;
			TUN_uwLSTIME = TUN_uwLSCNT1>>1;
		}               
	}
	else {
		TUNEPMLSLOW_V = 0;
		if (TUN_uwLSCNT==1){
			if (TUN_uwPMTunCnt>5871){TUN_slUphS1 = TUN_slUphS1 + TUN_swIdseFdbPu;}	//3871
		}
		if (TUN_PMLS_ST && (TUN_swIdseFdbPu <TUN_swImid)){TUN_uwLSCNT1++;}
	}

    if (TUN_uwPMTunCnt > 6000){ 	//4000		
    	TUN_uwPMTunCnt = 0;
		TUNEPMLSLOW_V = 1; 
        TUN_uwLSCNT ++;
        if (TUN_uwLSCNT == 2){
	    	TUN_swIlow = (SWORD)(TUN_slIphS1>>7);
	    	TUN_swIhigh = (SWORD)(TUN_slUphS1>>7); 
	   		TUN_uwtemp =  TUN_swIhigh - TUN_swIlow;
	    	TUN_uwtemp =  U16xU16divU16(TUN_uwtemp, 41427, 65535);	//1-e^-1 = 0.6321
	    	TUN_swImid = TUN_uwtemp + TUN_swIlow;
	    	TUN_PMLS_ST = 1;   	
		}
    }

    TUN_TuningCNT ++;
    TUN_TunLSCNT++;

//------ when TUN_Sector over 6, PM LS test is finished, Calculate Ls ----//
    if (TUN_TunLSCNT > 30000){	//20000
    	TUN_TunLSCNT = 0;
    	TUN_Sector ++;
    	if (TUN_uwLSTIME > TUN_uwLSTmax){TUN_uwLSTmax = TUN_uwLSTIME;}
    	if (TUN_uwLSTIME < TUN_uwLSTmin){TUN_uwLSTmin = TUN_uwLSTIME;}
    	TUN_uwLSTIME = 0;    	
    	TUN_uwLSCNT = 0; 
    	TUN_uwLSCNT1 = 0;
    	TUN_slIphS1 = 0;
    	TUN_slUphS1 = 0;
    }
    if (TUN_Sector > 6){			//Modified by SCOTTY 02/07/2007
		TUN_TuningCNT = 0;
		TUN_PMLS_OK = 1;
		TUN_PMLS_ST = 0;
		TUN_uwLSCNT1 = 0;
		TUN_swUoutPu = 0;
		TUN_uwPMTunCnt = 0;
		TUNEPMLSLOW_V =0;
		TUN_uwLSCNT =0;

		ZeroPWM();
    }
	
}
//--- end ---2007/02/06---------------------
//---ADDED BY SCOTTY---2007/02/06-----------
void TUN_CalPMLS(void)
{
    UWORD TUN_uwtemp, TUN_uwtemp1, TUN_uwtemp2;
    
    TUN_uwtemp = (((ULONG)TUN_uwRsPu * COF_uwRbRe) >> 14);  	//注意:電阻超過65535不適用
    TUN_uwtemp1 = U16xU16divU16(TUN_uwtemp, TUN_uwLSTmax, 1000);
    TUN_uwtemp2 = U16xU16divU16(TUN_uwtemp, TUN_uwLSTmin, 1000);
    TUN_uwtemp = (TUN_uwtemp1 + TUN_uwtemp2)>>1;
    TUN_uwL1sigmaPu = U16xU16divU16(TUN_uwtemp, 51200, COF_uwLbRe);
    
}
//--- END ---2007/02/06---------------------
//--ADDED BY SCOTTY - 2007/06/01------------
void TUN_PGZ_Section(void)
{
    //SWORD swVrefSqu;
    //ULONG ulVoutSqu;
    UWORD TUN_uwtemp, TUN_uwtemp1, uwCMDDIR;
	//SWORD TUN_swtemp;
	UWORD uwPGA, uwPGB, uwPGZ;
	
//	BRK_RLS = 1;// release
	TUN_uwPMTunCnt ++;
	
	if (TUN_PHASEZ_OK==0){
		if (TUN_uwPMTunCnt>40000){
			if (TUN_uwPMTunCnt > 50000 && TUN_STEPANG<TUN_STEPANGMAX){
				TUN_STEPANG ++;
				TUN_uwPMTunCnt = 40001;
			}
    		TUN_POS_DC_OK = 1;
		}

	}
	else {
		if (TUN_uwPMTunCnt & 0x1000){
			TUN_uwPMTunCnt = 0;
			if (TUN_STEPANG > 0){  // TUN_STEPANG should be >0, DINO, 08/02/2010
				TUN_STEPANG--;
			}
		}
	}
	
    if (TUN_POS_DC_OK){
        //if(pr[PG_TYPE]==SIN_SIN && ((pr[SysControl]&0x4000)!=0)){  // [IED 1387 static Tune, 2011/07/06]
        if(pr[PG_TYPE]==SIN_SIN && (NEWHSDSTUNE==1 && ((pr[SysControl]&0x0200)==0x0200))){  // [IED 1387 static Tune, 2011/07/06]
       	   //TUN_CAL_ZOFFSET();
       	 
       	   WRITE_Z_1387 = 1;
   	       TUN_PHASEZ_OK = 1;
        }
//--- EnDat tuning, Add by DINO, 08/26/2008
		if ( pr[PG_TYPE]==SIN_ENDAT || pr[PG_TYPE]==SIN_HIPER ){
			TUN_Z_CAPTURECNT = ((ULONG)TUN_uwTheta * SpDt_uwAnglePeriod) >> 16;
			TUN_Z_CAPTURECNTZ = TUN_Z_CAPTURECNT;
			TUN_PHASEZ_OK = 1;
		}
//--- End on 08/26/2008
		else{
			if (pr[CHG_DIR] == 1){  // Change CHGDIR Function, DINO, 08/02/2010
				uwCMDDIR = CMDDIR ^ 1;
			}
			else{
				uwCMDDIR = CMDDIR;
			}

			//-- Modify by DINO, 07/21/2008
    		if (uwCMDDIR == FORWARD){
    			CRM_uwTheta += TUN_STEPANG;
			}
    		else{
    			CRM_uwTheta -= TUN_STEPANG;
    		}

//			CRM_uwTheta &= 0x0ffff;
			TUN_uwtemp1 = 0xffff - TUN_STEPANG;
/*
			if ((CRM_uwTheta&0xfffe)==TUN_uwInitTheta ){  // Modify judged method, DINO, 07/21/2008
				uw_SCTEST = MTU21.TCNT - uw_SCTEST3;
				uw_SCTEST3 = MTU21.TCNT;
				TUN_TuningCNT++;
				if (TUN_TuningCNT > (COF_ubMPolePair<<2))	
					stop();					
			}	//protect idle
*/
			// [ Modify judged method, DINO, 05/18/2010
			if ((CRM_uwTheta&0x8000) != (TUN_uwInitTheta&0x8000)){
				if (TUN_IACrossZero == 0){
					TUN_IACrossZero = 1;
					TUN_TuningCNT++;
				}
			}
			else{
				TUN_IACrossZero = 0;
			}
			// ]

			if (TUN_TuningCNT > (COF_ubMPolePair<<2)){
				stop();					
			}	//protect idle


    		//TUN_uwtemp = MTU21.TCNT;
            TUN_uwtemp = MTU1.TCNT;
    		if (PGDIR != 1)
            	TUN_uwtemp = 65535 - TUN_uwtemp ;

    		TUN_swZANGLE = (SWORD)(TUN_uwtemp - SpDt_uwPG1CNT_Org1);

			//-- Modify by DINO, 07/21/2008
    		if (TUN_swZANGLE >= 0){
            	if(TUN_swZANGLE >= SpDt_uwAnglePeriod){
                	SpDt_uwPG1CNT_Org1 += SpDt_uwAnglePeriod;
                	if (uwCMDDIR == REVERSE)
                		TUN_Z_COMFIRM++;
            	}
    		}
    		else{
            	if((-TUN_swZANGLE) >= SpDt_uwAnglePeriod){
                	SpDt_uwPG1CNT_Org1 -= SpDt_uwAnglePeriod;
                	if (uwCMDDIR == FORWARD)
                		TUN_Z_COMFIRM++;
            	}
			}

			if(TUN_Z_COMFIRM >=2)
				stop();	//uvw or pg error

//- PG SWITCH -- ADD SC 10/08/2007
			switch(pr[PG_TYPE]){
			    // [ SIN/COS Signal is changed to AN7, DINO, 08/12/2010
			    case SIN_SIN:
			    	PGSEL = TUN_Z_COUNT<=3 ? 0 : 1;
			    #if NEWIEDCB  // IO Define, Sean, 06/25/2010
#if 1	// add pghs01, Sean, 12/06/2010
					//if ( TUN_SINDATAMIN >= Pgc_uwCpo ){ TUN_SINDATAMIN = Pgc_uwCpo; }
					//if ( TUN_SINDATAMAX <= Pgc_uwCpo ){ TUN_SINDATAMAX = Pgc_uwCpo; }
					//if ( TUN_COSDATAMIN >= Pgc_uwDpo ){ TUN_COSDATAMIN = Pgc_uwDpo; }
					//if ( TUN_COSDATAMAX <= Pgc_uwDpo ){ TUN_COSDATAMAX = Pgc_uwDpo; }   
					TUN_SINDATAMIN = 0;
					TUN_SINDATAMAX = 4095;
					TUN_COSDATAMIN = 0;
					TUN_COSDATAMAX = 4095;

#else			    
			    	if (!PGSEL){  // Inverse SIN/COS, DINO, 09/28/2010, Modify for New PG Card, DINO, 10/20/2010
						if ( TUN_SINDATAMIN >= AN7 ){ TUN_SINDATAMIN = AN7; }
						if ( TUN_SINDATAMAX <= AN7 ){ TUN_SINDATAMAX = AN7; }
			    	}
			    	else{
						if ( TUN_COSDATAMIN >= AN7 ){ TUN_COSDATAMIN = AN7; }
						if ( TUN_COSDATAMAX <= AN7 ){ TUN_COSDATAMAX = AN7; }
			    	}
#endif			    	
			    #else
			    	if (!PGSEL){
						//if ( TUN_SINDATAMIN >= AN8 ){ TUN_SINDATAMIN = AN8; }
						//if ( TUN_SINDATAMAX <= AN8 ){ TUN_SINDATAMAX = AN8; }
                        if ( TUN_SINDATAMIN >= AN02 ){ TUN_SINDATAMIN = AN02; }
						if ( TUN_SINDATAMAX <= AN02 ){ TUN_SINDATAMAX = AN02; }
			    	}
			    	else{
						//if ( TUN_COSDATAMIN >= AN8 ){ TUN_COSDATAMIN = AN8; }
						//if ( TUN_COSDATAMAX <= AN8 ){ TUN_COSDATAMAX = AN8; }
                        if ( TUN_COSDATAMIN >= AN02 ){ TUN_COSDATAMIN = AN02; }
						if ( TUN_COSDATAMAX <= AN02 ){ TUN_COSDATAMAX = AN02; }
			    	}
			    #endif
			    	break;
            	// ]
            	default:
					PGSEL = 1;	// Read ABZ, DINO, 03/09/2010
            	    break;
			}
//- END PG SWITCH -- ADD SC 10/08/2007
		}
    }
    else{
		TUN_uwtemp = PM_uwStart;
    	//MTU21.TCNT = TUN_uwtemp;
        MTU1.TCNT = TUN_uwtemp;
    	while ( TUN_uwtemp&0x8000 ){ TUN_uwtemp += SpDt_uwAnglePeriod; }  // Transfr negtive to positive
    	CRM_uwTheta = (UWORD)(((ULONG)TUN_uwtemp<<16) / SpDt_uwAnglePeriod);
    	if ( PGDIR!=1 )
    		CRM_uwTheta = ~CRM_uwTheta;
    	TUN_uwInitTheta = CRM_uwTheta&0xfffe;  // Set initial theta(even), add by DINO, 07/21/2008

    	if (pr[PG_TYPE]==ABZ_UVW){		//11/06/2007 SCOTTY ABZ TO UVW
    		if (TUN_uwPMTunCnt == 39000){
#if SH7286 //Sean, 02/22/2010
    			//uwPGA = PA.PR.BIT.B6;	// U phase
    			//uwPGB = PA.PR.BIT.B7;	// V phase
    			//uwPGZ = PD.PR.BIT.B24;	// W phase 			
                uwPGA = PORT2.PIDR.BIT.B1;   // U phase
                uwPGB = PORT2.PIDR.BIT.B0;   // V phase
                uwPGZ = PORT9.PIDR.BIT.B2;   // W phase
#endif				
    			TUN_uwUVWsector = (uwPGA<<2) + (uwPGB<<1) + uwPGZ;
    		
//				PFC.PECRH2.WORD = 0x0010;	//GPIO to PGZ
//				PFC.PACRL2.WORD = 0x1110;	//GPIO to PGA,PGB
				PGSEL = 1;	// Read ABZ, DINO, 03/09/2010
    		}
    	}

		if (TUN_uwPMTunCnt == 40000){
    		if ( pr[PG_TYPE]!=SIN_ENDAT && pr[PG_TYPE]!=SIN_HIPER ){	// Don't interrupt Z-pulse when EnDat, dino, 08/29/2008
    			//MTU2S4.TSR.BYTE  &= 0xF7;	// clear TGFD flag
    			//MTU2S4.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable  		
    			MTU6.TSR.BYTE  &= 0xF7;	// clear TGFD flag
    			MTU6.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable  		  
    		}
		}
	}
	
	if (TUN_Z_COUNT&0x01 && CRM_uwTheta<TUN_Z_CAPTURECNT){
//	if (TUN_Z_COUNT&0x01 && CRM_uwTheta< TUN_Z_CAPTURECNT && !TUN_PHASEZ_OK){
		TUN_Z_COUNT++;
		/* [ Delete by DINO, 05/04/2009
		TUN_Z_CAPTURECNTZ = TUN_Z_CAPTURECNT;
		] */
		//MTU2S4.TSR.BYTE  &= 0xF7;	// clear TGFD flag
		//MTU2S4.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable
		MTU6.TSR.BYTE  &= 0xF7;	// clear TGFD flag
        MTU6.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable  
	}

	CRM_uwSinIndex = CRM_uwTheta >> 6;
	CRM_uwCosIndex = ((CRM_uwTheta + 16384) & 0x0FFFF) >> 6;

	SinValue = sine[CRM_uwSinIndex];
	CosValue = sine[CRM_uwCosIndex];

	T32_swIasInPu = AD_swIAPu;
	T32_swIbsInPu = AD_swIBPu;
	abc2dq();

	TsE_swIdssInPu = T32_swIdssOutPu;
	TsE_swIqssInPu = T32_swIqssOutPu;
	Stat2Syn_s2e();

	//-------- d - axis current regulator --------//
//	TUN_uwtemp =  U16xU16divU16(pr[DC_ZSEARCH],13107,100);		//pr[11-33]
	TUN_uwtemp1 = (TUN_uwPMTunCnt>>1);								//Ramp
	if ((TUN_uwtemp1<TUN_uwIdCurr) && TUN_POS_DC_OK==0)
		CUR_swIdseRefPu = TUN_uwtemp1;
	else		
		CUR_swIdseRefPu = TUN_uwIdCurr;
    
    CUR_swIdseFdbPu = TsE_swIdseOutPu;
	CurrentReg_daxis();    
    
    //-------- q - axis current regulator --------//
	CUR_swIqseRefPu =  0;	
    CUR_swIqseFdbPu = TsE_swIqseOutPu;
    CurrentReg_qaxis();    
    
	//Voltage Limit
    TeS_swUdseInPu = sl_limit(CUR_swUdseOutPu, 0, 0x7FFF);
    TeS_swUqseInPu = sl_limit(CUR_swUqseOutPu, 0, 0x7FFF);
    
    Syn2Stat_e2s();
    T23_swUqssInPu = TeS_swUqssOutPu;
    T23_swUdssInPu = TeS_swUdssOutPu;
    dq2abc();
    
	Duty_swTasInPu = T23_swUasOutPu;
	Duty_swTbsInPu = T23_swUbsOutPu;
	Duty_swTcsInPu = T23_swUcsOutPu;
    UabcPu2Duty();

}
//--- end ---2007/06/01---------------------


//---ADDED BY DINO---08/12/2008-----------
void TUN_ZOFFSET(void){
	if ( CMDRUN==RUN ){
		if ( TUN_uwPMTunCnt<40000 ){
			Fcmd = 0;
			TUN_uwPMTunCnt++;
		}
		else{
			Fcmd = (UWORD)COF_ubMPolePair * 5;  // 3rpm / 60sec * pole pairs * (1/0.01Hz)
			TUN_POS_DC_OK = 1;
		}
	}

	if ( TUN_PHASEZ_OK ){ TUN_STEPANG = 0; }

    if (TUN_POS_DC_OK){
		//--- Idle Protection
		TUN_TuningCNT++;
		if ( TUN_TuningCNT==10000 ){  // 1.0sec
			TUN_uwTB1CNT++;
			TUN_TuningCNT = 0;
		}
		if ( TUN_uwTB1CNT>90 )  // RUNNING>90.0sec in 3rpm is unreasonable
			stop();
		//--- End of Idel protection

//- PG SWITCH -- ADD SC 10/08/2007
		if (pr[PG_TYPE]==SIN_SIN){
		    PGSEL = TUN_Z_COUNT<=3 ? 0 : 1;  
		#if NEWIEDCB  // IO Define, Sean, 06/25/2010
#if 1	// add pghs01, Sean, 12/06/2010
			if ( TUN_SINDATAMIN >= Pgc_uwCpo ){ TUN_SINDATAMIN = Pgc_uwCpo; }
			if ( TUN_SINDATAMAX <= Pgc_uwCpo ){ TUN_SINDATAMAX = Pgc_uwCpo; }
			if ( TUN_COSDATAMIN >= Pgc_uwDpo ){ TUN_COSDATAMIN = Pgc_uwDpo; }
			if ( TUN_COSDATAMAX <= Pgc_uwDpo ){ TUN_COSDATAMAX = Pgc_uwDpo; }
#else		
		    if (!PGSEL){  // Inverse SIN/COS, DINO, 09/28/2010, Modify for New PG Card, DINO, 10/20/2010
				if ( TUN_SINDATAMIN >= AN7 ){ TUN_SINDATAMIN = AN7; }	
				if ( TUN_SINDATAMAX <= AN7 ){ TUN_SINDATAMAX = AN7; }
		    }
		    else{
				if ( TUN_COSDATAMIN >= AN7 ){ TUN_COSDATAMIN = AN7; }
				if ( TUN_COSDATAMAX <= AN7 ){ TUN_COSDATAMAX = AN7; }
		    }
#endif		    
		#else
		    if (!PGSEL){
				//if ( TUN_SINDATAMIN >= AN8 ){ TUN_SINDATAMIN = AN8; }
				//if ( TUN_SINDATAMAX <= AN8 ){ TUN_SINDATAMAX = AN8; }
                if ( TUN_SINDATAMIN >= AN02 ){ TUN_SINDATAMIN = AN02; }
				if ( TUN_SINDATAMAX <= AN02 ){ TUN_SINDATAMAX = AN02; }
		    }
		    else{
				//if ( TUN_COSDATAMIN >= AN8 ){ TUN_COSDATAMIN = AN8; }
				//if ( TUN_COSDATAMAX <= AN8 ){ TUN_COSDATAMAX = AN8; }
                if ( TUN_COSDATAMIN >= AN02 ){ TUN_COSDATAMIN = AN02; }
				if ( TUN_COSDATAMAX <= AN02 ){ TUN_COSDATAMAX = AN02; }
		    }
		#endif
		}
		else
			PGSEL = 1;	// Read ABZ, DINO, 03/09/2010
		// ]
//- END PG SWITCH -- ADD SC 10/08/2007

    }
    else{
    	TUN_uwInitTheta = (CRM_uwTheta&0xfffe)+0x8000;  // Set initial theta(even), add by DINO, 07/21/2008
		if (TUN_uwPMTunCnt == 40000){
			TUN_TuningCNT     = 0;
			TUN_uwTB1CNT      = 0;
    		//MTU2S4.TSR.BYTE  &= 0xF7;	// clear TGFD flag
    		//MTU2S4.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable  
    	    MTU6.TSR.BYTE  &= 0xF7;	// clear TGFD flag
            MTU6.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable  
    	}
	}

	if (TUN_Z_COUNT&0x01 /*&& CRM_uwTheta<TUN_Z_CAPTURECNT*/){
		TUN_Z_COUNT++;
		/* [ Delete by DINO, 05/04/2009
		TUN_Z_CAPTURECNTZ = TUN_Z_CAPTURECNT;
		] */
		//MTU2S4.TSR.BYTE  &= 0xF7;	// clear TGFD flag
		//MTU2S4.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable
	    MTU6.TSR.BYTE  &= 0xF7;	// clear TGFD flag
        MTU6.TIER.BYTE |= 0x08;	// TGIED, Z-pulse capture interrupt enable  
	}

	TB2_FOCPM();
}
//--- END ---08/12/2008---------------------



//---ADDED BY SCOTTY---2007/06/04-----------
void TUN_CAL_ZOFFSET(void)
{
	UWORD uw_temp;

//    BRK_RLS = 0;//lock  09/20/2007
//    STtune = 1;	//12/07/2007   // Delete by DINO, 07/10/2008
    
//---09/17/2007 modify SC
	uw_temp = (UWORD)(((ULONG)TUN_Z_CAPTURECNTZ + TUN_Z_CAPTURECNT)>>1);
	if (uw_temp <= SpDt_uwAnglePeriod){
		PG_Zoffset = uw_temp;
	}
	else{
		TUN_PHASEZ_OK = 0;
	}

	// C/D LOSS DETECTION, Add by DINO, 09/05/2008
	if ( pr[PG_TYPE]==SIN_SIN && 0){ //[Delete For IED PG-Card, Sampo, 02/24/2010]
		uw_temp = 0;

		if ( TUN_SINDATAMIN>1900 || TUN_SINDATAMAX<2300 )  // Modify by DINO, 02/23/2011
			uw_temp = 1000;
		else if ( TUN_COSDATAMIN>1900 || TUN_COSDATAMAX<2300 )  // Modify by DINO, 02/23/2011
			uw_temp = 1000;

		if ( uw_temp==1000 ){
			TUN_PHASEZ_OK = 0;
			TUN_TuningCNT = 10000;	// PGF2 if pr[PM_AUTO_T]==1
			TUN_uwTB1CNT  = 10000;	// PGF2 if pr[PM_AUTO_T]==3
		}
	}

} 
//--- END ---2007/06/04---------------------

void TUN_HFSS_4SectionCmd(void)
{
        switch(TUN_Sector){
		    case 1:
		        TUN_swIdseRefPu = COF_uwMIratePu >> 1;
		        //Frequency of Iph is 6000 * 0.4 = 2400, 24.00Hz
		        // 2400 * 2^18 / 60000 = 10485.76 => 10486(Q18)
		        TUN_slFreqPu = 10486;
		        break;
		    case 2:
		        TUN_swIdseRefPu = COF_uwMIratePu >> 1;
		        //Frequency of Iph is 6000 * 0.8 = 4800, 48.00Hz
		        // 4800 * 2^18 / 60000 = 20971.52 => 20972(Q18)
		        TUN_slFreqPu = 20972;
		        break;
		    case 3:
		        TUN_swIdseRefPu = COF_uwMIratePu;
		        //Frequency of Iph is 6000 * 0.4 = 2400, 24.00Hz
		        // 2400 * 2^18 / 60000 = 10485.76 => 10486(Q18)
		        TUN_slFreqPu = 10486;
		        break;
		    case 4:
		        TUN_swIdseRefPu = COF_uwMIratePu;
		        //Frequency of Iph is 6000 * 0.8 = 4800, 48.00Hz
		        // 4800 * 2^18 / 60000 = 20971.52 => 20972(Q18)
		        TUN_slFreqPu = 20972;
		        break;
        	default:
        	    break;
	    }
}

void TUN_HFSS_CalRrL1sigma(void)
{
    UWORD TUN_thetaTmp, uwTemp;    
    SLONG HFSS_Temp1, HFSS_Temp2;

    if (TUN_TuningCNT==0){
	    TUN_slIsqr = 0;
	    TUN_slUsqr = 0;
	    TUN_slP = 0;
	    TUN_slQ = 0;
	    TUN_IntegralCnt = 0;		    

	    if ((TUN_Sector==1)||(TUN_Sector==3)){
	        // 6 * (10000Hz / 24Hz), 6000 = fPWM,
	        TUN_CatchPoint = 2500;
	    }
	    else{
	        // 12 * (10000Hz / 48Hz), 6000 = fPWM,
	        TUN_CatchPoint = 2500;
	    }
    }

    // Calculate U^2, I^2, Power(P) and reactive power(Q) --------------//
    if (TUN_TuningCNT > 2000){
	    if (TUN_TuningCNT <= 6000){
	    	
	    	if ((abs(AD_swIAPu)<(COF_uwMIratePu>>10))&&(TUN_IACrossZero==0)){
	    		TUN_IACrossZero = 1;
	    	}

	    	// TUN_CatchPoint = 833
		    if ((TUN_IntegralCnt < TUN_CatchPoint)&&(TUN_IACrossZero==1)){
		    	TUN_IntegralCnt ++;
		    	//TUN_slUsqr in Q20, then integral 833 times
			    TUN_slUsqr += (((SLONG)TUN_VoltInQ*TUN_VoltInQ)>>10);

			    //TUN_slIsqr in Q20, then integral 833 times
			    TUN_slIsqr += (((SLONG)AD_swIAPu*AD_swIAPu)>>10);

			    //TUN_slP & TUN_slQ in Q20, and integral 833 times
			    TUN_slP += (((SLONG)AD_swIAPu * TUN_VoltInP)>>10);
			    TUN_slQ += (((SLONG)AD_swIAPu * TUN_VoltInQ)>>10);
		    }
	    }
    }

    if (TUN_TuningCNT>6000){
        if (TUN_IntegralCnt<TUN_CatchPoint){
            /*-----------------------------------------------------------------------------
              TuningCNT over 6000 mean section would finish, but if Tun_IntergralCnt don't
              reach catch point, R2 would get error value, here must to calculate again in
              same section.
            -----------------------------------------------------------------------------*/
            TUN_IntegralCnt = 0;
            TUN_slUsqr = 0;
            TUN_slIsqr = 0;
            TUN_slP = 0;
            TUN_slQ = 0;
            TUN_IACrossZero = 0;
            TUN_TuningCNT = 0;
        }
        else{
            /*-----------------------------------------------------------------------------
              TuningCNT over 6000 and IntegralCnt reached catch point, then if current cross
              to zero change next section
            -----------------------------------------------------------------------------*/
	        if (abs(AD_swIAPu) < (COF_uwMIratePu >> 10)){
		        TUN_TuningCNT = 0;
		        TUN_slUdIntPu = 0;
		        TUN_IACrossZero = 0;
				DBheight = 0;
		        switch(TUN_Sector){
    		        case 1:
    			        TUN_Sector = 2;
	    		        TUN_HFSS_P_I1F1 = TUN_slP;		//Q20
		       	        TUN_HFSS_I_I1F1 = TUN_slIsqr;	//Q20
			            break;
    			    case 2:
    			        TUN_Sector = 3;
	    		        TUN_HFSS_P_I1F2 = TUN_slP;		//Q20
		    	        TUN_HFSS_I_I1F2 = TUN_slIsqr;	//Q20
			            break;
// [ Modify the Rr Calculation from VE 2.05, Modify by DINO, 03/02/2009
    			    case 3:
    			        TUN_Sector = 4;
	    		        TUN_HFSS_P_I2F1 = TUN_slP;		//Q20
		    	        TUN_HFSS_I_I2F1 = TUN_slIsqr;	//Q20

    	                /*====== R2 calculation =======================================
	    	            P = I^2 * R + I * Vdead
        	            P1 = I1^2 * R + I1 * Vdead ------ (1)
        	            P2 = I2^2 * R + I2 * Vdead ------ (2) where I2 = k * I1, k = 2
    	                eq(2) - eq(1)*k : P2 - k*P1 = I2^2*R - I1^2*R*k
    	                          (P2 - k*P1)
    	                => R = -----------------
    	                        (I2^2 - I1^2*k)
	    	            =============================================================*/
                        uwTemp = uw_Sqrt32c(U16xU16divU16((TUN_HFSS_I_I2F1>>16), 16384, (TUN_HFSS_I_I1F1>>16)));

        	            //------ In Frequency 1, P2 - 2*P1 = Temp1 ------------------//
        	            HFSS_Temp1 = TUN_HFSS_P_I2F1 - U32xU32divU32(TUN_HFSS_P_I1F1, uwTemp, 128);
                        //------ In Frequency 1, I2^2 - 2*I1^2 = Temp2 --------------//
                        HFSS_Temp2 = TUN_HFSS_I_I2F1 - U32xU32divU32(TUN_HFSS_I_I1F1, uwTemp, 128);

                        //F1: R_f1 = (P2 - 2*P1) / (I2^2 - 2*I1^2), in Q16
                        TUN_HFSS_R_F1 = U32xU32divU32(HFSS_Temp1, 65535, HFSS_Temp2);

			            break;
    			    default:
    			    case 4:
    			        TUN_Sector = 0;
	    		        TUN_HFSS_P_I2F2 = TUN_slP;          //Q20
		    	        TUN_HFSS_I_I2F2 = TUN_slIsqr;  //Q20
		    	        ZeroPWM();

    	                /*====== R2 calculation =======================================
	    	            P = I^2 * R + I * Vdead
        	            P1 = I1^2 * R + I1 * Vdead ------ (1)
        	            P2 = I2^2 * R + I2 * Vdead ------ (2) where I2 = k * I1, k = 2
    	                eq(2) - eq(1)*k : P2 - k*P1 = I2^2*R - I1^2*R*k
    	                          (P2 - k*P1)
    	                => R = -----------------
    	                        (I2^2 - I1^2*k)
	    	            =============================================================*/
                        uwTemp = uw_Sqrt32c(U16xU16divU16((TUN_HFSS_I_I2F2>>16), 16384, (TUN_HFSS_I_I1F2>>16)));

                        //------ In Frequency 2, P2 - 2*P1 = Temp1 ------------------//
                        HFSS_Temp1 = TUN_HFSS_P_I2F2 - U32xU32divU32(TUN_HFSS_P_I1F2, uwTemp, 128);
                        //------ In Frequency 2, I2^2 - 2*I1^2 = Temp2 --------------//
                        HFSS_Temp2 = TUN_HFSS_I_I2F2 - U32xU32divU32(TUN_HFSS_I_I1F2, uwTemp, 128);

                        //F2: R_f2 = (P2 - 2*P1) / (I2^2 - 2*I1^2), in Q15
                        TUN_HFSS_R_F2 = U32xU32divU32(HFSS_Temp1, 32767, HFSS_Temp2);
                        
						/* [ 單位轉換係數修正, Modify by DINO, 03/02/2009 ====================
							2500 V.S 220.0 Vac
							TUN_HFSS_R_F0 = (TUN_HFSS_R_F0/sqrt(2))*(2200/2500)	= 1.5R
							TUN_HFSS_R_F0 = TUN_HFSS_R_F0 * 0.6222				= 1.5R
							TUN_HFSS_R_F0 = TUN_HFSS_R_F0 * 0.6222 *4/3 		= 2.0R -- display L-L resister
							27187 = 0.6222 * 4/3 * 32768
						=====================================================================*/
                       // TUN_HFSS_R_F0 = ((ULONG)(TUN_HFSS_R_F1 - TUN_HFSS_R_F2) * 27187) >> 15;
                       //  TUN_HFSS_R_F0 = ((ULONG)(TUN_HFSS_R_F1 - TUN_HFSS_R_F2) * 29491) >> 15;
                          TUN_HFSS_R_F0 = ((ULONG)(TUN_HFSS_R_F1 - TUN_HFSS_R_F2)) ; //[IM Autotune Modify,Sampo,2018/07/12]
                                                       
                        if (TUN_HFSS_R_F0>TUN_uwRsPu)
                            TUN_uwRrPu = TUN_HFSS_R_F0 - TUN_uwRsPu;    //Q15
                        else{
                            if(Error ==0){ //[Other erroe cause AUE_ERR,lyabryan,2016/06/12]
                                Error = AuE_ERR;
                            }
                        }

		                /*====== L1x Calculation ======================================
		                                   Q        Q * U^2           U^2
		                X1 = (Lx * W1) = ----- = ------------- = -------------
		                                  I^2      P^2 + Q^2      P*(P/Q)+ Q
                        =============================================================*/
                        TUN_slPQSquare = S32xS32divS32(TUN_slP, TUN_slP, TUN_slQ) + TUN_slQ;    //Q20    		            
                        //Q(20+15) - Q20 = Q15
                        TUN_slXpu = S32xS32divS32(TUN_slUsqr, 32768, TUN_slPQSquare);      //Q15
                        //TUN_slFreqPu in Q18, TUN_slXpu in Q15
                        //Q(15+13) - Q18 = Q10
                        //TUN_slFreqPu = fcmd * 0x40000 / Fb
                        //TUN_uwL1sigmaPu(Q10) = X * Fb / fcmd, and COF_uwLbRe = Rb / (2 * pi * Fb)
                        TUN_uwL1sigmaPu = (SWORD)(S32xS32divS32(TUN_slXpu,8192,TUN_slFreqPu));

		                TUN_HFSS_OK = 1;
		                break;
// ] End on 03/02/2009
	            }
	        }
	    }
	}
	//====== PWM calculate =============================================//
	//Theta = Theta + DeltaTheta * TUN_swIphFreqPu, (0-360) = (0-65535)
	// CRM_slFlxFreqPu in Q18, COF_ulKTheta in Q16
	// 262144 = 2^18, because Fb scale 100, so COF_ulKTheta sacle 100
	TUN_thetaTmp = S32xS32divS32(COF_ulKTheta,TUN_slFreqPu,26214400);
  TUN_thetaTmp = S32xS32divS32(TUN_thetaTmp,5,3); //[IM Autotune Modify,Sampo,2018/07/12]
	CRM_uwTheta = ((CRM_uwTheta + TUN_thetaTmp) & 0x0FFFF);

	// sin table have 1024 data, and max=+32767, min=-32767
	CRM_uwSinIndex = CRM_uwTheta >> 6;
	//90 degree map to Q16 is 16384
	CRM_uwCosIndex = ((CRM_uwTheta + 16384) & 0x0FFFF) >> 6; 	  

	SinValue = sine[CRM_uwSinIndex];    //Q15
	CosValue = sine[CRM_uwCosIndex];    //Q15

	if (TUN_TuningCNT==0){
	    if (abs(AD_swIAPu) <= TUN_swIdseRefPu){
	    	TUN_slUdIntPu = TUN_slUdIntPu + 2;  //Q16
	        if (TUN_slUdIntPu > 65536)
	            TUN_slUdIntPu = 65536;
	    }
	    else
	        TUN_TuningCNT ++;
	}
	else
	    TUN_TuningCNT ++;

	// Calculate Ta, Tb, Tc & wave form output -------------------------//
	TUN_swUalfa = ((SLONG)TUN_slUdIntPu * CosValue)>>16;  //Q15
	TUN_swUbeta = ((SLONG)TUN_slUdIntPu * SinValue)>>16;  //Q15

	Duty_swTasInPu = TUN_swUalfa;
	Duty_swTbsInPu = -(TUN_swUalfa >> 1);
	Duty_swTcsInPu = -(TUN_swUalfa >> 1);	    

	UabcPu2Duty();	    

	//TUN_VoltInP & TUN_VoltInQ in Q15
	// where Z1 mean, this time PWM output, AD sample was the last time value
	TUN_VoltInP = TUN_UalfaZ1;
	TUN_VoltInQ = TUN_UbetaZ1;

	TUN_UalfaZ1 = TUN_swUalfa;
	TUN_UbetaZ1 = TUN_swUbeta;        
}

void TUN_HFSSTB2_OK(void)
{
   		            
	TUN_TuningCNT = 0;
	CRM_uwTheta = 0;
	TUN_slUdIntPu = 0;
	TUN_VoltInP = 0;
	TUN_VoltInQ = 0;
	TUN_swUalfa = 0;
	TUN_UalfaZ1 = 0;
	TUN_swUbeta = 0;
	TUN_UbetaZ1 = 0;
	TUN_IntegralCnt = 0;
	TUN_slUsqr = 0;
	TUN_slIsqr = 0;
	TUN_slP = 0;
	TUN_slQ = 0;
	//TUN_HFSS_P_I1F1 = 0;
	//TUN_HFSS_P_I1F2 = 0;
	//TUN_HFSS_P_I2F1 = 0;
	//TUN_HFSS_P_I2F2 = 0;
	//TUN_HFSS_I_I1F1 = 0;
	//TUN_HFSS_I_I1F2 = 0;
	//TUN_HFSS_I_I2F1 = 0;
	//TUN_HFSS_I_I2F2 = 0;
}

void TUN_NLRotaryTB2_INLm(void)
{
    UWORD SectionVtemp;
    UWORD uwSpdCmd, uwFcmdMax;
    
    T32_swIasInPu = AD_swIAPu;
    T32_swIbsInPu = AD_swIBPu;
    abc2dq();

    TsE_swIdssInPu = T32_swIdssOutPu;
    TsE_swIqssInPu = T32_swIqssOutPu;
    Stat2Syn_s2e();    
    
    uwSpdCmd = abs(TB1_slSpdCmdPu>>16);
    uwFcmdMax = (TUN_slFcmdPuMax>>16);
	switch(TUN_Sector){
	    // LPF algorithm:
	    //	Y(S) = X(S) / (1+TS).
	    //	x: input, y: output, T: time constant of the LPF.
	    // Implementation:
	    //	y(n) = ( y(n-1)*TUN_NLRLPG + x(n) ) / (TUN_NLRLPG+1).
	    //	TUN_NLRLPG = T / Tctrl.		    
		case 1:
		    if (uwSpdCmd >= uwFcmdMax){
                SectionVtemp = TUN_NLRV2; //[IM Autotune Modify,Sampo,2018/07/12]
		    }
		    break;
		case 2:
		    SectionVtemp = TUN_NLRV2;
		    break;
		case 3:
		    SectionVtemp = TUN_NLRV3;
		    break;
		case 4:
		    SectionVtemp = TUN_NLRV4;
		    break;
		case 5:
		    SectionVtemp = TUN_NLRV5;
		    break;
		case 6:
		    SectionVtemp = TUN_NLRV6;
		    break;
		case 7:
		    SectionVtemp = TUN_NLRV7;
		    break;
			
		default:
		case 0:
		    SectionVtemp = TUN_NLRV3;
		    break;
    }
        
    TUN_uwUd_K = ((ULONG)TUN_uwUd_K * (TUN_NLRLPG - 1) + SectionVtemp)/TUN_NLRLPG;
        
    TUN_swUoutPu = ((ULONG)VFTB1_swUoutPu * TUN_uwUd_K)>>14;        
        
    if ((UWORD)TUN_swUoutPu >= COF_uwVratePu)
   	    TUN_swUoutPu = COF_uwVratePu;

    CUR_swUdseOutPu = 0;
    CUR_swUqseOutPu = TUN_swUoutPu;

    CRM_slSpdPu = TB1_slSpdCmdPu;
    CurrentMod_noPG();

    TeS_swUdseInPu = CUR_swUdseOutPu;
    TeS_swUqseInPu = CUR_swUqseOutPu;
    Syn2Stat_e2s();

    T23_swUqssInPu = TeS_swUqssOutPu;
    T23_swUdssInPu = TeS_swUdssOutPu;
    dq2abc();        

    Duty_swTasInPu = T23_swUasOutPu;
    Duty_swTbsInPu = T23_swUbsOutPu;
    Duty_swTcsInPu = T23_swUcsOutPu;
    UabcPu2Duty();

        
    if (TUN_Sector<=7){     

       	if (TUN_TuningCNT==0){
       		TUN_swUqssPuZ1 = 0;
       		TUN_IntegralCnt = 0;
       		TUN_IACrossZero = 0;
       	}
        	
       	if (TUN_TuningCNT >= 12000){
       		if (TUN_IntegralCnt==0){
				TUN_slIsqr = 0;
       			TUN_slUsqr = 0;
       			TUN_slP = 0;
       			TUN_slQ = 0;        			
       		}

       		// Start integration when voltage phase angle is over 90 degree
   		    //  mean current is crossing zero
   		    if ((abs(AD_swIAPu)<(COF_uwMIratePu>>10))&&(TUN_IACrossZero==0)){
   	    		TUN_IACrossZero = 1;
   	    	}       	        

       		if ((TUN_IntegralCnt <TUN_CatchPoint)&&(TUN_IACrossZero==1)){
       		    TUN_IntegralCnt ++;      			    
                // alfa -> d axis
                // beta -> q axis
                TUN_slQ += ((SLONG)TUN_swUqssPuZ1*T32_swIdssOutPu)>>10;
                TUN_slP += ((SLONG)TeS_swUdssOutPu*T32_swIdssOutPu)>>10;
                TUN_slIsqr += ((SLONG)AD_swIAPu*AD_swIAPu)>>10;
                TUN_slUsqr += ((SLONG)TeS_swUdssOutPu*TeS_swUdssOutPu)>>10;
            }
            else{
                /*====== Lmx calculation ==========================================
                mode 1:
                  X = Q/I^2 (Deadtime would effect I)                      
                mode 2:
                  X = Q/I^2 = Q*U^2/S^2 = Q*U^2/(P^2+Q^2) = U^2/(P*(P/Q)+Q) 
                      
                  L = X/f (with p.u value), L = U^2/(Q*f)                          
                =================================================================*/                    
              	//TUN_slXpu is in Q(20+20-20) = Q20
               	TUN_slXpu = S32xS32divS32(abs(TUN_slQ), 0x100000, TUN_slIsqr);

               	//TUN_uwLmPu is in Q(20+17-31) = Q6
                TUN_uwLmPu = S32xS32divS32(TUN_slXpu, 0x20000, TUN_slFcmdPuMax);    //Q6
					                           
                /*====== (I-noload)^2 calculation =================================
                mode 1:
                  Irms^2 = Q/X

                mode 2:
                  1/2(Imax^2) = (1/T)integral(Ia^2)
                  Irms^2 = (1/T)integral(Ia^2)
                =================================================================*/
                //TUN_slI0sqr is in Q(20+30-20) = Q30
                // where 0x13AB2D = 1289005 = 2^30/833
                // here must *2, because from Irms -> Imax, 0x13AB2D * 2 = 0x27565B
                TUN_slI0sqr = S32xS32divS32(abs(TUN_slQ), 0x27565B, TUN_slXpu);                        

                switch(TUN_Sector){
                   	default:
                   	case 0:
                    case 7:// 10/10
                        break;
                    case 6:// 6/10
                        TUN_uwLmx6Pu = TUN_uwLmPu;
                        TUN_slI0Sqr6 = TUN_slI0sqr;
                        TUN_slX6 = (TUN_slXpu >> 6);    //Q14
                        break;
                    case 5:// 8/10
                        TUN_uwLmx5Pu = TUN_uwLmPu;
                        TUN_slI0Sqr5 = TUN_slI0sqr;
                        TUN_slX5 = (TUN_slXpu >> 6);    //Q14
                        break;
                    case 4:// 9/10
                        TUN_uwLmx4Pu = TUN_uwLmPu;
                        TUN_slI0Sqr4 = TUN_slI0sqr;
                        TUN_slX4 = (TUN_slXpu >> 6);    //Q14
                        break;
                    case 3://10/10
                        TUN_uwLmxPu = TUN_uwLmPu;
                        TUN_slI0Sqr3 = TUN_slI0sqr;
                        slXsNPu = (TUN_slXpu >> 5);     //Q15
                        break;
                    case 2://11/10
                        TUN_uwLmx2Pu = TUN_uwLmPu;
                        TUN_slI0Sqr2 = TUN_slI0sqr;
                        break;
                    case 1://12/10
                        TUN_uwLmx1Pu = TUN_uwLmPu;
                        TUN_slI0Sqr1 = TUN_slI0sqr;
                        break;
                }                     
            }//End of TUN_IntegralCnt <=833                
        }//End of TUN_TuningCNT >= 6000
            
        TUN_swUqssPuZ1 = TeS_swUqssOutPu;   

        if (uwSpdCmd>=uwFcmdMax){
          	if ((TUN_TuningCNT>>1)<=12000)
           	    TUN_TuningCNT ++;
           	else{
           	    //when TUN_TuningCNT > (6000*2) change the section
           	    TUN_Sector ++;            	    
         	    TUN_TuningCNT = 0;    
            }
        }
        else
            TUN_TuningCNT = 0;            
    }// End of TUN_Sector != 7
    else{
   	   	TUN_ROTARY_OK = 1;
   	   	stop();
   	}
} 

void TUN_NLRotary_OK(void)
{
    //TUN_uwI0Pu is in sqrt[Q30] = Q15
    TUN_uwI0Pu = uw_Sqrt32c(TUN_slI0Sqr3);
		  
	//TUN_uwLmPu in Q6, TUN_uwL1sigmaPu in Q10
	TUN_uwLm1Pu = TUN_uwLmxPu - (TUN_uwL1sigmaPu >> 4);
	        
	slEsNPu = ((ULONG)TUN_uwI0Pu * slXsNPu)>>15;    //Q(15+15-15) = Q15
    
	// Calculate flux curve table.
	// Lmx (%Q13) = Xsx / XsN.
	// Fluxx (%Q14) = Esx / EsN = Xsx * Isx / EsN. (for 3 points of under excitation)
	// Imx (%Q14) = Imx / ImN. ( for 2 points of over excitation)
	
	//TUN_uwLmx1Pu in Q6
	pr[LMPU6] = U16xU16divU16(TUN_uwLmx1Pu,0x2000,TUN_uwLmxPu);
	pr[LMPU5] = U16xU16divU16(TUN_uwLmx2Pu,0x2000,TUN_uwLmxPu);
	pr[LMPU3] = U16xU16divU16(TUN_uwLmx4Pu,0x2000,TUN_uwLmxPu);
	pr[LMPU2] = U16xU16divU16(TUN_uwLmx5Pu,0x2000,TUN_uwLmxPu);
	pr[LMPU1] = U16xU16divU16(TUN_uwLmx6Pu,0x2000,TUN_uwLmxPu);
	
	
	//TUN_uwX4 is Q22, Q((30/2)+14-15) = Q14
	pr[EMFPU3] = U32xU32divU32(uw_Sqrt32c(TUN_slI0Sqr4), TUN_slX4, slEsNPu);
	pr[EMFPU2] = U32xU32divU32(uw_Sqrt32c(TUN_slI0Sqr5), TUN_slX5, slEsNPu);
	pr[EMFPU1] = U32xU32divU32(uw_Sqrt32c(TUN_slI0Sqr6), TUN_slX6, slEsNPu);
	
	//TUN_slI0Sqr1 is Q22, Q(((30/2)+14-15) = Q14
	pr[EMFPU6] = U16xU16divU16(uw_Sqrt32c(TUN_slI0Sqr1), 0x4000, TUN_uwI0Pu);
	pr[EMFPU5] = U16xU16divU16(uw_Sqrt32c(TUN_slI0Sqr2), 0x4000, TUN_uwI0Pu);
	
	WRITE_FLUXPR = 1;
}

void TUN_CalLmbyPr(void)
{
    
    UWORD VratePh, Frate, Par_Lm, BackEmf;
    UWORD CaluwTemp1, CaluwTemp2;
    ULONG CalulTemp1;
    WGOFF;
    TUN_uwI0Pu = COF_uwI0Pu;
    //*********************** Par_Lm = Lm + Lx Calculation ***************************
    //Lm Calculation based on I0^2 obtained in rotary test and user-input IN, PN, SN
    // Algorithm: 	Par_Lm = Lm+Lx
    //				wn*(Lm+Lx)= E1/I0
    //				E1 = VratePh - (I0*Rs)^2/VratePh
    //================================================================================
    // COF_uwVbRe: max. phase voltage,Q16
    CaluwTemp1 = ((ULONG)vbase * 53509)>>16;             //53509 = sqrt(2/3) * 2^16
    VratePh = U16xU16divU16(CaluwTemp1, 16384, COF_uwVbRe); //VratePh: Q14

   	Frate = U16xU16divU16(fbase, 32768, COF_uwFbRe);    //Frate: Q15
    
    CaluwTemp1 = ((ULONG)COF_uwI0Pu * Frate) >> 16;         //Q(15+15-16) = Q14
    
    //------ Calculate Vph^2 - (I0*Rs)^2 -----------------------------------//
    CaluwTemp2 = ((ULONG)COF_uwI0Pu * TUN_uwRsPu)>>16;      //Q(15+15-16) = Q14
    CalulTemp1 = ((ULONG)VratePh*VratePh) - ((ULONG)CaluwTemp2*CaluwTemp2);
    BackEmf = uw_Sqrt32c(CalulTemp1);
    
    //------ Calculate (Vph^2 - (I0*Rs)^2)/wn*I0*VratePh -------------------//
    Par_Lm = U32divU16(((ULONG)BackEmf*64), CaluwTemp1);    //Par_Lm: Q6
    
    //TUN_uwLmPu in Q6, TUN_uwL1sigmaPu in Q10
	TUN_uwLm1Pu = Par_Lm - (TUN_uwL1sigmaPu >> 4);
    
}

void Static_Test1(void)
{
	switch(TUN_Method){
	    case DC_TEST:
		    if (TUN_WAIT==1){    		    	
    	   	    TUN_TuningCNT++;
    	   	    WGOFF;
    	   	    if (TUN_TuningCNT > 3000){
    	   	    	WGON;
    	   	    	ZeroPWM();    	   	    	
    	   		    TUN_WAIT = 0;
    	   		    TUN_DCVarInit();    	   		    
    	   	    }
    	    }
    	
    	    if ((TUN_WAIT==0)&&(TUN_DC_OK==0)){
                TUN_DC_Cmd();
                // 10000 * 100us = 1s
		        if ((IrmsAD<=68)&&(TUN_TuningCNT>=5000)){// IrmsAD <= 5% rated current
                    if(Error == 0){ //[Other erroe cause AUE_ERR,lyabryan,2016/06/12]
		                Error = AuE_ERR;
		            }
                }
            }
        
    	    if (TUN_DC_OK==1){
    	   	    TUN_DC_CalRs();

//--- ADDED BY SCOTTY 2007/02/06----------- 
				if (pr[PM_AUTO_T]==2){
					TUN_Method = PMLS_TEST;
					TUN_Sector = 1;
					TUN_WAIT = 1;			//waiting enable (300ms)
                }
//--- END 2007/02/06-----------
                else {
					TUN_DCVarInit();
	            	TUN_Method = HFSS_TEST;
	            	TUN_Sector = 1;
	            	TUN_WAIT = 1;
	            	TUN_HFSS_OK = 0;					
				}
    	    } break;
//--- ADDED BY SCOTTY 2007/02/06-----------  	    
	    case PMLS_TEST:
	        if (TUN_WAIT==1){    	
			    WGOFF;	    	
			    TUN_TuningCNT++;
			    if (TUN_TuningCNT > 3000){
				    WGON;
				    TUN_TuningCNT = 0;
				    TUN_WAIT = 0;
				    TUN_DCVarInit();
			    }
	        } 	
	        if ((TUN_WAIT==0)&& (TUN_DC_OK==1)){    	                              	  	
			    TUN_PMLS_3Section();  
	        }
	        break;
//--- END 2007/02/06-----------   	    

//--- ADDED BY SCOTTY 2007/06/01-----------
		case PGZ_DETECT:
			if ( pr[PM_AUTO_T]==1 ){
				//-- Waiting for 300ms
		        if (TUN_WAIT==1){    		    	
    	   	   	   	TUN_TuningCNT++;
    	   	   	   	WGOFF;
    	   	   	   	if (TUN_TuningCNT > 3000){
    	   	   	   		WGON;
    	   	   	   		ZeroPWM();    	   	    	
    	   	   	    	TUN_WAIT = 0;
    	   	   	    	TUN_DCVarInit();  
    	   	   	    	Init_FOCPG();	   		    
    	   	   	   	}
    	        }		
	            else  //-- TUN_WAIT==0
				    TUN_PGZ_Section(); 
			}
			else {  // pr[PM_AUTO_T]==3, 08/11/2008
//				WGON;
				TUN_WAIT = 0;
				TUN_ZOFFSET();
			} 
	        break;    	    	
//--- END 2007/06/01-----------------------

     	case HFSS_TEST:
		    TUN_HFSS_4SectionCmd();
    		    
            if (TUN_WAIT==1){    	
                WGOFF;	    	
    	        TUN_TuningCNT++;
    	        if (TUN_TuningCNT > 3000){
    	            WGON;
    	 		    TUN_TuningCNT = 0;
    		        TUN_WAIT = 0;
    		        DBheight = 0;
    		    }
    	    }
    	
    	    if ((TUN_WAIT==0)&&(TUN_HFSS_OK==0)&&(TUN_DC_OK==1)){
                TUN_HFSS_CalRrL1sigma();
            }
        
    	    if (TUN_HFSS_OK==1){
    	  	    TUN_HFSSTB2_OK();    	  	    
            } break;
        default:
            break;
	}
}

void Rolling_Test1(void)
{
	UWORD AT_Vcmd;
	
	switch(TUN_Method){
		case ROTARY_TEST:
	        AT_Vcmd = GetFx2Vm(fcmd.uw.hi);
    
   	        VFTB1_swUoutPu = U16xU16divU16(AT_Vcmd , 26755, COF_uwVbRe);
   	        if ((UWORD)VFTB1_swUoutPu >= COF_uwVratePu)
   	            VFTB1_swUoutPu = COF_uwVratePu;

            fout.ul = fcmd.ul;

            SPR_slSpdRefPu = TB1_slSpdCmdPu;
            SPR_slSpdFdbPu = TB1_slSpdCmdPu;
	
	        if (TUN_WAIT==1){
                TUN_TuningCNT++;
                if (TUN_TuningCNT > 3000){
    	            TUN_TuningCNT = 0;
    		        TUN_WAIT = 0;
    		    		
    		        Init_TransferValue();
    		    		
    		        fcmd.uw.hi = fmin;
    		        ftemp.uw.hi = fmin;
    		        
    		    	uwFkeypad = ((ULONG)fbase * 43691)>>16;
    		    	Fcmd = uwFkeypad;
	                
	                TUN_Sector = 0;
	                // fbase * (2/3) => TUN_slFcmdPuMax, where (2/3) in Q31 is 1431655765 = 0x55555555
	                TUN_slFcmdPuMax = U32xU32divU32(fbase,0x55555555,COF_uwFbRe);
    		    	
    		        TUN_CatchPoint = 833;
    		        //TUN_uwUd_K = 65536;
                    TUN_uwUd_K = 0;           //Need verify Bernie
    	        }
            }
    
            if ((TUN_WAIT==0)&&(TUN_HFSS_OK==1)&&(TUN_DC_OK==1)){
                TUN_NLRotaryTB2_INLm();
            } break;
        default:
            break;
    }
}

void CurGainPWMSetup(void)
{
    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 7 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P7nPFS PSEL[4:0]                                           //
    // Bit[76]          1        0          0         1           00001b              :P76  MTIOC4D       GZ1         //
    // Bit[75]          1        0          0         1           00001b              :P75  MTIOC4C       GY1         //
    // Bit[74]          1        0          0         1           00001b              :P74  MTIOC3D       GX1         //
    // Bit[73]          1        0          0         1           00001b              :P73  MTIOC4B       GW1         //
    // Bit[72]          1        0          0         1           00001b              :P72  MTIOC4A       GV1          //
    // Bit[71]          1        0          0         1           00001b              :P71  MTIOC3B       GU1          //
    // Bit[70]          0        0          0         1           00111b              :P70  POE0#      OC/CC/GFF  //
    // ======================================================== //
      
    //Setup special PWM operation for current calibration
	//PFC.PECRL3.BIT.PE9MD  = 1;   	       //A+  PE9/TIOC3B as TIOC3B function pin
	//PFC.PECRL3.BIT.PE11MD = 1;   	//A-  PE11/TIOC3D as TIOC3D function pin

    MPC.P71PFS.BYTE = 0x01;         //A+  P71/TIOC3B as TIOC3B function pin
	MPC.P74PFS.BYTE = 0x01;         //A-  P74/TIOC3D as TIOC3D function pin
    
	//PFC.PECRL4.BIT.PE12MD = 0;   	//B+ :PE12/TIOC4A as general input/output
	//PFC.PEIORL.BIT.B12  = 1;   		//B+ :PE12/TIOC4A as general output
	//PE.DR.BIT.B12 = 1;				//B+ :Output 1

    MPC.P72PFS.BYTE = 0x01;         //B+ :P72/TIOC4A as general input/output
    PORT7.PDR.BIT.B2 = 0x01;        //B+ :P72/TIOC4A as general output
    PORT7.PODR.BIT.B2 = 0x01;       //B+ :Output 1
    
	//PFC.PECRL4.BIT.PE14MD = 0;  	//B- :PE14/TIOC4C as general input/output
	//PFC.PEIORL.BIT.B14  = 1;		//B- :PE14/TIOC4C as general output
	//PE.DR.BIT.B14 = 0;				//B- :Output 0 

    MPC.P75PFS.BYTE = 0x01;         //B- :P75/TIOC4C as general input/output
    PORT7.PDR.BIT.B5 = 0x01;        //B- :P75/TIOC4C as general output
    PORT7.PODR.BIT.B5 = 0x01;       //B- :Output 0 

	//PFC.PECRL4.BIT.PE13MD = 0;   	//C+ :PE13/TIOC4B as general input/output
	//PFC.PEIORL.BIT.B13  = 1;		//C+ :PE13/TIOC4B as general output
	//PE.DR.BIT.B13 = 1;				//C+ :Output 1

    MPC.P73PFS.BYTE = 0x01;         //B- :P73/TIOC4C as general input/output
    PORT7.PDR.BIT.B3 = 0x01;        //B- :P73/TIOC4C as general output
    PORT7.PODR.BIT.B3 = 0x01;       //B- :Output 0 
	
	//PFC.PECRL4.BIT.PE15MD = 0;   	//C- :PE15/TIOC4D as general input/output
	//PFC.PEIORL.BIT.B15  = 1;		//C- :TIOC4D as general output
	//PE.DR.BIT.B15 = 1;				//C- :Output 1

    MPC.P76PFS.BYTE = 0x01;         //B- :P76/TIOC4C as general input/output
    PORT7.PDR.BIT.B6 = 0x01;        //B- :P76/TIOC4C as general output
    PORT7.PODR.BIT.B6 = 0x01;       //B- :Output 0 

}

void CurGainCalib(void)
{
    UWORD TUN_uwKi, TUN_uwKp;
	SWORD TUN_swIerrPu;
	
	TUN_uwKp = pr[CALI_P];
	TUN_uwKi = pr[CALI_I];
    
    TUN_swIdseRefPu = 6000;
	TUN_swIdseFdbPu = AD_swIAPu;	
    
    TUN_swIerrPu = TUN_swIdseRefPu - TUN_swIdseFdbPu;
	    
    //------ Current Regulator PI --------------------------------------//	
	TUN_slUdIntPu = TUN_slUdIntPu + (((SLONG)TUN_swIerrPu * TUN_uwKi)>>16);
	if (TUN_slUdIntPu >= 24576)
	    TUN_slUdIntPu = 0x6000;
	else if (TUN_slUdIntPu <= (-24576))
	    TUN_slUdIntPu = -24576;
	
	TUN_swUoutPu = TUN_slUdIntPu + (((SLONG)TUN_swIerrPu * TUN_uwKp)>>16);
	if (TUN_swUoutPu >= 0x6000)
	    TUN_swUoutPu = 0x6000;
	else if (TUN_swUoutPu <= (-24576))
	    TUN_swUoutPu = -24576;
	
    //------ Wave Form processing --------------------------------------//       
    Duty_swTasInPu = TUN_swUoutPu;
    Duty_swTbsInPu = 0;
    Duty_swTcsInPu = 0;
	
    UabcPu2Duty();
    
    TUN_TuningCNT++;
    
    if ((TUN_TuningCNT>10000)&&(TUN_TuningCNT<11025)){
        CCB_slIaSum += AD_swIAPu;
        CCB_slIbSum += AD_swIBPu;
    }
    
    if (TUN_TuningCNT > 11050){        
        uwCurCalibRatio = U32xU32divU32(CCB_slIaSum, 16384, (-CCB_slIbSum));
        
        if ((uwCurCalibRatio>18022)||(uwCurCalibRatio<14745))
            uwCurCalibRatio = 16384;            
            
        stop();
    }
}

void TUN_ACSmpl(void)
{
    SWORD swUalfaPu, swUbetaPu;
    SWORD swIalfaPu, swIbetaPu;
    
    swUalfaPu = TeS_swUdssOutPu;
    swUbetaPu = TeS_swUqssOutPu;
    swIalfaPu = AD_swIAPu;
    swIbetaPu = 0;
  #if 0
	TUN_slUsqr += ((SLONG)swUalfaPu*swUalfaPu >> 3);	// (Q27).
	TUN_slIsqr += ((SLONG)swIalfaPu*swIalfaPu >> 6);	// (Q24).
	TUN_slP += (((SLONG)swUalfaPu*swIalfaPu+(SLONG)swUbetaPu*swIbetaPu) >> 6);	// (Q24)
	TUN_slQ += (((SLONG)swUbetaPu*swIalfaPu-(SLONG)swUalfaPu*swIbetaPu) >> 3);	// (Q27)
  #else
  	#if 0
	TUN_slUsqr += ((SLONG)swUalfaPu*swUalfaPu >> 8);	// (Q22).
	TUN_slIsqr += ((SLONG)swIalfaPu*swIalfaPu >> 8);	// (Q22).
	TUN_slP += (((SLONG)swUalfaPu*swIalfaPu+(SLONG)swUbetaPu*swIbetaPu) >> 8);	// (Q22)
	TUN_slQ += (((SLONG)swUbetaPu*swIalfaPu-(SLONG)swUalfaPu*swIbetaPu) >> 8);	// (Q22)
	#else
	TUN_slUsqr += ((SLONG)swUalfaPu*swUalfaPu >> 10);	// (Q20).
	TUN_slIsqr += ((SLONG)swIalfaPu*swIalfaPu >> 10);	// (Q20).
	TUN_slP += (((SLONG)swUalfaPu*swIalfaPu+(SLONG)swUbetaPu*swIbetaPu) >> 10);	// (Q20)
	TUN_slQ += (((SLONG)swUbetaPu*swIalfaPu-(SLONG)swUalfaPu*swIbetaPu) >> 10);	// (Q20)
	#endif	    
  #endif
}

void TUN_CalcEmLmN(void)
{
    /*=================================================================================*/
    /* LmN = EmN / (ImN*WN)                                                            */
    /*       sqrt{[(UN/sqrt(3))-ImN*R1]^2 - (IN^2-ImN^2)*XsigaN^2} - ImN*XsigaN        */
    /* LmN = ------------------------------------------------------------------        */
    /*                                             ImN*Wn                              */
    /*=================================================================================*/
    UWORD uwTemp, uwUNTemp, uwXxPu;
    ULONG ulTemp, ulTemp2;
    /*
	Algorithm:
	//	Em = SQRT((UNph-I0*Rs)^2 - (IN^2-I0^2)*(Xx^2)) - I0*Xx
	*/    
    // (Q30) = (UN/sqrt(3) - ImN*R1)^2
    uwUNTemp = U16xU16divU16(18919, vbase, COF_uwVbRe);    //18919 = 32768/sqrt(3)
    uwTemp = uwUNTemp - (((ULONG)TUN_uwImNPu*TUN_uwRsPu)>>15);
    ulTemp = (ULONG)uwTemp*uwTemp;

    // (Q13) = Lx*fN, TUN_uwL1sigmaPu:Q10,  COF_uwFRatePu: Q15
    uwXxPu = ((ULONG)TUN_uwL1sigmaPu * COF_uwFRatePu)>>12;
    
    // (Q19) = (IN^2-ImN^2), COF_uwMIratePu: Q15,  TUN_uwImNPu: Q15
    ulTemp2 = ((ULONG)COF_uwMIratePu*COF_uwMIratePu - (ULONG)TUN_uwImNPu*TUN_uwImNPu)>>11;
    
    // (Q17) = (IN^2-ImN^2)*Xx
    ulTemp2 = ((UDOUBLE)ulTemp2 * uwXxPu)>>15;
    
    // (Q30) = (UN/sqrt(3)-ImN*Rs)^2 - (IN^2-ImN^2)*(Xx^2)
    ulTemp = ulTemp - ((ULONG)ulTemp2 * uwXxPu);
    
    // Em (Q15) = SQRT((UN/sqrt(3)-I0*Rs)^2 - (IN^2-I0^2)*(Xx^2)) - I0*Xx
    uwTemp = ((ULONG)TUN_uwImNPu * uwXxPu)>>13;
    TUN_uwEmNPu = uw_Sqrt32c(ulTemp) - uwTemp;
    
    //2006/5/23 下午 03:33:46 Max.SJ.Chang uwTemp = ((ULONG)TUN_uwImNPu * COF_uwFRatePu) >> 15;	// (Q15).
  
}

/*************************************************************** 
 Function: TUN_uwCalcIm
 Description:	Calculate Im with Is, fs, Tr.
 Called by: TUN_QMethod
 Input Variables: Is, fs, Tr
 Output/Return Variables: Im
 Subroutine Call: N/A
 Reference: N/A
****************************************************************/
static UWORD TUN_uwCalcIm(UWORD Is, UWORD fs, UWORD Tr)
{
    //Is:Q15 & fs:Q15 & Tr:Q4
    
	//Im = Is / SQRT(1+(fs*Tr)^2).
	UWORD	uwTemp;
	ULONG	ulTemp;

	uwTemp = ((ULONG) fs * Tr)>>10;		// Q9 = Q(15+4-10)
	ulTemp = uwTemp * uwTemp;			// Q18
	//Q15 = Q(15+9 - sqrt(Q18)) 
	uwTemp = U16xU16divU16(Is, 512, uw_Sqrt32c(ulTemp + 262144));
	return	uwTemp;
}

/*************************************************************** 
 Function: TUN_CalcZLFSL
 Description:	Calculate Z = R+jX and 
                RMS stator current with sampled and 
 				integrated AC voltage, current, active power and 
 				reactive power.
 Called by: TUN_LFSSIdle
****************************************************************/
void TUN_CalcZLFSL(SLONG slPPu, SLONG slQPu, SLONG slUsqrPu, SLONG slIsqrPu, UWORD CatchPoint)
{
    //SLONG slTemp1;  
  #if (CALC_X_METHOD)
    // algorithm: X = Q/I^2, R = X*(P/Q).
    #if 0
    //slPPu:Q22 & slQPu:Q22 & ulUsqrPu:Q22 & ulIsqrPu:Q22
  	uwXPu = S32xS32divS32(slQPu, 16384, slIsqrPu);      //Q(22+14-22) = Q14
  	
    uwRPu = S32xS32divS32(uwXPu, slPPu, slQPu);         //Q(14+22-22) = Q14
	
	uwIsPu = uw_Sqrt32c(U32xU32divU32(slIsqrPu, 256, CatchPoint));	// sqrt(Q(22+8))=Q15
	#else
    //slPPu:Q20 & slQPu:Q20 & ulUsqrPu:Q20 & ulIsqrPu:Q20
  	uwXPu = S32xS32divS32(slQPu, 16384, slIsqrPu);      //Q(20+14-20) = Q14
  	
    uwRPu = S32xS32divS32(uwXPu, slPPu, slQPu);         //Q(14+20-20) = Q14
	
	uwIsPu = uw_Sqrt32c(U32xU32divU32(slIsqrPu, 1024, CatchPoint));	// sqrt(Q(20+10))=Q15	
	#endif
  #else    
    // New algorithm: X = Q*U^2/(P*P+Q*Q) = (U^2)/(P*P/Q+Q), R = X*(P/Q).

    //slPPu:Q22 & slQPu:Q22
  	slTemp1 = S32xS32divS32(slPPu, slPPu, slQPu) + slQPu;    //Q22
  	
  	//ulUsqrPu:Q22 & ulIsqrPu:Q22
  	uwXPu = S32xS32divS32(slUsqrPu, 16384, slTemp1);    //Q(22+14-22) = Q14
  	
    uwRPu = S32xS32divS32(uwXPu, slPPu, slQPu);    //Q(14+22-22) = Q14
	
	uwIsPu = uw_Sqrt32c(U32xU32divU32(slIsqrPu, 256, CatchPoint));	// sqrt(Q(22+8))=Q15
  #endif
}

/*************************************************************** 
 Function: TUN_QMethod
 Description:	Calculate Tr, Rr, LmN and ImN based on Q method.
 Called by: TUN_LFSLIdle
 Input Variables: 
 Output/Return Variables: 
 Subroutine Call: N/A
 Reference: N/A
****************************************************************/
UWORD uwLe1, uwLe2;	
ULONG ulfs1Pu, ulfs2Pu;

void TUN_QMethod(void)
{
	// uwXPu:Q14 & uwRPu:Q14 & uwIsPu:Q15	
	ULONG ulTemp1, ulTemp2;
	
	ulfs1Pu = TUN_slLFSLFminPu;         //Q31
	ulfs2Pu = TUN_slLFSLFminPu * 2;     //Q31
	
	// Calculate Le = Lss - Lx = Xss/fs - Lx.
	uwLe1 = U32xU32divU32(uwX1Pu,0x1000000,ulfs1Pu) - (TUN_uwL1sigmaPu>>3);	// Q(14+24-31) - Q7
	uwLe2 = U32xU32divU32(uwX2Pu,0x1000000,ulfs2Pu) - (TUN_uwL1sigmaPu>>3);	// Q(14+24-31) - Q7

	ulTemp1 = U32xU32shlr32(ulfs1Pu, ulfs1Pu);	        // Q(31+31-32) = Q30
	ulTemp1 = U32xU32shlr32((uwLe1*16384), ulTemp1);	// Q19 = Q((7+14)+30-32)
	
	ulTemp2 = U32xU32shlr32(ulfs2Pu, ulfs2Pu);	        // Q(31+31-32) = Q30
	ulTemp2 = U32xU32shlr32((uwLe2*16384), ulTemp2);	// Q19 = Q((7+14)+30-32)
	
	ulTemp1 = ulTemp2 - ulTemp1;    // Q19
	
	// Calculate Tr = sqrt((Le1-Le2)/(Le2*fs2^2-Le1*fs1^2))
	// Q4 = sqrt(Q(7+4+16-19))
 	uwTrPu = uw_Sqrt32c(U32xU32divU32(((ULONG)(uwLe1-uwLe2)<<4),65536 ,ulTemp1));
  #if 0	
	// Calculate Lm = Le1*Le2*(fs2^2-fs1^2)/(Le2*fs2^2-Le1*fs1^2).
	ulTemp2 = (((ULONG)uwfs2Pu*uwfs2Pu) - ((ULONG)uwfs1Pu*uwfs1Pu))>>3;	//Q27
	ulTemp2 = ((ULONG) uwLe2 * ulTemp2) >> 14;		// Q19 = Q(6+27-14)
	TUN_uwLm1Pu = U32xU32divU32(uwLe1, ulTemp2, ulTemp1);   // Q6 = Q(6+19-19)

	//Calculate Rr = Lm / Tr.
	// Q(6+13-4)
	TUN_uwRrPu = U16xU16divU16(TUN_uwLm1Pu, 8192, uwTrPu);	// (Q15)
  #else
	// Calculate Lm = Le1*Le2*(fs2^2-fs1^2)/(Le2*fs2^2-Le1*fs1^2).
	// Calculate Lm = Le1*Le2*(fs2^2-fs1^2)/(Le2*fs2^2-Le1*fs1^2).
	ulTemp2 = U32xU32shlr32(ulfs2Pu,ulfs2Pu) - U32xU32shlr32(ulfs1Pu,ulfs1Pu);	//Q30
	ulTemp2 = U32xU32shlr32((uwLe2*16384), ulTemp2);		// Q19 = Q((7+14)+30-32)
	TUN_uwLm1Pu = U32xU32divU32(uwLe1, ulTemp2, ulTemp1);   // Q7 = Q(7+19-19)

	//Calculate Rr = Lm / Tr.
	// Q(7+12-4)
	
	//--- 02/24/06	Max.SJ.Chang: Rr Tuning replace by 4-section HFSS tuning
	//TUN_uwRrPu = U16xU16divU16(TUN_uwLm1Pu, 4096, uwTrPu);	// (Q15)  
  #endif
	//Calculate Im = (Im1+Im2)/2, Imx = Isx / SQRT(1+(fsx*Tr)^2), where x = 1, 2.	
	TUN_uwI0Pu = (TUN_uwCalcIm(uwIs1Pu, (ulfs1Pu>>16), uwTrPu) + TUN_uwCalcIm(uwIs2Pu, (ulfs2Pu>>16), uwTrPu))>>1;	// (Q15)
	
}

void TUN_LFSLIdle(void)
{

	// Calculate Z = R + jX.
	// Calculate Rss, Xss and Is in the 1st LFSS test.
	TUN_CalcZLFSL(TUN_slP1,TUN_slQ1,TUN_slUphS1,TUN_slIphS1,TUN_CatchPoint);
	uwX1Pu = uwXPu;     //Q14
	uwIs1Pu = uwIsPu;	//Q15
	
    TUN_CalcZLFSL(TUN_slP2,TUN_slQ2,TUN_slUphS2,TUN_slIphS2,(TUN_CatchPoint>>1));
	uwX2Pu = uwXPu;     //Q14
	uwIs2Pu = uwIsPu;	//Q15    
    
    TUN_QMethod();
}

void TUN_LFSLInit(void)
{
    UWORD MotorPower, temp;
    
    TUN_TuningCNT = 0;
    TUN_IntegralCnt = 0;
    
    TUN_Sector = 0;
    
    TUN_slIsqr = 0;
    TUN_slUsqr = 0;
    TUN_slP = 0;
    TUN_slQ = 0;
    
    TUN_slIphS1 = 0;
    TUN_slUphS1 = 0;
    TUN_slP1 = 0;
    TUN_slQ1 = 0;
    
    TUN_slIphS2 = 0;
    TUN_slUphS2 = 0;
    TUN_slP2 = 0;
    TUN_slQ2 = 0;
    
    //LPF_KiT 750uS,low pass filter constant(1us)    
	temp = U16xU16divU16(pr[HFTUN_P],TB2CLK_Hz,62500)+16;
	mrs_LpfKit = U16xU16divU16(32767, 16, temp);

    TUN_CatchPoint = U16xU16divU16(100, TB2CLK_Hz,(COF_uwFslipRate>>1));
    TUN_slLFSLFminPu = U32xU32divU32((COF_uwFslipRate>>1), 0x80000000, COF_uwFbRe);
    
    TUN_slFreqPu = TUN_slLFSLFminPu;
    
    if ((EXT_MOTOR1to2==1)||(pr[MOTORSEL]==2))	//motor 2 highest priority
        MotorPower = pr[P_RATED2];
    else
        MotorPower = pr[P_RATED1];
    
    if (MotorPower<=75){
        //   1HP, PN <= 0.75kW => ImN = 0.6*IN.
        TUN_uwImNRatioPu = 19661;
    }
    else if (MotorPower<=550){
        // 7.5HP, PN <= 5.50kW => ImN = 0.5*IN.
        TUN_uwImNRatioPu = 16384;
    }
    else if (MotorPower<=1500){
        // 20HP,  PN <= 15.0kW => ImN = 0.4*IN.
        TUN_uwImNRatioPu = 13107;
    }
    else{
        // above 20HP,  ImN = 0.3*IN.
        TUN_uwImNRatioPu = 9830;
    }
    
    TUN_uwImNPu = ((ULONG)COF_uwMIratePu * TUN_uwImNRatioPu)>>15;
    
    TUN_CalcEmLmN();
    
    TUN_uwQfRatioPu = U16xU16divU16(TUN_uwEmNPu, TUN_uwImNPu, COF_uwFRatePu);
    
    TUN_slIqIntePu = ((ULONG)TUN_uwImNPu * 46340);  //Q30
    
    // K1 = Lx/Tctrl, Q9 = Q(10+14-15)
    uwK1Pu = U16xU16divU16(TUN_uwL1sigmaPu, 16384,COF_uwTctrTb2Pu);
    
    TUN_swUoutPu = 0;    
    TUN_slFreqPu = 0;
}

void TUN_LFSLTB1(void)
{
	TUN_uwTB1CNT++;
    
	if (TUN_uwTB1CNT>8000){
        TUN_Sector++;
        TUN_IntegralCnt = 0;
        TUN_SAMPLEON 	= 0;
        TUN_uwTB1CNT 	= 0;
        TUN_slIsqr		= 0;
        TUN_slUsqr		= 0;
        TUN_slP			= 0;
        TUN_slQ			= 0;
		if (TUN_Sector>=2)
			TUN_LFSL_OK = 1;
	}
    
    if ((TUN_uwTB1CNT>4000)&&(abs(AD_swIAPu)<(COF_uwMIratePu>>8)))
        TUN_SAMPLEON = 1;
        
    switch(TUN_Sector){
        default:
        case 0:
            TUN_slFreqPu = TUN_slLFSLFminPu;
            break;
        case 1:
            TUN_slFreqPu = TUN_slLFSLFminPu * 2;
            break;
    }
    
    if (TUN_LFSL_OK==1){
        stop();
        TUN_LFSLIdle();
    }
}

void MRAS_LPF(void)
{
    SWORD swUalfaPu, swUbetaPu;
    SWORD swIalfaPu, swIbetaPu;
    
    swUalfaPu = TUN_swUalfa;
    swUbetaPu = TUN_swUbeta;
    swIalfaPu = T32_swIdssOutPu;
    swIbetaPu = T32_swIqssOutPu;    
    
	//#define LPF_KiT 8191 //32767*10000/10/4000 VP0511220_B	
	slUalfaPuLPF = ((SLONG)mrs_LpfKit * (swUalfaPu - (slUalfaPuLPF>>15)) + (slUalfaPuLPF));
	slUbetaPuLPF = ((SLONG)mrs_LpfKit * (swUbetaPu - (slUbetaPuLPF>>15)) + (slUbetaPuLPF));
	slIalfaPuLPF = ((SLONG)mrs_LpfKit * (swIalfaPu - (slIalfaPuLPF>>15)) + (slIalfaPuLPF));
	slIbetaPuLPF = ((SLONG)mrs_LpfKit * (swIbetaPu - (slIbetaPuLPF>>15)) + (slIbetaPuLPF));

}

void MRAS_RefBEMF(void)
{
    SWORD swUalfaPu, swUbetaPu;
    SWORD swIalfaPu, swIbetaPu;
  #if LFSL_LPF_ON
    swUalfaPu = (SWORD)(slUalfaPuLPF >> 15);
    swUbetaPu = (SWORD)(slUbetaPuLPF >> 15);
    swIalfaPu = (SWORD)(slIalfaPuLPF >> 15);
    swIbetaPu = (SWORD)(slIbetaPuLPF >> 15);
  #else
    swUalfaPu = TUN_swUalfa;
    swUbetaPu = TUN_swUbeta;
    swIalfaPu = T32_swIdssOutPu;
    swIbetaPu = T32_swIqssOutPu;      
  #endif
	// K1 = Lx/Tctrl, Q9 = Q(10+14-15)
    // uwK1Pu = U16xU16divU16(TUN_uwL1sigmaPu, 16384,COF_uwTctrTb2Pu);
	swEalfaPu = swUalfaPu
					 - (((SLONG)(swIalfaPu - swIalfaOldPu) * (uwK1Pu<<2) 
					 	+ ((SLONG)swIalfaPu * TUN_uwRsPu>>4))>>11);
	swEbetaPu = swUbetaPu 
					 - (((SLONG)(swIbetaPu - swIbetaOldPu) * (uwK1Pu<<2)
					 	+ ((SLONG)swIbetaPu * TUN_uwRsPu>>4))>>11);

	swIalfaOldPu = swIalfaPu;
	swIbetaOldPu = swIbetaPu;
}

void MRAS_RefQ(void)
{
    SWORD swIalfaPu, swIbetaPu;
  #if LFSL_LPF_ON
    swIalfaPu = (SWORD)(slIalfaPuLPF >> 15);
    swIbetaPu = (SWORD)(slIbetaPuLPF >> 15);
  #else
    swIalfaPu = T32_swIdssOutPu;
    swIbetaPu = T32_swIqssOutPu;    
  #endif
    
	slQFdbPu = (((SLONG)swIalfaPu*swEbetaPu)-((SLONG)swIbetaPu*swEalfaPu))<<1;	//Q31
}

#define	LFSL_AQR_KI	    3000		// Ki of AQR in the LFSL test (Q16).
#define	LFSL_AQR_MAX	0x40000000	// Max output of Iq of AQR in the LFSL test (Q31).

void TUN_AQR(void)
{
	SLONG slQErr, slIntegrator;
    // slQRefPu = (((SDOUBLE)TUN_uwQfRatioPu*TB1_slSpdCmdPu)>>14);
	slQErr = (slQRefPu>>1) - (slQFdbPu>>1);	// (Q30).

	slIntegrator = TUN_slIqIntePu + (((SDOUBLE)slQErr*LFSL_AQR_KI)>>15);	// (Q31).

	if (abs(slIntegrator) < LFSL_AQR_MAX)
		TUN_slIqIntePu = slIntegrator;
	else{
	// saturation value: 0.5 (in Q31)
		if (slIntegrator > 0){
			TUN_slIqIntePu = LFSL_AQR_MAX;
		}
		else{
			TUN_slIqIntePu = 0 - LFSL_AQR_MAX;
		}
	}
}

void TUN_LFSLTB2(void)
{
    SLONG Vout_tmp, VsquareTemp;

    if ((TUN_SAMPLEON==1)&&(TUN_IntegralCnt<TUN_CatchPoint)){
        TUN_ACSmpl();
        if (TUN_Sector==0)
            TUN_IntegralCnt = TUN_IntegralCnt + 1;
        else if (TUN_Sector==1)
            TUN_IntegralCnt = TUN_IntegralCnt + 2;
    }
    else{
        if (TUN_IntegralCnt>=TUN_CatchPoint){
            switch(TUN_Sector){
                case 0:
                    TUN_slIphS1 = TUN_slIsqr;	//Q20
                    TUN_slUphS1 = TUN_slUsqr;	//Q20
                    TUN_slP1 = TUN_slP;			//Q20
                    TUN_slQ1 = TUN_slQ;			//Q20
                    break;
                case 1:
                    TUN_slIphS2 = TUN_slIsqr;	//Q20
                    TUN_slUphS2 = TUN_slUsqr;	//Q20
                    TUN_slP2 = TUN_slP;			//Q20
                    TUN_slQ2 = TUN_slQ;			//Q20      
                    break;
                default:
                    break;
            }
        }
    }
    //Theta = Theta + DeltaTheta * CRM_swFlxFreqPu, (0-360) = (0-65535)
    // CRM_slFlxFreqPu in Q31, COF_ulKTheta in Q16
    // 0x80000000 = 2^31, because Fb scale 100, so COF_ulKTheta sacle 100
    
    //--- 02/21/06	Max.SJ.Chang: 
    // COF_ulKTheta = 393216
    CRM_swThetaStep = (S32xS32shlr31(COF_ulKTheta, TUN_slFreqPu))/100;    
    TUN_uwTheta = ((TUN_uwTheta + CRM_swThetaStep) & 0x0FFFF);    
    // sin table have 1500 data
   	TUN_uwSinIndex = TUN_uwTheta >> 6;
   	TUN_uwCosIndex = ((TUN_uwTheta + 16384) & 0x0FFFF) >> 6;
    SinValue = sine[TUN_uwSinIndex];
    CosValue = sine[TUN_uwCosIndex];
    
    T32_swIasInPu = AD_swIAPu;
    T32_swIbsInPu = AD_swIBPu;
    abc2dq();

    TsE_swIdssInPu = T32_swIdssOutPu;
    TsE_swIqssInPu = T32_swIqssOutPu;
    Stat2Syn_s2e();    
  #if 0
    TUN_swUaPu = ((SLONG)PWM_swTaInPu * COF_uwVdcPu)>>15;
    TUN_swUbPu = ((SLONG)PWM_swTbInPu * COF_uwVdcPu)>>15;
    
    TUN_swUalfa = TUN_swUaPu;
    TUN_swUbeta = ((SLONG)(TUN_swUaPu + 2*TUN_swUbPu)*18919)>>15;
  #else
    TUN_swUalfa = TeS_swUdssOutPu;
    TUN_swUbeta = TeS_swUqssOutPu;
  #endif
    
    //-------- Calc Q_fbk from MRAS --------------//
  #if LFSL_LPF_ON
  	//------------------------------------------------------------//
  	// To get Low pass value of Ualfa, Ubeta, Ialfa, Ibeta        //	  
    MRAS_LPF();
  #endif
    //------ Calculate Back-EMF ------------------//
    MRAS_RefBEMF();
    MRAS_RefQ();
    
    slQRefPu = (((SDOUBLE)TUN_uwQfRatioPu*TUN_slFreqPu)>>14);	// Q(15+31-14)=2* (Q31).
    //slQRefPu = (((SDOUBLE)TUN_uwQfRatioPu*TUN_slFreqPu)>>16);	// Q(15+31-14)=2* (Q31).
    TUN_AQR();

    //-------- q - axis current regulator --------//
    CUR_swIqseRefPu = (SWORD)(TUN_slIqIntePu>>16);;
    CUR_swIqseFdbPu = TsE_swIqseOutPu;
    CurrentReg_qaxis();    
        
    //-------- d - axis current regulator --------//
    CUR_swIdseRefPu = 0;
    CUR_swIdseFdbPu = TsE_swIdseOutPu;
    CurrentReg_daxis();    

    FFD_swUdseOutPu = 0;
    FFD_swUqseOutPu = 0;
    
    TeS_swUdseInPu = sl_limit(CUR_swUdseOutPu, FFD_swUdseOutPu, COF_uwVratePu);
    TeS_swUqseInPu = sl_limit(CUR_swUqseOutPu, FFD_swUqseOutPu, COF_uwVratePu);
    
    	//Ud^2+Uq^2 > Urate_max^2 = 32767^2 = 2^30
	Vout_tmp = (((SLONG)TeS_swUdseInPu*TeS_swUdseInPu) + ((SLONG)TeS_swUqseInPu*TeS_swUqseInPu)) >> 16;

	VsquareTemp = (((SLONG)COF_uwVratePu*COF_uwVratePu) >> 16) - 128; //1V/255V*32768 = 128
	
	if(Vout_tmp >= VsquareTemp){
		VolSat_flag = 1;
	}
	else{
		VolSat_flag = 0;
	}

    Syn2Stat_e2s();
    
    T23_swUqssInPu = TeS_swUqssOutPu;
    T23_swUdssInPu = TeS_swUdssOutPu;
    dq2abc();
    
	Duty_swTasInPu = T23_swUasOutPu;
	Duty_swTbsInPu = T23_swUbsOutPu;
	Duty_swTcsInPu = T23_swUcsOutPu;
    UabcPu2Duty();    

}

void TUN_ProcessTB2(void)
{

	if ((TUN_START==1)&&(TUN_OK==0)){
		if ( pr[AUTO_T]!=0 ){
			switch(pr[AUTO_T]){
			//------ Rolling test 1 ----------------------------------------//
            	case 1:
                	if (TUN_ROLLING==0){
                    	Static_Test1();
                    	if ((TUN_HFSS_OK==1)&&(TUN_DC_OK==1)){
                	    	TUN_WAIT = 1;
                        	TUN_Method = ROTARY_TEST;
                        	TUN_Sector = 0;
                        	TUN_ROLLING = 1;
                    	}
                	}
                	else {
                    	Rolling_Test1();
                	} break;
            //------ Static test 1 -----------------------------------------// 
            	case 2:
                	Static_Test1();
                
                	if ((TUN_HFSS_OK==1)&&(TUN_DC_OK==1)){        	        
						TUN_CalLmbyPr();
						fcmd.uw.hi = fmin;
        	        	stop();
                	} break;
            //-------- Shaft Lock Tuning -----------------------------------//
            	case 3:
                	if (TUN_LFSL==0){
                    	Static_Test1();

                    	if ((TUN_HFSS_OK==1)&&(TUN_DC_OK==1)){
                        	TUN_LFSLInit();
                	    	TUN_LFSL = 1;                	    
                    	}
                	}
                	else if (TUN_LFSL==1){
                    	TUN_LFSLTB2();
                	} break;
            //-------- Gain of Ia & Ib -------------------------------------//
                case 10:
                    CurGainCalib();
                    break;
                default:
                    break;
        	}
		}
		else {
			switch(pr[PM_AUTO_T]){
//------ ADDED BY SCOTTY 2007/06/01 -----------------------------------------// 			
				case 1:
				case 3:  // 08/11/2008
					Static_Test1();	
					if (TUN_PHASEZ_OK && TUN_STEPANG ==0){
						TUN_CAL_ZOFFSET();
//						WGOFF;  // Delete by DINO, 07/09/2008
						stop();
					}
					break; 
            	case 2:
                	Static_Test1();
                	if (TUN_DC_OK==1 && TUN_PMLS_OK ==1){
                    	TUN_CalPMLS();
	                	pr[PM_Lq] = U16xU16divU16(TUN_uwL1sigmaPu, COF_uwLbRe, 51200);
 		            	STDutyInit();	// calculate uwTGain for StandStill duty
		            	PM_swTmax = experiod + DeadTime;
		            	PM_swTmin = (SWORD)(experiod + DeadTime) - (SWORD)((ULONG)experiod*uwTGain>>8); 
        	        	stop();
                	} break;
//------ END 2007/02/06 --------------------------                
            	default:
                	break;
        	}        
		}
    }
}


#ifdef  _ATUNING_C
    #undef  _ATUNING_C
#endif

/************************************************************************
 Copyright (c) 2005 EMBU DELTA
 All rights reserved.
*************************************************************************
 End of this File (EOF):
 !!!!!!Do not put anything after this part!!!!!!!!!!!
*************************************************************************/

