/***********************************************************************/
/*                                                                     */
/*  FILE        :hwsetup.c                                             */
/*  DATE        :Fri, Aug 12, 2005                                     */
/*  DESCRIPTION :Hardware Setup file                                   */
/*  CPU TYPE    :SH7149                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.0).     */
/*                                                                     */
/***********************************************************************/
#ifndef  _SYSInit_C
    #define  _SYSInit_C
#endif

#include "ProgHeader.h"



void InitIO(void)
{    
    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 0 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P0nPFS PSEL[4:0]                                          //
    // Bit[01]          0        0          0         0           00000b              :P01  Input        PSDIEA         //
    // Bit[00]          0        0          0         1           00101b              :P00  CACREF    BOOT_MD    //
    // ======================================================== //
      //PORT0.PMR.BIT.B0 = 1;
      //PORT0.PDR.BYTE = 0x00;
      //PORT0.PMR.BYTE = 0x01;
      PORT0.PDR.BIT.B1 = 1;  //[New addition IO card,Lyabryan,2019/07/22]
      PORT0.PMR.BIT.B1 = 0;
      MPC.P01PFS.BYTE = 0x00;
      MPC.P00PFS.BYTE = 0x05;
      PORT0.PODR.BIT.B1 = 1;  //[New addition IO card,Lyabryan,2019/07/22]

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 1 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P1nPFS PSEL[4:0]                                          //
    // Bit[13]          1        0          0         0           00000b              :P13  Output     SF RY           //
    // Bit[12]          0        0          0         0           00000b              :P12  Input        FAN LOCK    //
    // Bit[11]          0        0          0         1           00010b              :P11  TCLKC      PG2refA        //
    // Bit[10]          0        0          0         1           00010b              :P10  TCLKD      PG2refB       //
    // ======================================================== //
      PORT1.PDR.BIT.B3 = 1;
      PORT1.PDR.BIT.B2 = 0;
      PORT1.PDR.BIT.B1 = 0;
      PORT1.PDR.BIT.B0 = 0;
      PORT1.PMR.BIT.B3 = 0;
      PORT1.PMR.BIT.B2 = 0;
      PORT1.PMR.BIT.B1 = 1;
      PORT1.PMR.BIT.B0 = 1;

      MPC.P11PFS.BYTE = 0x02;
      MPC.P10PFS.BYTE = 0x02;

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 2 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P2nPFS PSEL[4:0]                                          //
    // Bit[26]          0        0          0         1           01111b              :P26  SDA          SDA1           //
    // Bit[25]          0        0          0         1           01111b              :P25  SCL          SCL1            //
    // Bit[24]          1        0          0         0           00000b              :P24  Output      PGSEL          //
    // Bit[23]          1        0          0         1           01010b              :P23  TXD0        PGTXD         //
    // Bit[22]          0        0          0         1           01010b              :P22  RXD0        PGRXD         //
    // Bit[21]          0        0          0         1           00010b              :P21  TCLKA      PGA             //
    // Bit[20]          0        0          0         1           00010b              :P20  TCLKB      PGB              //
    // ======================================================== //
      //PORT2.PDR.BYTE = 0x18;
      //PORT2.PMR.BYTE = 0x6F;
      PORT2.PMR.BIT.B6 = 1;
      PORT2.PMR.BIT.B5 = 1;
      PORT2.PMR.BIT.B4 = 0;      
      PORT2.PMR.BIT.B3 = 0; //[0: Uses the pin as a general I/O pin.];[1: Uses the pin as an I/O port for peripheral functions.]
      PORT2.PMR.BIT.B2 = 0; //[0: Uses the pin as a general I/O pin.];[1: Uses the pin as an I/O port for peripheral functions.]
      PORT2.PMR.BIT.B1 = 1;
      PORT2.PMR.BIT.B0 = 1;
      
      
      PORT2.PDR.BIT.B6 = 0;
      PORT2.PDR.BIT.B5 = 0;
      PORT2.PDR.BIT.B4 = 1;
      PORT2.PDR.BIT.B3 = 1; //[0: Input (Functions as an input pin.)];[1: Output (Functions as an output pin.)]
      PORT2.PDR.BIT.B2 = 1; //[0: Input (Functions as an input pin.)];[1: Output (Functions as an output pin.)]
      PORT2.PDR.BIT.B1 = 0;
      PORT2.PDR.BIT.B0 = 0;
      
      MPC.P26PFS.BYTE = 0x0F;
      MPC.P25PFS.BYTE = 0x0F;
      MPC.P24PFS.BYTE = 0x00;
      MPC.P23PFS.BYTE = 0x00;
      MPC.P22PFS.BYTE = 0x00;
      MPC.P21PFS.BYTE = 0x02;
      MPC.P20PFS.BYTE = 0x02;
      
          PORT2.PODR.BIT.B2 = 0; // Initial PORD Output is zero.
		  PORT2.PODR.BIT.B3 = 0; // Initial PORD Output is zero.

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 3 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P3nPFS PSEL[4:0]                                          //
    // Bit[33]          1        0          0         0           00000b              :P33  Output     DP-RCLK       //
    // Bit[32]          1        0          0         0           00000b              :P32  Output     DP-TX           //
    // Bit[31]          1        0          0         0           00000b              :P31  Output     GBP               //
    // Bit[30]          1        0          0         0          01010b               :P30  Output  SCK0 PGDIR     //
    // ======================================================== //
      //PORT3.PDR.BYTE = 0x0E;
      //PORT3.PMR.BYTE = 0x01;
      PORT3.PMR.BIT.B3 = 0;
      PORT3.PMR.BIT.B2 = 0;
      PORT3.PMR.BIT.B1 = 0;
      PORT3.PMR.BIT.B0 = 0;
      
      PORT3.PDR.BIT.B3 = 1;
      PORT3.PDR.BIT.B2 = 1;
      PORT3.PDR.BIT.B1 = 1;
      PORT3.PDR.BIT.B0 = 1;
      
      MPC.P33PFS.BYTE = 0x00;
      MPC.P32PFS.BYTE = 0x00;
      MPC.P31PFS.BYTE = 0x00;
      MPC.P30PFS.BYTE = 0x00;

      //if((pr[PG_TYPE] == ABZ_ONLY)||(pr[PG_TYPE] == ABZ_UVW)||(pr[PG_TYPE] == NOPG)){
          PORT3.PODR.BIT.B0 = 0; // Initial PORD Output is zero.
      //}


    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 4 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P4nPFS                                                          //
    // Bit[47]          -        -          -         -           0x80              :P47  AN013      AUI1'               //
    // Bit[46]          -        -          -         -           0x80              :P46  AN012      AUI2'               //
    // Bit[45]          -        -          -         -           0x80              :P45  AN011  ABS_DATA2MCU  //
    // Bit[44]          -        -          -         -           0x80              :P44  AN010      GFFAD             //
    // Bit[43]          -        -          -         -           0x80              :P43  AN003      VDC                //
    // Bit[42]          -        -          -         -           0x80              :P42  AN002      IW                  //
    // Bit[41]          -        -          -         -           0x80              :P41  AN001      IV                   //
    // Bit[40]          -        -          -         -           0x80              :P40  AN000      IU                   //
    // ======================================================== //
      MPC.P47PFS.BYTE = 0x80;
      MPC.P46PFS.BYTE = 0x80;
      MPC.P45PFS.BYTE = 0x80;
      MPC.P44PFS.BYTE = 0x80;
      MPC.P43PFS.BYTE = 0x80;
      MPC.P42PFS.BYTE = 0x80;
      MPC.P41PFS.BYTE = 0x80;
      MPC.P40PFS.BYTE = 0x80;


    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 5 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P5nPFS                                                          //
    // Bit[55]          -        -          -         -           0x00              :P55  DA1        Vref1                 //
    // Bit[54]          -        -          -         -           0x00              :P54  DA0        Vref2                 //
    // Bit[53]          -        -          -         -           0x80              :P53  AN9        safety function   //
    // Bit[52]          -        -          -         -           0x80              :P52  AN8        safety function   //
    // Bit[51]          -        -          -         -           0x80              :P51  AN7        safety function   //
    // Bit[50]          -        -          -         -           0x80              :P50  AN6        safety function    //
    // ======================================================== //
      MPC.P55PFS.BYTE = 0x00;
      MPC.P54PFS.BYTE = 0x00;
      MPC.P53PFS.BYTE = 0x80;
      MPC.P52PFS.BYTE = 0x80;
      MPC.P51PFS.BYTE = 0x80;
      MPC.P50PFS.BYTE = 0x80;
    

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 6 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P6nPFS                                                          //
    // Bit[65]          -        -          -         -           0x00              :P65  Input      PGLOSS1            //
    // Bit[64]          -        -          -         -           0x00              :P64  Input      PGLOSS2           //
    // Bit[63]          -        -          -         -           0x80              :P63  AN3        TH1                   //
    // Bit[62]          -        -          -         -           0x80              :P62  AN2        TH2                    //
    // Bit[61]          -        -          -         -           0x80              :P61  AN1        sysV                   //
    // Bit[60]          -        -          -         -           0x80              :P60  AN0        PGT                    //
    // ======================================================== //
      MPC.P65PFS.BYTE = 0x00;
      MPC.P64PFS.BYTE = 0x00;
      MPC.P63PFS.BYTE = 0x80;
      MPC.P62PFS.BYTE = 0x80;
      MPC.P61PFS.BYTE = 0x80;
      MPC.P60PFS.BYTE = 0x80;


    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 7 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P7nPFS PSEL[4:0]                                           //
    // Bit[76]          1        0          0         1           00001b              :P76  MTIOC4D       GZ1         //
    // Bit[75]          1        0          0         1           00001b              :P75  MTIOC4C       GY1         //
    // Bit[74]          1        0          0         1           00001b              :P74  MTIOC3D       GX1         //
    // Bit[73]          1        0          0         1           00001b              :P73  MTIOC4B       GW1         //
    // Bit[72]          1        0          0         1           00001b              :P72  MTIOC4A       GV1          //
    // Bit[71]          1        0          0         1           00001b              :P71  MTIOC3B       GU1          //
    // Bit[70]          0        0          0         1           00111b              :P70  POE0#      OC/CC/GFF  //
    // ======================================================== //
      PORT7.PDR.BIT.B6 = 1;
      PORT7.PDR.BIT.B5 = 1;
      PORT7.PDR.BIT.B4 = 1;
      PORT7.PDR.BIT.B3 = 1;
      PORT7.PDR.BIT.B2 = 1;
      PORT7.PDR.BIT.B1 = 1;
      PORT7.PDR.BIT.B0 = 0;
      
      PORT7.PMR.BIT.B6 = 1;
      PORT7.PMR.BIT.B5 = 1;
      PORT7.PMR.BIT.B4 = 1;
      PORT7.PMR.BIT.B3 = 1;
      PORT7.PMR.BIT.B2 = 1;
      PORT7.PMR.BIT.B1 = 1;
      PORT7.PMR.BIT.B0 = 1;
      
      MPC.P76PFS.BYTE = 0x01;
      MPC.P75PFS.BYTE = 0x01;
      MPC.P74PFS.BYTE = 0x01;
      MPC.P73PFS.BYTE = 0x01;
      MPC.P72PFS.BYTE = 0x01;
      MPC.P71PFS.BYTE = 0x01;
      MPC.P70PFS.BYTE = 0x07;
    
    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 8 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P8nPFS PSEL[4:0]                                           //
    // Bit[82]          1        0          0         0           00000b              :P82  SCK12      SCK0            //
    // Bit[81]          0        0          0         1           01100b              :P81  RXD12      TXD0             //
    // Bit[80]          1        0          0         1           01100b              :P80  TXD12      RXD0             //
    // ======================================================== //
      //PORT8.PMR.BYTE = 0x07;
      //PORT8.PDR.BYTE = 0x05;
      PORT8.PDR.BIT.B2 = 1; //[New addition IO card,Lyabryan,2019/07/22]
      PORT8.PDR.BIT.B1 = 1; //[New addition IO card,Lyabryan,2019/07/22]
      PORT8.PDR.BIT.B0 = 1; //[New addition IO card,Lyabryan,2019/07/22]

      PORT8.PMR.BIT.B2 = 0;
      PORT8.PMR.BIT.B1 = 0; //[New addition IO card,Lyabryan,2019/07/22]
      PORT8.PMR.BIT.B0 = 1;


      MPC.P82PFS.BYTE = 0x00;
      MPC.P81PFS.BYTE = 0x00; //[New addition IO card,Lyabryan,2019/07/22]
      MPC.P80PFS.BYTE = 0x0C;
      
      PORT8.PODR.BIT.B1 = 1;  //[New addition IO card,Lyabryan,2019/07/22]
      PORT8.PODR.BIT.B2 = 1;  //[New addition IO card,Lyabryan,2019/07/22]

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port 9 ===========================  //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                           //
    // Bit[96]          0        0          0         1           00111b              :P96  POE4#          OCC        //
    // Bit[95]          0        0          0         0           00000b              :P95  Input           Key-RX     //
    // Bit[94]          1        0          0         0           00000b              :P94  Output         Key-SRCLK //
    // Bit[93]          1        0          0         0           00000b              :P93  Output         DP-SRCLK   //
    // Bit[92]          0        0          0         1           00001b              :P92  MTIOC6D       PGZ          //
    // Bit[91]          1        0          0         1           00001b              :P91  MTIOC7C      DAO0          //
    // Bit[90]          1        0          0         1           00001b              :P90  MTIOC7D      DAO1        //
    // ======================================================== //
      //PORT9.PDR.BYTE = 0x1F;
      //PORT9.PMR.BYTE = 0x47;
      PORT9.PDR.BIT.B6 = 0;
      PORT9.PDR.BIT.B5 = 0;
      PORT9.PDR.BIT.B4 = 1;
      PORT9.PDR.BIT.B3 = 1;
      PORT9.PDR.BIT.B2 = 0;
      PORT9.PDR.BIT.B1 = 1;
      PORT9.PDR.BIT.B0 = 1;
            
      PORT9.PMR.BIT.B6 = 1;
      PORT9.PMR.BIT.B5 = 0;
      PORT9.PMR.BIT.B4 = 0;
      PORT9.PMR.BIT.B3 = 0;
      PORT9.PMR.BIT.B2 = 1;
      PORT9.PMR.BIT.B1 = 1;
      PORT9.PMR.BIT.B0 = 1;
      
      MPC.P96PFS.BYTE = 0x07;
      MPC.P95PFS.BYTE = 0x00;
      MPC.P94PFS.BYTE = 0x00;
      MPC.P93PFS.BYTE = 0x00;
      MPC.P92PFS.BYTE = 0x01;
      MPC.P91PFS.BYTE = 0x06;
      MPC.P90PFS.BYTE = 0x06;

    
    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port A ===========================  //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                          //
    // Bit[A5]          0        0          0         0           00000b              :PA5  Input           DI3           //
    // Bit[A4]          0        0          0         0           00000b              :PA4  Input            DI4          //
    // Bit[A3]          0        0          0         0           00000b              :PA3  Input            DI5          //
    // Bit[A2]          1        0          0         0           00000b              :PA2  Output         Fan          //
    // Bit[A1]          0        0          0         0           00000b              :PA1  Input            DI6          //
    // Bit[A0]          0        0          0         0           00000b              :PA0  Input            DI7          //
    // ======================================================== //
      //PORTA.PDR.BYTE = 0x04;
      //PORTA.PMR.BYTE = 0x00;
      PORTA.PDR.BIT.B5 = 0;
      PORTA.PDR.BIT.B4 = 0;
      PORTA.PDR.BIT.B3 = 0;
      PORTA.PDR.BIT.B2 = 1;
      PORTA.PDR.BIT.B1 = 0;
      PORTA.PDR.BIT.B1 = 0;
            
      PORTA.PMR.BIT.B5 = 0;
      PORTA.PMR.BIT.B4 = 0;
      PORTA.PMR.BIT.B3 = 0;
      PORTA.PMR.BIT.B2 = 0;
      PORTA.PMR.BIT.B1 = 0;
      PORTA.PMR.BIT.B0 = 0;

      MPC.PA5PFS.BYTE = 0x00;
      MPC.PA4PFS.BYTE = 0x00;
      MPC.PA3PFS.BYTE = 0x00;
      MPC.PA2PFS.BYTE = 0x00;
      MPC.PA1PFS.BYTE = 0x00;
      MPC.PA0PFS.BYTE = 0x00;

      PORTA.PODR.BIT.B2 = 1;  //Pull High After I/O initial   //FAN

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port B ===========================  //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                          //
    // Bit[B7]          1        0          0         0           00000b              :PB7  Output         316JRST   //
    // Bit[B6]          1        0          0         1           01101b              :PB6  CTx0            CTX          //
    // Bit[B5]          0        0          0         1           01101b              :PB5  CRx0            CRX          //
    // Bit[B4]          0        0          0         1           00111b              :PB4  POE8#          OV          //
    // Bit[B3]          0        0          0         0           00000b              :PB3  Input            FWD         //
    // Bit[B2]          0        0          0         0           00000b              :PB2  Input            REV          //
    // Bit[B1]          0        0          0         0           00000b              :PB1  Input            DI1          //
    // Bit[B0]          0        0          0         0           00000b              :PB0  Input            DI2          //
    // ======================================================== //
      //PORTB.PDR.BYTE = 0xC0;
      //PORTB.PMR.BYTE = 0x70;
      PORTB.PDR.BIT.B7 = 1;
      PORTB.PDR.BIT.B6 = 0;
      PORTB.PDR.BIT.B5 = 1;
      PORTB.PDR.BIT.B4 = 0;
      PORTB.PDR.BIT.B3 = 0;
      PORTB.PDR.BIT.B2 = 0;
      PORTB.PDR.BIT.B1 = 0;
      PORTB.PDR.BIT.B0 = 0;
      
      PORTB.PMR.BIT.B7 = 0;
      PORTB.PMR.BIT.B6 = 1;
      PORTB.PMR.BIT.B5 = 1;
      PORTB.PMR.BIT.B4 = 1;
      PORTB.PMR.BIT.B3 = 0;
      PORTB.PMR.BIT.B2 = 0;
      PORTB.PMR.BIT.B1 = 0;
      PORTB.PMR.BIT.B0 = 0;

      MPC.PB7PFS.BYTE = 0x00;
      MPC.PB6PFS.BYTE = 0x10;
      MPC.PB5PFS.BYTE = 0x10;
      MPC.PB4PFS.BYTE = 0x07;
      MPC.PB3PFS.BYTE = 0x00;
      MPC.PB2PFS.BYTE = 0x00;
      MPC.PB1PFS.BYTE = 0x00;
      MPC.PB0PFS.BYTE = 0x00;

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port D ===========================  //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                          //
    // Bit[D7]          1        0          0         0           00000b              :PD7  Output            RA6      //
    // Bit[D6]          1        0          0         0           00000b              :PD6  Output            RA5      //
    // Bit[D5]          1        0          0         0           00000b              :PD5  Output            RA4      //
    // Bit[D4]          1        0          0         0           00000b              :PD4  Output            RA3       //
    // Bit[D3]          1        0          0         0           00000b              :PD3  Output            RA2       //
    // Bit[D2]          1        0          0         0           00000b              :PD2  Output            RA1       //
    // Bit[D1]          1        0          0         0           00000b              :PD1  Output            RA D      //
    // Bit[D0]          1        0          0         0           00000b              :PD0  Output            RA C      //
    // ======================================================== //
      //PORTD.PDR.BYTE = 0xFF;
      //PORTD.PMR.BYTE = 0x00;
      PORTD.PDR.BIT.B7 = 1;
      PORTD.PDR.BIT.B6 = 1;
      PORTD.PDR.BIT.B5 = 1;
      PORTD.PDR.BIT.B4 = 1;
      PORTD.PDR.BIT.B3 = 1;
      PORTD.PDR.BIT.B2 = 1;
      PORTD.PDR.BIT.B1 = 1;
      PORTD.PDR.BIT.B0 = 1;
      
      PORTD.PMR.BIT.B7 = 0;
      PORTD.PMR.BIT.B6 = 0;
      PORTD.PMR.BIT.B5 = 0;
      PORTD.PMR.BIT.B4 = 0;
      PORTD.PMR.BIT.B3 = 0;
      PORTD.PMR.BIT.B2 = 0;
      PORTD.PMR.BIT.B1 = 0;
      PORTD.PMR.BIT.B0 = 0; 
      
      MPC.PD7PFS.BYTE = 0x00;
      MPC.PD6PFS.BYTE = 0x00;
      MPC.PD5PFS.BYTE = 0x00;
      MPC.PD4PFS.BYTE = 0x00;
      MPC.PD3PFS.BYTE = 0x00;
      MPC.PD2PFS.BYTE = 0x00;
      MPC.PD1PFS.BYTE = 0x00;
      MPC.PD0PFS.BYTE = 0x00;

      
      PORTD.PODR.BIT.B7 = 1;  //Pull High After I/O initial 
      PORTD.PODR.BIT.B6 = 1;  //Pull High After I/O initial 
      PORTD.PODR.BIT.B5 = 1;  //Pull High After I/O initial 
      PORTD.PODR.BIT.B4 = 1;  //Pull High After I/O initial 
      PORTD.PODR.BIT.B3 = 1;  //Pull High After I/O initial 
      PORTD.PODR.BIT.B2 = 1;  //Pull High After I/O initial 


    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port E ===========================  //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                           //
    // Bit[E5]          0        0          0         1           10001b              :PD5  USB0_VBUS    UMON     //
    // Bit[E4]          1        0          0         0           00000b              :PD4  Output            Fault LED       //
    // Bit[E3]          0        0          0         1           10001b              :PD3  POE11#          OC          //
    // Bit[E2]          0        0          0         1           10001b              :PD2  POE10#          GFF          //
    // Bit[E1]          0        0          0         0           00000b              :PD1  Input            PGRST      //
    // Bit[E0]          0        0          0         0           00000b              :PD0  Input               BF          //
    // ======================================================== //
      //PORTE.PDR.BYTE = 0x12;
      //PORTE.PMR.BYTE = 0x2C;
      PORTE.PDR.BIT.B5 = 0;
      PORTE.PDR.BIT.B4 = 1;
      //PORTE.PDR.BIT.B3 = 0;
      //PORTE.PDR.BIT.B2 = 0;
      PORTE.PDR.BIT.B1 = 0;
      PORTE.PDR.BIT.B0 = 0;
      
      PORTE.PMR.BIT.B5 = 1;
      PORTE.PMR.BIT.B4 = 0;
      PORTE.PMR.BIT.B3 = 1;
      PORTE.PMR.BIT.B2 = 1;
      PORTE.PMR.BIT.B1 = 0;
      PORTE.PMR.BIT.B0 = 0;     
      
      MPC.PE5PFS.BYTE = 0x11;
      MPC.PE4PFS.BYTE = 0x00;
      MPC.PE3PFS.BYTE = 0x07;
      MPC.PE2PFS.BYTE = 0x07;
      MPC.PE1PFS.BYTE = 0x00;
      MPC.PE0PFS.BYTE = 0x00;


    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port F ===========================  //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                           //
    // Bit[F3]          1        0          0         0           00000b              :PF3  Output          RA B          //
    // Bit[F2]          1        0          0         0           00000b              :PF2  Output          RA A          //
    // Bit[F1]          0        0          0         0                -                  :PF1  Input            PSDIEB      //
    // Bit[F0]          0        0          0         0                -                  :PF0  Input            CKPD          //
    // ======================================================== //
      //PORTF.PDR.BYTE = 0x0C;
      //PORTF.PMR.BYTE = 0x00;
      //PORTF.PDR.BIT.B3 = 1;
      //PORTF.PDR.BIT.B2 = 1;
      PORTF.PDR.BIT.B3 = 0; //[IEDS vs. EDS deriver,Lyabryan,2016/07/14]
      PORTF.PDR.BIT.B2 = 0; //[IEDS vs. EDS deriver,Lyabryan,2016/07/14]
      PORTF.PDR.BIT.B1 = 1; //[New addition IO card,Lyabryan,2019/07/22]
      //PORTF.PDR.BIT.B1 = 0;
      
      PORTF.PMR.BIT.B3 = 0;
      PORTF.PMR.BIT.B2 = 0;
      //PORTF.PMR.BIT.B1 = 0;
      //PORTF.PMR.BIT.B0 = 0; 
      
      MPC.PF3PFS.BYTE = 0x00;
      MPC.PF2PFS.BYTE = 0x00;
      //MPC.PF1PFS.BYTE = 0x00;
      //MPC.PF0PFS.BYTE = 0x00;
      PORTF.PODR.BIT.B1 = 1;  //[New addition IO card,Lyabryan,2019/07/22]

    //================ PIN FUNCTION/IO PORTS ======================= //
    //Modified by                                                                                                                       //
    //======================== Port G =========================== //
    //                   PDR   PODR    PIDR   PMR         P9nPFS PSEL[4:0]                                          //
    // Bit[G6]          0        0          0         0           00000b              :PG6  Input            DI8         //
    // Bit[G5]          1        0          0         1           01010b              :PG5  SCK3            DIR1       //
    // Bit[G4]          0        0          0         1           01010b              :PG4  RXD3            RXD1      //
    // Bit[G3]          1        0          0         1           01010b              :PG3  TXD3            TXD1       //
    // Bit[G2]          1        0          0         0           01010b              :PG2  SCK2            DIR3        //
    // Bit[G1]          0        0          0         1           01010b              :PG1  RXD2            RXD3       //
    // Bit[G0]          1        0          0         1           01010b              :PG0  TXD2            TXD3        //
    // ======================================================== //
      //PORTG.PDR.BYTE = 0x2D;
      //PORTG.PMR.BYTE = 0x3F;
      PORTG.PDR.BIT.B6 = 0;
      PORTG.PDR.BIT.B5 = 1;
      PORTG.PDR.BIT.B4 = 0;
      PORTG.PDR.BIT.B3 = 1;
      PORTG.PDR.BIT.B2 = 1;
      PORTG.PDR.BIT.B1 = 0;
      PORTG.PDR.BIT.B0 = 1;
      
      PORTG.PMR.BIT.B6 = 0;
      PORTG.PMR.BIT.B5 = 0;
      PORTG.PMR.BIT.B4 = 1;
      PORTG.PMR.BIT.B3 = 1;
      PORTG.PMR.BIT.B2 = 0;
      PORTG.PMR.BIT.B1 = 1;
      PORTG.PMR.BIT.B0 = 1;  
      
      MPC.PG6PFS.BYTE = 0x00;
      MPC.PG5PFS.BYTE = 0x0A;
      MPC.PG4PFS.BYTE = 0x0A;
      MPC.PG3PFS.BYTE = 0x0A;
      MPC.PG2PFS.BYTE = 0x0A;
      MPC.PG1PFS.BYTE = 0x0A;
      MPC.PG0PFS.BYTE = 0x0A;

}

/* CMT0 Init */
void InitCMT0_500us(void)
{
    MSTP(CMT0) = 0 ;  // enable the Module CMT0
    
    // Initial CMT0 interrupt /
    IEN(CMT0, CMI0) = 0 ;  // disable the interrupt
    
    //=== Compare Match Timer Start Register (CMSTR) =======================//
    // Bit[15-2]      -     :RESERVED                           
    // Bit[1]           0     :STR1, Count Start 1          
    // Bit[0]           0     :STR0, Count Start 0                   
    CMT.CMSTR0.BIT.STR0 = 0;
    //=== Compare Match Control/Status Register (CMCSR) ====================//
    // Bit[15-8]      -     :RESERVED                
    // Bit[7]           0      :Reserved                  
    // Bit[6]           0     :CMIE, Compare Match Interrupt Enable      
    // Bit[5-2]       0     :RESERVED                                  
    // Bit[1-0]       0     :CKS[1:0],clock select 1 and 0, Phi/8(Phi=48MHz)
    //CMT0.CMCR.BIT.CMIE = 1;
    //CMT0.CMCR.BIT.CKS = 0;
    CMT0.CMCR.WORD = 0x0040 ;  // PCLK/8 = 6 MHz

    // Peripheral clock 40MHz                                               
    //1ms(1KHz),(48MHz/8)/1KHz = 6000 
	//CMT0.CMCOR = 5000;
    // 0.5ms(2KHz),(48MHz/8)/2KHz = 3000 
    CMT0.CMCOR = 3000;

    //===== Priority level of 1ms Interrupt ========//
    //============= Interrupt priority register 8 ================//
    // Bit[15-12]     0111  :CMT_0 priority level                          
    // Bit[11-8]       0000  :CMT_1 priority level                  
    // Bit[7-4]         0000  :RESERVED                                 
    // Bit[3-0]         0000  :WDT   priority level        
    
    //INTC.IPR08.BIT._CMT0 = 7;		//0.5ms    
	//ICU.IPR08.BIT._CMT0 = 7;		//0.5ms 
	IPR(CMT0, CMI0) = 7;  // set the priority level
    IR(CMT0, CMI0) = 0;  // IR bit clear
    IEN(CMT0, CMI0) = 1;  // enable the interrupt
	
    CMT0.CMCNT = 0x0000;	
}


/* CMT1 Init */
void InitCMT1_100us(void)
{
    MSTP(CMT1) = 0 ;  // enable the Module CMT1

    // Initial CMT1 interrupt//
    IEN(CMT1, CMI1) = 0 ;  // disable the interrupt
  
    //============ Compare Match Timer Start Register (CMSTR) ================//
    // Bit[15-2]      -     :RESERVED                                      
    // Bit[1]           0     :STR1, Count Start 1                        
    // Bit[0]           0     :STR0, Count Start 0                   
    CMT.CMSTR0.BIT.STR1 = 0;
    
    //========= Compare Match Control/Status Register (CMCSR) ==============//
    // Bit[15-8]      -     :RESERVED                                   
    // Bit[7]           0      :Reserved                     
    // Bit[6]           0     :CMIE, Compare Match Interrupt Enable          
    // Bit[5-2]       0     :RESERVED                                      
    // Bit[1-0]       0     :CKS[1:0],clock select 1 and 0, Phi/8(Phi=48MHz)
    //CMT1.CMCR.BIT.CMIE = 1;
    //CMT1.CMCR.BIT.CKS = 0;
    CMT1.CMCR.WORD = 0x0040 ;  // PCLK/8 = 6 MHz

    // Peripheral clock 40MHz                                            
    // 100us(10KHz),(48MHz/8)/10KHz = 600                                  
    //CMT1.CMCOR = 600;
    CMT1.CMCOR = 600;  // compare value  // T = 100us => 1.5M/10KHz=150

    //======== Priority level of 1ms Interrupt  ========//
    //=== Interrupt priority register 8 ==================================== //
    // Bit[15-12]     1010  :CMT_0 priority level                           
    // Bit[11-8]       0000  :CMT_1 priority level                        
    // Bit[7-4]         0000  :RESERVED                                   
    // Bit[3-0]         0000  :WDT   priority level                        

    //INTC.IPR08.BIT._CMT1 = 10;		//100us
    //ICU.IPR08.BIT._CMT1 = 10;
    
      //*----- Interrupt configuration for CMT1 Function -------------------------/
    IPR(CMT1, CMI1) = 10 ;  // set the priority level
    IR(CMT1, CMI1) = 0 ;  // IR bit clear
    IEN(CMT1, CMI1) = 1 ;  // enable the interrupt
  
    CMT1.CMCNT = 0x0000;	
}

// 200us for USB routine, Sean, 2014/09/16
void InitCMT2(void)
{
    MSTP(CMT2) = 0 ;  // enable the Module CMT2

    // Initial CMT1 interrupt//
    IEN(CMT2, CMI2) = 0 ;  // disable the interrupt
  
    //============ Compare Match Timer Start Register (CMSTR) ================//
    // Bit[15-2]      -     :RESERVED                                      
    // Bit[1]           0     :STR2, Count Start 1                        
    // Bit[0]           0     :STR3, Count Start 0                   
    CMT.CMSTR1.BIT.STR2 = 0;
    
    //========= Compare Match Control/Status Register (CMCSR) ==============//
    // Bit[15-8]      -     :RESERVED                                   
    // Bit[7]           0      :Reserved                     
    // Bit[6]           0     :CMIE, Compare Match Interrupt Enable          
    // Bit[5-2]       0     :RESERVED                                      
    // Bit[1-0]       0     :CKS[1:0],clock select 1 and 0, Phi/8(Phi=48MHz)
    //CMT1.CMCR.BIT.CMIE = 1;
    //CMT1.CMCR.BIT.CKS = 0;
    CMT2.CMCR.WORD = 0x0040 ;  // PCLK/8 = 6 MHz

    // Peripheral clock 48MHz                                            
    // 200us(5KHz),(48MHz/8)/5KHz = 1200
    CMT2.CMCOR = 1200;  // compare value

    //======== Priority level of 1ms Interrupt  ========//
    //=== Interrupt priority register 8 ==================================== //
    // Bit[15-12]     1010  :CMT_0 priority level                           
    // Bit[11-8]       0000  :CMT_1 priority level                        
    // Bit[7-4]         0000  :RESERVED                                   
    // Bit[3-0]         0000  :WDT   priority level                        

    //INTC.IPR08.BIT._CMT1 = 10;		//100us
    //ICU.IPR08.BIT._CMT1 = 10;
    
      //*----- Interrupt configuration for CMT1 Function -------------------------/
    IPR(CMT2, CMI2) = 2 ;  // set the priority level
    IR(CMT2, CMI2) = 0 ;  // IR bit clear
    IEN(CMT2, CMI2) = 1 ;  // enable the interrupt
  
    CMT2.CMCNT = 0x0000;	
}

/* MTU20:Capture Input / MTU21:phase counting */
void InitMTU21_PG1(void)
{
    MSTP(MTU0) = 0 ;  // enable Module
    MSTP(MTU1) = 0 ;  // enable Module

    //MTU20.TCNT = 0x0000;
    MTU0.TCNT = 0x0000;
    
//    MTU21.TCNT = 0x0000;	//DEL By SCOTTY 12/06/2007

    /*=== Timer 0 Control Register (TCR0) ==================================*/
    /* Bit[7-5]       000   :CCLR2~0, Clearing disabled		            	*/
    /* Bit[4-3]       00    :CKEG1~0, Count on both edges                   */
    /* Bit[2-0]       001   :TPSC2~0, Internal Clock:phi/4                  */
    //MTU20.TCR.BYTE = 0x01;
    MTU0.TCR.BYTE = 0x01;

    /*=== Timer 0 Mode Register (TMDR0) ====================================*/
    /* Bit[7]         0     :RESERVED                                       */
    /* Bit[6]         0     :BFE,TGRE and TGRF Buffer operation             */
    /* Bit[5]         0     :BFB,TGRB and TGRD Buffer operation             */
    /* Bit[4]         0     :BFA,TGRA and TGRC Buffer operation             */
    /*----------------------------------------------------------------------*/
    /* Bit[3-0]       0000  :MD3~0,normal operation                             */
    //MTU20.TMDR.BYTE = 0x00;
    MTU0.TMDR1.BYTE = 0x00;

    /*=== Timer 0 I/O Control Register (TIOR0H) ============================*/
    /* Bit[7-4]       0000  :IOB3~0, TGR0B Output retained					*/
    /* Bit[3-0]       11xx  :IOA3~0, TIOC0A capture input@TCNT1 count up/down*/
    //MTU20.TIOR.BYTE.H = 0x0F;
    MTU0.TIORH.BYTE = 0x0F;

    /*=== Timer 0 I/O Control Register (TIOR0L) ============================*/
    /* Bit[7-4]       0000  :IOD3~0, TGR0D Output retained		    */
    /* Bit[3-0]       0000  :IOC3~0, TGR0C Output retained		    */
    //MTU20.TIOR.BYTE.L = 0x00;
    MTU0.TIORL.BYTE = 0x00;

    /* Peripheral clock 40MHz/4                                             */
    /* 1ms(1KHz),(40MHz)/4/1KHz = 10000                                     */
	//MTU20.TGRA = 10000;
	//MTU20.TGRA = 20000;
	//MTU20.TGRC = 5000;

    /*=== Timer 0 Interrupt Enable Register ================================*/
    /* Bit[7]         0     :TTGE, AD conversion start when compare-match   */
    /* Bit[6]         0     :TTGE2,AD Converter Start Request Enable 2      */
    /* Bit[5]         0     :TCIEU, Underflow interrupt request             */
    /* Bit[4]         0     :TCIEV, Overflow interrupt request              */
    /* Bit[3]         0     :TGIED, TGR Interrupt Enable D                  */
    /* Bit[2]         0     :TGIEC, TGR Interrupt Enable C                  */
    /* Bit[1]         0     :TGIEB, TGR Interrupt Enable B                  */
    /* Bit[0]         0     :TGIEA, TGR Interrupt Enable A                  */
    //MTU20.TIER.BYTE = 0x00;
    MTU0.TIER.BYTE = 0x00;

    /*=== Timer 1 Mode Register (TMDR1) ====================================*/
    /* Bit[7]         0     :RESERVED                                       */
    /* Bit[6]         0     :BFE,TGRE and TGRF Buffer operation             */
    /* Bit[5]         0     :BFB,TGRB and TGRD Buffer operation             */
    /* Bit[4]         0     :BFA,TGRA and TGRC Buffer operation             */
    /*----------------------------------------------------------------------*/
    /* Bit[3-0]       0100  :MD3~0,Phase Counting mode 1                    */
    //MTU21.TMDR.BYTE = 0x04;
    MTU1.TMDR1.BYTE = 0x04;

    /*=== Timer 1 I/O Control Register (TIOR1) =============================*/
    /* Bit[7-4]       000x  :IOB3~0, TGR1B Output retained		            */
    /* Bit[3-0]       11xx  :IOA3~0, TIOC1A capture input@TIOC0A input capture*/
    //MTU21.TIOR.BYTE = 0x0F;
    MTU1.TIOR.BYTE = 0x0F;
    
    /*=== Timer 1 Interrupt Enable Register ================================*/
    /* Bit[7]         0     :TTGE, AD conversion start when compare-match   */
    /* Bit[6]         0     :TTGE2,AD Converter Start Request Enable 2      */
    /* Bit[5]         1     :TCIEU, Underflow interrupt request             */
    /* Bit[4]         1     :TCIEV, Overflow interrupt request              */
    /* Bit[3]         0     :TGIED, TGR Interrupt Enable D                  */
    /* Bit[2]         0     :TGIEC, TGR Interrupt Enable C                  */
    /* Bit[1]         0     :TGIEB, TGR Interrupt Enable B                  */
    /* Bit[0]         0     :TGIEA, TGR Interrupt Enable A                  */	
#if SCOTTY
	//MTU21.TSR.BYTE &= 0xCF;  // 16384 TEST, scotty, 05/10/2007, //clear TCNT underflow/overflow flag
	//MTU21.TIER.BYTE = 0x30;  // Enable TCIEU, TCIEV, 16384 TEST, scotty, 05/10/2007
	MTU1.TSR.BYTE &= 0xCF;
    MTU1.TIER.BYTE = 0x30; // Enable TCIEU, TCIEV
#else 
    MTU21.TIER.BYTE = 0x00;
#endif 

	/*=== Timer Start Registr (TSTR) =======================================*/
    /* Bit[7]         0     :CST4, counter start 4                          */
    /* Bit[6]         0     :CST3, counter start 3                          */
    /* Bit[5-3]       ---   :RESERVED                                       */
    /* Bit[2]         0     :CST2, counter start 2                          */
    /* Bit[1]         0     :CST1, counter start 1                          */
    /* Bit[0]         0     :CST0, counter start 0                          */
//	MTU2.TSTR.BYTE &= 0xFF;
    
    /*=== Timer 1 Control Register (TCR1) ==================================*/
    /* Bit[7-5]       000   :CCLR2~0,TCNT clearing disabled                 */
    /* Bit[4-3]       00    :CKEG1~0,Count at rising edges                  */
    /* Bit[2-0]       000   :TPSC2~0,Internal Clock:phi/1                   */
//    MTU21.TCR.BYTE = 0x00;
    MTU1.TCR.BYTE = 0x00;
    /**** Priority level of Waveform interrupt ******************************/
    /*=== Interrupt priority register 9 ====================================*/
    /* Bit[15-12]     1011  :MTU20 priority level = 11                      */
    /* Bit[11-8]      1011  :MTU20 priority level = 11                      */
    /* Bit[7-4]       0000  :MTU21 priority level                           */
    /* Bit[3-0]       1011  :MTU21 priority level = 11                      */
    //INTC.IPR09.BIT._MTU20G = 11;	//PG
    //INTC.IPR09.BIT._MTU20C = 11;	//PG overflow check interrupt
    //INTC.IPR09.BIT._MTU21C = 11;	//PG Overflow & underflow, scotty, 05/10/2007
    IEN(MTU1, TCIV1) = 0 ;  // Disable the interrupt
    IPR(MTU1, TCIV1) = 11 ;  // set the priority level to 13
    IR(MTU1,TCIV1) = 0 ;  // IR bit clear
    IEN(MTU1, TCIV1) = 1 ;  // enable the interrupt
    
    IEN(MTU1, TCIU1) = 0 ;  // Disable the interrupt
    IPR(MTU1, TCIU1) = 11 ;  // set the priority level to 13
    IR(MTU1,TCIU1) = 0 ;  // IR bit clear
    IEN(MTU1, TCIU1) = 1 ;  // enable the interrupt

    IEN(MTU0, TGIA0) = 0 ;  // Disable the interrupt
    IPR(MTU0, TGIA0) = 11 ;  // set the priority level to 13
    IR(MTU0,TGIA0) = 0 ;  // IR bit clear
    IEN(MTU0, TGIA0) = 1 ;  // enable the interrupt

    IEN(MTU0, TCIV0) = 0 ;  // Disable the interrupt
    IPR(MTU0, TCIV0) = 11 ;  // set the priority level to 13
    IR(MTU0,TCIV0) = 0 ;  // IR bit clear
    IEN(MTU0, TCIV0) = 1 ;  // enable the interrupt

	PGSEL = 1;	// Read ABZ, DINO, 03/09/2010
}

void InitMTU234_WG(void)
{
   // ====  PWM I/O Setting ==== //
    //PORT7.PDR.BIT.B1 = 1;
    //PORT7.PDR.BIT.B2 = 1;
    //PORT7.PDR.BIT.B3 = 1;
    //PORT7.PDR.BIT.B4 = 1;
    //PORT7.PDR.BIT.B5 = 1;
    //PORT7.PDR.BIT.B6 = 1;

    //PORT7.PMR.BIT.B1 = 1;
    //PORT7.PMR.BIT.B2 = 1;
    //PORT7.PMR.BIT.B3 = 1;
    //PORT7.PMR.BIT.B4 = 1;
    //PORT7.PMR.BIT.B5 = 1;
    //PORT7.PMR.BIT.B6 = 1;

    //MPC.P76PFS.BIT.PSEL = 1;
    //MPC.P75PFS.BIT.PSEL = 1;
    //MPC.P74PFS.BIT.PSEL = 1;
    //MPC.P73PFS.BIT.PSEL = 1;
    //MPC.P72PFS.BIT.PSEL = 1;
    //MPC.P71PFS.BIT.PSEL = 1;
   // =================== //

    MSTP(MTU3) = 0 ;  // enable Module
    MSTP(MTU4) = 0 ;  // enable Module

    /*=== Timer Start Registr (TSTR) =======================================*/
    /* Bit[7]         0     :CST4, counter start 4                          */
    /* Bit[6]         0     :CST3, counter start 3                          */
    /* Bit[5-3]       ---   :RESERVED                                       */
    /* Bit[2]         0     :CST2, counter start 2                          */
    /* Bit[1]         0     :CST1, counter start 1                          */
    /* Bit[0]         0     :CST0, counter start 0                          */
    //MTU2.TSTR.BYTE &= 0x07;
    MTU.TSTRA.BYTE &= 0xF8;

    /*=== Timer 3 Control Register (TCR3) ==================================*/
    /* Bit[7-5]       011   :CCLR2~0,Synchronizing clear, TSYR              */
    /* Bit[4-3]       00    :CKEG1~0,Count on both edges                    */
    /* Bit[2-0]       000   :TPSC2~0,Internal Clock:phi/1                   */
    //MTU23.TCR.BYTE = 0x60;
    //MTU24.TCR.BYTE = 0x60;
    MTU3.TCR.BYTE = 0x60;
    MTU4.TCR.BYTE = 0x60;

	/*=== Timer Gate Control Register (TGCR) ===============================*/
    /* Bit[7]         -     :RESERVED                                       */
    /* Bit[6]         0     :BDC, Brushless DC selector                     */
    /* Bit[5]         1     :N, RESERVED Phase Output                       */
    /* Bit[4]         1     :P, Positive Phase Output                       */
    /*----------------------------------------------------------------------*/
    /* Bit[3]         0     :FB, Feedback Input                             */
    /* Bit[2-0]       000   :WF,VF,UF, Output Phase Switch                  */
    //MTU2.TGCR.BYTE = 0xB0;
    MTU.TGCRA.BYTE = 0xB0;
	
    /**** Load TCNT_3, 4 with initial values. *******************************/
    //MTU23.TCNT = DeadTime;    /* Set the same value as dead time in TCNT_3. */
    //MTU24.TCNT = 0;           /* Clear TCNT_4.                              */
    MTU3.TCNT = DeadTime;  // Set the same value as dead time in TCNT_6.
    MTU4.TCNT = 0 ;   

    /*=== Timer Synchro Register (TSYR) ====================================*/
    /* Bit[7]         1     :SYNC4                                          */
    /* Bit[6]         1     :SYNC3                                          */
    /* Bit[5-3]       000   :RESERVED                                       */
    /* Bit[2]         0     :SYNC2                                          */
    /* Bit[1]         0     :SYNC1                                          */
    /* Bit[0]         0     :SYNC0                                          */
    MTU.TSYRA.BYTE = 0xC0;
	
		

    /********* Set PWM period, duty cycle, dead time, and carrier period. ***/
    n_period = U32divU16(MTU2CLK, 1000);
    
    experiod = n_period + (n_period>>1);

    //MTU23.TGRD = experiod;    /* Set TGRD_3 (buffer register for TGRB_3).        */
    //MTU23.TGRB = 0;           /* Set TGRB_3 (compare register for PWM output 1). */
    MTU3.TGRD = experiod;
    MTU3.TGRB = 0;
    
    //MTU24.TGRC = experiod;    /* Set TGRC_4 (buffer register for TGRA_4).        */
    //MTU24.TGRA = 0;           /* Set TGRA_4 (compare register for PWM output 2). */
    MTU4.TGRC = experiod;
    MTU4.TGRA = 0;
    
    //MTU24.TGRD = experiod;    /* Set TGRD_4 (buffer register for TGRB_4).        */
    //MTU24.TGRB = 0;           /* Set TGRB_4 (compare register for PWM output 3). */
    MTU4.TGRD = experiod;
    MTU4.TGRB = 0;

    //MTU2.TDDR = DeadTime;    
    MTU.TDDRA = DeadTime;
    
    /*=== Timer Period Data Register (TCDR) ================================*/
    //MTU2.TCDR = experiod;
    MTU.TCDRA = experiod;
    
    /*=== Timer Period Buffer Register (TCBR) ==============================*/
    //MTU2.TCBR = experiod;
    MTU.TCBRA = experiod;
    
    /*===Set TGRC_3 (buffer register for TGRA_3) ===========================*/
    //MTU23.TGRA = experiod + DeadTime;   
    //MTU23.TGRC = experiod + DeadTime;
    MTU3.TGRA = experiod + DeadTime;   
    MTU3.TGRC = experiod + DeadTime;

    /*=== Timer Output Control Register (TOCR1) ============================*/
    /* Bit[7]         -     :RESERVED                                        */
    /* Bit[6]         1     :PSYE, Toggle output synchronous with PWM period*/
    /* Bit[5-4]       00    :RESERVED                                        */
    /* Bit[3]         0     :TOCL                                           */
    /* Bit[2]         0     :TOCS, TOCR1 setting is selected                */
    /* Bit[1]         0     :OLSN, High level                               */
    /* Bit[0]         0     :OLSP, High level                               */
    //MTU2.TOCR1.BYTE = 0x40;
    MTU.TOCR1A.BYTE = 0x40 ;  // 0x40 ;

    /*=== Timer Output Control Register (TOCR2) ============================*/
    /* Bit[7-6]       10    :BF, Buffer Transfer Timing select              */
    /* Bit[6]         1     :OLS3N,TIOC4D                                   */
    /* Bit[5]         1     :OLS3P,TIOC4B                                   */
    /* Bit[3]         1     :OLS2N,TIOC4C                                   */
    /* Bit[2]         1     :OLS2P,TIOC4A                                   */
    /* Bit[1]         1     :OLS1N,TIOC3D                                   */
    /* Bit[0]         1     :OLS1P,TIOC3B                                   */
    //MTU2.TOCR2.BYTE = 0xBF;
    MTU.TOCR2A.BYTE = 0xBF ;

    /*=== Timer 3 Mode Register (TMDR3) ====================================*/
    /* Bit[7]         0     :RESERVED                                       */
    /* Bit[6]         1     :BFE,TGRE and TGRF Buffer operation             */
    /* Bit[5]         1     :BFB,TGRB and TGRD Buffer operation             */
    /* Bit[4]         1     :BFA,TGRA and TGRC Buffer operation             */
    /*----------------------------------------------------------------------*/
    /* Bit[3-0]       1101  :MD3~0,Complementary PWM 1(transmit at crest)   */
    /* Bit[3-0]       1110  :MD3~0,Complementary PWM 2(transmit at trough)  */
    /* Bit[3-0]       1111  :MD3~0,Complementary PWM 2(transmit at crest and trough)*/
//#if DINO
//	MTU23.TMDR.BYTE = 0x3D;	// Complementary PWM 1(transmit at crest)
	//MTU23.TMDR.BYTE = 0x3E;	// Complementary PWM 1(transmit at trough), Modify by DINO, 03/03/2009
	MTU3.TMDR1.BYTE = 0x3E; // Complementary PWM 1(transfert at trough)
//#else
//    MTU23.TMDR.BYTE = 0x3F;	// Complementary PWM 2(transmit at crest and trough)
//#endif
    /* Do not set in TMDR4                                                  */

    /*=== Timer 3 I/O Control Register (TIOR3H) ============================*/
    /* Bit[7-4]       0111  :IOB3~0, TGR3B Toggle output on compare-match   */
    /* Bit[3-0]       0000  :IOA3~0, output disable                         */
    //MTU23.TIOR.BYTE.H |= 0x70;
    MTU3.TIORH.BYTE |= 0x70;

	/*=== Timer 3 I/O Control Register (TIOR3L) ============================*/
    /* Bit[7-4]       0111  :IOD3~0, TGR3D Toggle output on compare-match   */
    /* Bit[3-0]       0000  :IOC3~0, output disable                         */
    //MTU23.TIOR.BYTE.L |= 0x70;
    MTU3.TIORL.BYTE |= 0x70;
    
	/*=== Timer 4 I/O Control Register (TIOR4H) ============================*/
    /* Bit[7-4]       0111  :IOB3~0, TGR4B Toggle output on compare-match   */
    /* Bit[3-0]       0111  :IOA3~0, TGR4A Toggle output on compare-match   */
    //MTU24.TIOR.BYTE.H |= 0x77;
    MTU4.TIORH.BYTE |= 0x77;
    
	/*=== Timer 3 I/O Control Register (TIOR4L) ============================*/
    /* Bit[7-4]       0111  :IOD3~0, TGR4D Toggle output on compare-match   */
    /* Bit[3-0]       0000  :IOC3~0, TGR4C Toggle output on compare-match   */
    //MTU24.TIOR.BYTE.L |= 0x77;
    MTU4.TIORL.BYTE |= 0x77;

    /*=== Timer 1 Interrupt Enable Register ================================*/
    /* Bit[7]         0     :TTGE, AD conversion start when compare-match   */
    /* Bit[6]         0     :TTGE2,AD Converter Start Request Enable 2      */
    /* Bit[5]         0     :TCIEU, Underflow interrupt request             */
    /* Bit[4]         0     :TCIEV, Overflow interrupt request              */
    /* Bit[3]         0     :TGIED, TGR Interrupt Enable D                  */
    /* Bit[2]         0     :TGIEC, TGR Interrupt Enable C                  */
    /* Bit[1]         0     :TGIEB, TGR Interrupt Enable B                  */
    /* Bit[0]         1     :TGIEA, TGR Interrupt Enable A                  */	
    //MTU23.TIER.BYTE = 0x01;	// dino, 03/05/2007
    MTU3.TIER.BYTE = 0x01;
    
    /*=== Timer Output Master Enable Register (TOERA) =======================*/
    /* Bit[7-6]       11    :RESERVED                                       */
    /* Bit[5]         1     :OE4D, Enable TIOC4D pin MTU output             */
    /* Bit[4]         1     :OE4C, Enable TIOC4C pin MTU output             */
    /* Bit[3]         1     :OE3D, Enable TIOC3D pin MTU output             */
    /* Bit[2]         1     :OE4B, Enable TIOC4B pin MTU output             */
    /* Bit[1]         1     :OE4A, Enable TIOC4A pin MTU output             */
    /* Bit[0]         1     :OE3B, Enable TIOC3B pin MTU output             */
    //MTU2.TOER.BYTE = 0x00;
    MTU.TOERA.BYTE = 0x00 ;

// [ AD Conversion Test, DINO, 10/09/2009
#if NEW_AD
	MTU24.TADCOBRA = 0;		   // Set A/D activation timing (buffer register)
	MTU24.TADCORA = 0;		   // Set A/D activation timing

    /*=== Timer A/D Converter Start Request Control Register (TADCR)=========================*/
    /* Bit[15-14]     10    :BF, Transfer data from buffer at the trough of the TCNT_4 count */
    /* Bit[13-8]      0     :RESERVED                                                        */
    /* Bit[7]         1     :UT4AE, Start requests(TRG4AN) enabled during TCNT_4 up-count    */
    /* Bit[6]         0     :DT4AE, Start requests(TRG4AN) disabled during TCNT_4 down-count */
    /* Bit[5]         0     :UT4BE, Start requests(TRG4BN) disabled during TCNT_4 up-count   */
    /* Bit[4]         0     :DT4BE, Start requests(TRG4BN) disabled during TCNT_4 down-count */
    /* Bit[3]         0     :ITA3AE, Does not link with TGIA_3 interrupt skipping            */
    /* Bit[2]         0     :ITA4VE, Does not link with TCIV_4 interrupt skipping            */
    /* Bit[1]         0     :ITB3AE, Does not link with TGIA_3 interrupt skipping            */
    /* Bit[0]         0     :ITB4VE, Does not link with TCIV_4 interrupt skipping            */
	MTU24.TADCR.WORD = 0x8080;
#endif
// ]  
    /**** Priority level of Waveform interrupt ******************************/
    /*=== Interrupt priority register 10 ====================================*/
    /* Bit[15-12]     1010  :MTU22 priority level                           */
    /* Bit[11-8]      0000  :MTU22 priority level                           */
    /* Bit[7-4]       0000  :MTU23 priority level = MTU23G(TGIA) 12         */
    /* Bit[3-0]       0000  :MTU23 priority level                           */        
    //INTC.IPR10.BIT._MTU23G = 12;	//WG
    /*----- Interrupt configuration for Waveform Generator --------------------*/
    IEN(MTU3, TGIA3) = 0 ;  // Disable the interrupt
    IPR(MTU3, TGIA3) = 12 ;  // set the priority level to 13
    IR(MTU3,TGIA3) = 0 ;  // IR bit clear
    IEN(MTU3, TGIA3) = 1 ;  // enable the interrupt

}

void InitMTU2S4_PGZ(void)
{
    MSTP(MTU6) = 0 ;  // enable Module

    //MTU2S.TSTR.BIT.CST4 = 0;
    MTU.TSTRB.BIT.CST6 = 0;
    //MTU2S4.TCNT = 0x0000;
    MTU6.TCNT = 0x0000;
    /*=== Timer 4S Control Register (TCR4S) ================================*/
    /* Bit[7-5]       000   :CCLR2~0, Clearing disabled		            	*/
    /* Bit[4-3]       00    :CKEG1~0, Count on both edges                   */
    /* Bit[2-0]       001   :TPSC2~0, Internal Clock:phi/4                  */
    //MTU2S4.TCR.BYTE = 0x01;
    MTU6.TCR.BYTE = 0x01;
    /*=== Timer 4S Mode Register (TMDR4S) ==================================*/
    /* Bit[7]         0     :RESERVED                                       */
    /* Bit[6]         0     :BFE,TGRE and TGRF Buffer operation             */
    /* Bit[5]         0     :BFB,TGRB and TGRD Buffer operation             */
    /* Bit[4]         0     :BFA,TGRA and TGRC Buffer operation             */
    /*----------------------------------------------------------------------*/
    /* Bit[3-0]       0000  :Normal operation                               */
    //MTU2S4.TMDR.BYTE = 0x00;
    MTU6.TMDR1.BYTE = 0x00;

    /*=== Timer 4S I/O Control Register (TIOR4SH) ==========================*/
    /* Bit[7-4]       0000  :IOB3~0, TGR4BS Output retained                 */
    /* Bit[3-0]       0000  :IOA3~0, TGR4AS Output retained		    */
    //MTU2S4.TIOR.BYTE.H = 0x00;	// 12/18/2006, dino
    MTU6.TIORH.BYTE = 0x00;	    
    MTU6.TIORL.BYTE = 0x00; 

    /*=== Timer 0 I/O Control Register (TIOR4SL) ============================*/
    /* Bit[7-4]       1001  :IOD3~0, TGR4DS Input capture at falling edge    */
    /* Bit[3-0]       0000  :IOCA~0, TGR4CS Output retained		     */
    //MTU2S4.TIOR.BYTE.L = 0x90;
    MTU6.TIORL.BYTE = 0x90; 

    /*=== Timer 0 Interrupt Enable Register ================================*/
    /* Bit[7]         0     :TTGE, AD conversion start when compare-match   */
    /* Bit[6]         0     :TTGE2,AD Converter Start Request Enable 2      */
    /* Bit[5]         0     :TCIEU, Underflow interrupt request             */
    /* Bit[4]         0     :TCIEV, Overflow interrupt request              */
    /* Bit[3]         1     :TGIED, TGR Interrupt Enable D                  */
    /* Bit[2]         0     :TGIEC, TGR Interrupt Enable C                  */
    /* Bit[1]         0     :TGIEB, TGR Interrupt Enable B                  */
    /* Bit[0]         0     :TGIEA, TGR Interrupt Enable A                  */
    //MTU2S4.TIER.BYTE = 0x08;	// Enable TGIED for Z pluse,2006/12/18,dino  
    MTU6.TIER.BYTE = 0x08;

    /**** Priority level of Waveform interrupt ******************************/
    /*=== Interrupt priority register D ====================================*/
    /* Bit[15-12]     1011  :MTU2S4 priority level = 11                     */
    /* Bit[11-8]      0000  :MTU2S4 priority level = 11                     */
    /* Bit[7-4]       1011  :MTU2S5 priority level                          */
    /* Bit[3-0]       1011  :MTU2S5 priority level                          */
    //INTC.IPR12.BIT._MTU2S4G = 11	;	// PGZ

    IEN(MTU6, TGID6) = 0 ;  // Disable the interrupt
    IPR(MTU6, TGID6) = 11 ;  // set the priority level to 13
    IR(MTU6,TGID6) = 0 ;  // IR bit clear
    IEN(MTU6, TGID6) = 1 ;  // enable the interrupt

    //MTU2S4.TSR.BYTE = 0x00;
     MTU6.TSR.BYTE = 0x00;

}

void InitAD_S12B0(void)
{  
   //==== I/O setting ====//
    //MPC.P43PFS.BYTE = 0x80;
    //MPC.P42PFS.BYTE = 0x80;
    //MPC.P41PFS.BYTE = 0x80;
    //MPC.P40PFS.BYTE = 0x80;
    //PORT4.PIDR.BIT.B0 = 0;
    //PORT4.PIDR.BIT.B1 = 0;
    //PORT4.PIDR.BIT.B2 = 0;
    //PORT4.PIDR.BIT.B3 = 0;

    MSTP(S12ADB0) = 0 ;  // enable Module
    

    /*=== A/D Converter: module 0 ==========================================*/
    /*=== AD Control Register 0 (ADCR0) ====================================*/
    /* Bit[15]        0     :ADST, A/D Conversion Start                               */
    /* Bit[14-13] 10    :ADCS[1:0], Scan Mode Select                               */
    /* Bit[12]        0     :ADIE, Scan End Interrupt Enable                                */
    /* Bit[10-11]   0     :ADST, A/D Start                                 */
    /* Bit[9]          0     :TRGE, Trigger Start Enable,                         */
    /* Bit[8]          0     :EXTRG, Trigger Select                     */
    /* Bit[7]          0     :DBLE, Double Trigger Mode Select        */
    /* Bit[6]          0     :GBADIE, Group B Scan End Interrupt Enable                              */
    /* Bit[5]          0     :RESERVED                        */
    /* Bit[4-0]      0     :DBLANS[4:0] , Double-trigger channel select                           */
	S12ADB0.ADCSR.BIT.ADCS = 0x02 ;  // Continuous scan mode : For HW Check



    /*----- A/D Channel Select Register (ADANS0) --------------------------------*/
    /* Bit[15]       -     :Reserved                                             */
    /* Bit[114]       0     :PG002SEL, AN002 Programmable Gain Amplifier Select   */
    /* Bit[13]        0     :PG001SEL, AN001 Programmable Gain Amplifier Select   */
    /* Bit[12]        0     :PG000SEL, AN000 Programmable Gain Amplifier Select   */
    /* Bit[11]      -     :Reserved                                             */
    /* Bit[10]         0     :PG002EN, AN002 Programmable Gain Amplifier Enable    */
    /* Bit[9]           0     :PG001EN, AN001 Programmable Gain Amplifier Enable    */
    /* Bit[8]            0     :PG000EN, AN000 Programmable Gain Amplifier Enable    */
    /* Bit[7-4]        -     :Reserved                                             */
    /* Bit[3-0]        1     :ANSA[3:0] , A/D Conversion Channels Select    */
    S12ADB0.ADANSA.WORD = 0x000F;

    /*----- A/D Control Extended Register (ADCER) -------------------------------*/
    /* Bit[15]        0     :ADRFMT, A/D Data Register Format Select             */
    /* Bit[14]        -     :Reserved                                            */
    /* Bit[13]        0     :ADIEW, Double Trigger Interrupt Select              */
    /* Bit[12]        0     :ADIE2, 2-Channel Scan Interrupt Select              */
    /* Bit[11]        0     :DIAGM, Self Diagnostic Enable                       */
    /* Bit[10]        0     :DIAGLD, Self Diagnostic Mode Select                 */
    /* Bit[9-8]      00     :DIAGVAL, Self Diagnostic Voltage Select             */
    /* Bit[7-6]       -     :Reserved                                            */
    /* Bit[5]         0     :ACE, Automatic Clearing Enable                      */
    /* Bit[4-3]       -     :Reserved                                            */
    /* Bit[2-1]      00     :ADPRC, A/D Data Register Bit Precision Set          */
    /* Bit[0]         0     :SHBYP, Dedicated Sample-and-Hold Circuit Select     */
    S12ADB0.ADCER.WORD = 0x0000 ;



    S12ADB0.ADCSR.BIT.ADST = 1; // A/D Conversion Start   //moved to ADProg.C

    //S12ADB0.ADCSR.BIT.ADST = 1; // A/D Conversion Start


    /**** Priority level of AD module 2 AN8-AN15 Conv. End Interrupt ********/
    /*=== Interrupt priority register 05 ====================================*/
    /* Bit[15-12]     0000  :RESERVED				                         */
    /* Bit[11-8]      0000  :RESERVED				                         */
    /* Bit[7-4]       0000  :AD0   priority level                            */
    /* Bit[3-0]       0000  :AD1   priority level                            */    
    //INTC.IPR05.BIT._AD0 = 0;		//AD0, interrupt disalbe	
	
}


void InitAD_S12B1(void)
{  
    //==== I/O setting ====//
    //MPC.P47PFS.BYTE = 0x80;
    //MPC.P46PFS.BYTE = 0x80;
    //MPC.P45PFS.BYTE = 0x80;
    //MPC.P44PFS.BYTE = 0x80;
    //PORT4.PIDR.BIT.B4 = 0;
    //PORT4.PIDR.BIT.B5 = 0;
    //PORT4.PIDR.BIT.B6 = 0;
    //PORT4.PIDR.BIT.B7 = 0;

    MSTP(S12ADB1) = 0 ;  // enable Module

    /*=== A/D Converter: module 0 ==========================================*/
    /*=== AD Control Register 0 (ADCR0) ====================================*/
    /* Bit[15]        0     :ADST, A/D Conversion Start                               */
    /* Bit[14-13] 10    :ADCS[1:0], Scan Mode Select                               */
    /* Bit[12]        0     :ADIE, Scan End Interrupt Enable                                */
    /* Bit[10-11]   0     :ADST, A/D Start                                 */
    /* Bit[9]          0     :TRGE, Trigger Start Enable,                         */
    /* Bit[8]          0     :EXTRG, Trigger Select                     */
    /* Bit[7]          0     :DBLE, Double Trigger Mode Select        */
    /* Bit[6]          0     :GBADIE, Group B Scan End Interrupt Enable                              */
    /* Bit[5]          0     :RESERVED                        */
    /* Bit[4-0]      0     :DBLANS[4:0] , Double-trigger channel select                           */


	S12ADB1.ADCSR.BIT.ADCS = 0x02 ;  // Continuous scan mode : For HW Check



    /*----- A/D Channel Select Register (ADANS0) --------------------------------*/
    /* Bit[15]       -     :Reserved                                             */
    /* Bit[114]       0     :PG002SEL, AN002 Programmable Gain Amplifier Select   */
    /* Bit[13]        0     :PG001SEL, AN001 Programmable Gain Amplifier Select   */
    /* Bit[12]        0     :PG000SEL, AN000 Programmable Gain Amplifier Select   */
    /* Bit[11]      -     :Reserved                                             */
    /* Bit[10]         0     :PG002EN, AN002 Programmable Gain Amplifier Enable    */
    /* Bit[9]           0     :PG001EN, AN001 Programmable Gain Amplifier Enable    */
    /* Bit[8]            0     :PG000EN, AN000 Programmable Gain Amplifier Enable    */
    /* Bit[7-4]        -     :Reserved                                             */
    /* Bit[3-0]        1     :ANSA[3:0] , A/D Conversion Channels Select    */
    S12ADB1.ADANSA.WORD = 0x000F;

    /*----- A/D Control Extended Register (ADCER) -------------------------------*/
    /* Bit[15]        0     :ADRFMT, A/D Data Register Format Select             */
    /* Bit[14]        -     :Reserved                                            */
    /* Bit[13]        0     :ADIEW, Double Trigger Interrupt Select              */
    /* Bit[12]        0     :ADIE2, 2-Channel Scan Interrupt Select              */
    /* Bit[11]        0     :DIAGM, Self Diagnostic Enable                       */
    /* Bit[10]        0     :DIAGLD, Self Diagnostic Mode Select                 */
    /* Bit[9-8]      00     :DIAGVAL, Self Diagnostic Voltage Select             */
    /* Bit[7-6]       -     :Reserved                                            */
    /* Bit[5]         0     :ACE, Automatic Clearing Enable                      */
    /* Bit[4-3]       -     :Reserved                                            */
    /* Bit[2-1]      00     :ADPRC, A/D Data Register Bit Precision Set          */
    /* Bit[0]         0     :SHBYP, Dedicated Sample-and-Hold Circuit Select     */
    S12ADB1.ADCER.WORD = 0x0000 ;



    //S12ADB1.ADCSR.BIT.ADST = 1; // A/D Conversion Start   //moved to ADProg.C



    /**** Priority level of AD module 2 AN8-AN15 Conv. End Interrupt ********/
    /*=== Interrupt priority register 05 ====================================*/
    /* Bit[15-12]     0000  :RESERVED				                         */
    /* Bit[11-8]      0000  :RESERVED				                         */
    /* Bit[7-4]       0000  :AD0   priority level                            */
    /* Bit[3-0]       0000  :AD1   priority level                            */    
    //INTC.IPR05.BIT._AD0 = 0;		//AD0, interrupt disalbe	
	
}
void InitAD_S10(void){
  //==== I/O setting ====//  
    //MPC.P60PFS.BYTE = 0x80; 
    //MPC.P61PFS.BYTE = 0x80;
    //MPC.P62PFS.BYTE = 0x80;
    //MPC.P63PFS.BYTE = 0x80;

    //MPC.P50PFS.BYTE = 0x80; 
    //MPC.P51PFS.BYTE = 0x80;
    //MPC.P52PFS.BYTE = 0x80;
    //MPC.P53PFS.BYTE = 0x80;
    
    MSTP(AD) = 0 ;  // enable Module
    
    /*-----  A/D Channel Select Register 0  (ADANSA0) ---------------------------------*/
    /* Bit[15-0]    11 1100 1111  : ANSA0[15:0] ,  A/D Conversion Channels Select                      */
    
    AD0.ADANSA0.WORD = 0x03CF;

    
    /*----- A/D Control Register (ADCSR) ----------------*/
    /* Bit[15]         0       :ADST A/D Conversion Start                 */
    /* Bit[14]       0       :ADCS, Scan Mode Select                     */
    /* Bit[13]       -       :Reserved                                            */
    /* Bit[12]       0       :ADIE, Scan End Interrupt Enable         */
    /* Bit[11-10]  -       :Reserved                                            */
    /* Bit[9]         0       :TRGE, Trigger Start Enable                  */    
    /* Bit[8]         0       :EXTRG, Trigger Select                         */
    /* Bit[7-0]      -      :Reserved                                             */
    AD0.ADCSR.BIT.ADCS = 1;          //selet contiune mode


       
    
}


/* SCI2:remote control */
// [ Add by DINO, 03/23/2010
void InitSCI2(void)           //Keypad communication port
{
	
   UBYTE Rx2BufTmp,i;

    //==== I/O setting ====//  
    //MPC.PG1PFS.BIT.PSEL = 10;
    //PORTG.PMR.BIT.B1 = 1; /* I/O port for peripheral functions */
    //PORTG.PDR.BIT.B1 = 0; /* RxD2 is input */

    //MPC.PG0PFS.BIT.PSEL = 10;
    //PORTG.PMR.BIT.B0 = 1; /* I/O port for peripheral functions */
    //PORTG.PDR.BIT.B0 = 1; /* TxD2 is output */

    //PORTG.PMR.BIT.B2 = 0;
    //PORTG.PDR.BIT.B2 = 1;

    MSTP(SCI2) = 0; /* Enable the module SCI3 */
    
    SCIDIR2Flag = 1;

    //=============== Serial Control Register (SCR) ====================//						
    // Bit[7]         0     :TIE, Transmit Interrupt Enable                
    // Bit[6]         0     :RIE, Receive Interrupt Enable                
    // Bit[5]         0     :TE, Transmit Enable                      
    // Bit[4]         0     :RE, Receive Enable                           
    // Bit[3]         0     :MPIE , Multi-Processor Interrupt Enable          
    // Bit[2]         0     :TEIE, Transmit End Interrupt Enable  							
    // Bit[1-0]     00   :CKE1-0, Internal clock, SCK pin for input pin  
    SCI2.SCR.BYTE = 0x0000;

            
    /*=== Serial Mode Register =============================================*/
    /* Bit[7]         0     :C/A, Asynchronous mode                         */
    /* Bit[6]         1     :CHR, 0:8 bit data;  1:7-bit data               */
    /* Bit[5]         1     :PE, Parity bit check, 0: not added; 1:added    */
    /* Bit[4]         0     :O/E, 0:Even Parity; 1:Odd Parity               */
    /* Bit[3]         0     :STOP, 0:1 STOP bit;  1:2 STOP bit              */
    /* Bit[2]         0     :MP, Multiprocessor function disabled           */
    /* Bit[1-0]       00    :CKS1-0, Clock select 1 & 0                     */


      //----- Serial Status Register (SSR) -------------------------------------
      // Bit[7]         0     :Reserved
      // Bit[6]         0     :Reserved
      // Bit[5]         0     :ORER, Overrun Error Flag
      // Bit[4]         0     :FER, Framing Error Flag
      // Bit[3]         0     :PER, Parity Error Flag
      // Bit[2]         0     :TEND, Transmit End Flag
      // Bit[1]         0     :MPB, Multi-Processor
      // Bit[0]         0     :MPBT, Multi-Processor Bit Transfer
      SCI2.SSR.BYTE = 0x00;
    	SCI2.SCMR.BYTE	= 0;	
	   //SCI0.SCR.BYTE	= 0;
	SCI2.SMR.BYTE	= 0;

    PUON2LINE = 1;
    if (PUON2LINE==0){ 
    
    	switch(pr[PROTOCOL2]){
    
    	    case 0:
    	        Rx2BufTmp = 0x40;                     //ASCII, 7.N.1
    	    break;
    
    	    case 1:
    	        Rx2BufTmp = (0x40+0x08);              //ASCII, 7.N.2
    	    break;
    
    	    case 2:
    	        Rx2BufTmp = (0x40+0x20);              //ASCII, 7.E.1
    	    break;
    
    	    case 3:
    	        Rx2BufTmp = (0x40+0x20+0x10);         //ASCII, 7.O.1
    	    break;
    
    	    case 4:
    	        Rx2BufTmp = (0x40+0x20+0x08);         //ASCII, 7.E.2
    	    break;
    
    	    case 5:
    	        Rx2BufTmp = (0x40+0x20+0x10+0x08);    //ASCII, 7.O.2
    	    break;
    	    
    	    case 6:
    	    case 12:
    	        Rx2BufTmp = 0x00;                     //ASCII/RTU, 8.N.1
    	    break;
    	    
    	    default:    
    	    case 7:
    	    case 13:
    	        Rx2BufTmp = (0x08);                   //ASCII/RTU, 8.N.2
    	    break;
    	
    	    case 8:
    	    case 14:
    	        Rx2BufTmp = (0x20);                   //ASCII/RTU, 8.E.1
    	    break;
    	
    	    case 9:
    	    case 15:
    	        Rx2BufTmp = (0x20+0x10);              //ASCII/RTU, 8.O.1
    	    break;
    	
    	    case 10:
    	    case 16:
    	        Rx2BufTmp = (0x20+0x08);              //ASCII/RTU, 8.E.2
    	    break;
    	
    	    case 11:
    	    case 17:
    	        Rx2BufTmp = (0x20+0x10+0x08);         //ASCII/RTU, 8.O.2
    	    break;
    	}
    
    	if (pr[PROTOCOL2]<=11)
    	    ASC_RTU2 = 0;          //ASCII mode
    	else
    	    ASC_RTU2 = 1;          //RTU mode
    
    	/*            phi                                                       */
    	/* N = ------------------ * 10^6 - 1                                    */
    	/*     64 * 2^(2n-1) * B                                                */
    	/* Baud Ratio >= 9600 , n = 0                                           */
    	/* Baud Ratio == 4800 , n = 1                                           */
    	if (pr[BPS2]<96){
    	    SCI2.SMR.BYTE = Rx2BufTmp + 0x01;
    	    SCI2.BRR = ((3750+(pr[BPS2]>>1))/pr[BPS2])-1;		/* 4800bps, n=1, N=77 at 48MHz, Error=0.16%     */
    	}
    	else{
    	    SCI2.SMR.BYTE = Rx2BufTmp;        
    	    SCI2.BRR = ((15000+(pr[BPS2]>>1))/pr[BPS2])-1;    /* 9600bps, n=0, N=155 at 48MHz, Error=0.16%     */
	    }
    }
    
    else{    
  
        ASC_RTU2 = 1;                   // RTU
        SCI2.SMR.BYTE = (0x08);    // 8.N.2
        SCI2.BRR = 77;               // 19200, DINO, 03/03/2010
    }  

    for (i=0;i<5;i++)
        nop();

	if ((SCI2.SMR.BYTE&0x01) == 0x01)	// 4800 bps, dino, 11/12/2007
	    RTU_Silent2 = 81;		    	// RTU slient time = 8.1ms, count in 100us
	else{
	    if (SCI2.BRR<=25)			    // 57600~115200 bps
		    RTU_Silent2 = 10;		    // RTU slient time = 1ms, count in 100us
	    else if (SCI2.BRR<=38)		// 57600~38400 bps
		    RTU_Silent2 = 20;			// RTU slient time = 2ms
	    else if (SCI2.BRR<=77)		// 38400~19200 bps
		    RTU_Silent2 = 30;			// RTU slient time = 3ms
	    else if (SCI2.BRR<=103)		// 19200~14400 bps
		    RTU_Silent2 = 40;			// RTU slient time = 4ms
	    else if (SCI2.BRR<=155)		// 14400~9600 bps
		    RTU_Silent2 = 50;           // RTU slient time = 5ms
	}    
    //RTU_Silent2 = 40;
    //SCI2_ubTXIDalay = RTU_Silent2 / 3;
    
    /*=== Serial Control Register (SCR) ====================================*/
    /* Bit[7]         0     :TIE, Transmit Interrupt Enable                 */
    /* Bit[6]         1     :RIE, Receive Interrupt Enable                  */
    /* Bit[5]         0     :TE, Transmit Enable                            */
    /* Bit[4]         0     :RE, Receive Enable                             */
    /* Bit[3]         0     :MPIE, Multiprocessor Interrupt Enable          */
    /* Bit[2]         0     :TEIE, Transmit-End Interrupt Enable            */
    /* Bit[1-0]       00    :CKS1-0, Internal clock, SCK pin for I/O        */
    SCI2.SCR.BYTE |= 0x40;
  
	/*=== Serial Status Register (SSR) =====================================*/
    /* Bit[7]         0     :TDRE,Transmit Data Register Empty              */
    /* Bit[6]         0     :RDRF,Receive Data Register Full                */
    /* Bit[5]         0     :ORER,Overrun Error                             */
    /* Bit[4]         0     :FER,Framing Error                              */
    /* Bit[3]         0     :PER,Parity Error                               */
    /* Bit[2]         0     :TEND,Transmit End                              */
    /* Bit[1]         0     :MPB,Multiprocessor Bit                         */
    /* Bit[0]         0     :MPBT,Multiprocessor Bit Transfer               */
    SCI2.SSR.BYTE = 0x00;

    /**** Priority level of Keypad Communication in SCI2 ********************/
    /*=== Interrupt priority register L ====================================*/
    /* Bit[15-12]     0000  :SCI0  priority level                           */
    /* Bit[11-8]      0000  :SCI1  priority level                           */
    /* Bit[7-4]       0000  :SCI2  priority level=11                        */
    /* Bit[3-0]       0000  :Reserved                                       */
    
    //INTC.IPR16.BIT._SCI2 = 11;	//SCI - Remote Control

    IEN(SCI2, RXI2) = 0; /* Disable the interrupt */
    IEN(SCI2, TXI2) = 0; /* Disable the interrupt */
    IEN(SCI2, TEI2) = 0; /* Disable the interrupt */
    IPR(SCI2, ) = 11; /* set the priority level */
    IR(SCI2, RXI2) = 0; /* IR bit clear */
    IR(SCI2, TXI2) = 0; /* IR bit clear */
    IR(SCI2, TEI2) = 0; /* IR bit clear */

    SCI2.SCR.BYTE |= 0xF0;	// RE=1, TE=1
    
    Rx2BufTmp = SCI2.RDR;

    //Initial communication flag
    com2_status.ub &= 0x01;
    RTU_RXF2 = 1;

    
    //Initial counter
    RTU_CNT2 = 0;
    Rx2CNT = 0xFF;
    Tx2CNT = 0;
    SendCNT2 = 0;
    Com_WatchDog2 = 0;

    IEN(SCI2, RXI2) = 1; /* Disable the interrupt */
    IEN(SCI2, TXI2) = 0; /* Disable the interrupt */
    IEN(SCI2, TEI2) = 1; /* Disable the interrupt */

}
// ]

void InitSCI3(void){   //external communication port for RS485 

	UWORD Rx3BufTmp;
	UBYTE i;
    
    //==== I/O setting ====//
    //MPC.PG4PFS.BIT.PSEL = 10;
    //PORTG.PMR.BIT.B4 = 1; /* I/O port for peripheral functions */
    //PORTG.PDR.BIT.B4 = 0; /* RxD2 is input */

    //MPC.PG3PFS.BIT.PSEL = 10;
    //PORTG.PMR.BIT.B3 = 1; /* I/O port for peripheral functions */
    //PORTG.PDR.BIT.B3 = 1; /* TxD2 is output */

    //PORTG.PMR.BIT.B5 = 0;
    //PORTG.PDR.BIT.B5 = 1;

    MSTP(SCI3) = 0; /* Enable the module SCI3 */

	SCIDIR3Flag = 1;

    //=============== Serial Control Register (SCR) ====================//						
    // Bit[7]         0     :TIE, Transmit Interrupt Enable                
    // Bit[6]         0     :RIE, Receive Interrupt Enable                
    // Bit[5]         0     :TE, Transmit Enable                      
    // Bit[4]         0     :RE, Receive Enable                           
    // Bit[3]         0     :MPIE , Multi-Processor Interrupt Enable          
    // Bit[2]         0     :TEIE, Transmit End Interrupt Enable  							
    // Bit[1-0]     00   :CKE1-0, Internal clock, SCK pin for input pin  
    SCI3.SCR.BYTE = 0x00;	
	
	/*=== FIFO Control Register (SCFCR) ==================================*/
	/* Bit[15-8]	0	:Reserved									  	  */
    /* Bit[7-6]     00  :RTRG, Receive FIFO data trigger RDF, 00:1        */
    /* Bit[5-4]     11  :TTRG, Transmit FIFO data trigger TDFE, 11:0      */
    /* Bit[3]       0   :Reserved                                         */
    /* Bit[2]       0   :TFRST, Transmit FIFO Data Register Reset disable */
    /* Bit[1]       1   :RFRST, Receive FIFO Data Register Reset enable   */
    /* Bit[0]       0   :LOOP, Loop-Back Test           			      */
//    SCIF3.SCFCR.WORD = 0x00B6;	// Delete by DINO, 03/02/2010
	//SCI1.SCFCR.WORD = 0x0032;

    /*=== Serial Mode Register (SCSMR) =====================================*/
	/* Bit[15-8]	  0		:Reserved  									    */	
    /* Bit[7]         0     :C/A, Asynchronous mode                         */
    /* Bit[6]         0     :CHR, 0:8 bit data;  1:7-bit data               */
    /* Bit[5]         1     :PE, Parity bit check, 0: not added; 1:added    */
    /* Bit[4]         0     :O/E, 0:Even Parity; 1:Odd Parity               */
    /* Bit[3]         0     :STOP, 0:1 STOP bit;  1:2 STOP bit              */
    /* Bit[2]         0     :Reserved							            */
    /* Bit[1-0]       00    :CKS1-0, Clock select 1 & 0                     */
    SCI3.SSR.BYTE = 0x00;
    SCI3.SCMR.BYTE	= 0;	
	   //SCI0.SCR.BYTE	= 0;
	SCI3.SMR.BYTE	= 0;
	
	switch(pr[PROTOCOL3]){

	    case 0:
	        Rx3BufTmp = 0x40;                     //ASCII, 7.N.1
	    break;

	    case 1:
	        Rx3BufTmp = (0x40+0x08);              //ASCII, 7.N.2
	    break;

	    case 2:
	        Rx3BufTmp = (0x40+0x20);              //ASCII, 7.E.1
	    break;

	    case 3:
	        Rx3BufTmp = (0x40+0x20+0x10);         //ASCII, 7.O.1
	    break;

	    case 4:
	        Rx3BufTmp = (0x40+0x20+0x08);         //ASCII, 7.E.2
	    break;

	    case 5:
	        Rx3BufTmp = (0x40+0x20+0x10+0x08);    //ASCII, 7.O.2
	    break;
	    
	    case 6:
	    case 12:
	        Rx3BufTmp = 0x00;                     //ASCII/RTU, 8.N.1
	    break;
	    
	    default:    
	    case 7:
	    case 13:
	        Rx3BufTmp = (0x08);                   //ASCII/RTU, 8.N.2
	    break;
	
	    case 8:
	    case 14:
	        Rx3BufTmp = (0x20);                   //ASCII/RTU, 8.E.1
	    break;
	
	    case 9:
	    case 15:
	        Rx3BufTmp = (0x20+0x10);              //ASCII/RTU, 8.O.1
	    break;
	
	    case 10:
	    case 16:
	        Rx3BufTmp = (0x20+0x08);              //ASCII/RTU, 8.E.2
	    break;
	
	    case 11:
	    case 17:
	        Rx3BufTmp = (0x20+0x10+0x08);         //ASCII/RTU, 8.O.2
	    break;
	}

	if (pr[PROTOCOL3]<=11)
	    ASC_RTU3 = 0;          //ASCII mode
	else
	    ASC_RTU3 = 1;          //RTU mode

	/*            phi                                                       */
	/* N = ------------------ * 10^6 - 1                                    */
	/*     64 * 2^(2n-1) * B                                                */
	/* Baud Ratio >= 9600 , n = 0                                           */
	/* Baud Ratio == 4800 , n = 1                                           */
	if (pr[BPS3]<96){
	    SCI3.SMR.BYTE = Rx3BufTmp + 0x01;
	    SCI3.BRR = ((3750+(pr[BPS3]>>1))/pr[BPS3])-1;		/* 4800bps, n=1, N=77 at 48MHz, Error=0.16%     */
	}
	else{
	    SCI3.SMR.BYTE = Rx3BufTmp;        
	    SCI3.BRR = ((15000+(pr[BPS3]>>1))/pr[BPS3])-1;    /* 9600bps, n=0, N=155 at 48MHz, Error=0.16%     */
	}
	
	for (i=0;i<5;i++)
        nop();

	if ( (SCI3.SCR.BYTE&0x01)==0x01 )	// 4800 bps, dino, 11/12/2007
	    RTU_Silent3 = 81;		    	// RTU slient time = 8.1ms, count in 100us
	else{		//SCBRR value redefined, Sean, 01/25/2010
	    if (SCI3.BRR<=25)			    // 57600(25)~115200 bps
		    RTU_Silent3 = 10;		    // RTU slient time = 1ms, count in 100us
	    else if (SCI3.BRR<=38)		// 57600~38400(38) bps
		    RTU_Silent3 = 20;			// RTU slient time = 2ms
	    else if (SCI3.BRR<=77)		// 38400~19200(77) bps
		    RTU_Silent3 = 30;			// RTU slient time = 3ms
	    else if (SCI3.BRR<=103)		// 19200~14400(103) bps
		    RTU_Silent3 = 40;			// RTU slient time = 4ms
	    else if (SCI3.BRR<=155)		// 14400~9600(155) bps
		    RTU_Silent3 = 50;           // RTU slient time = 5ms
	}   
	//SCI1_ubTXIDalay = RTU_Silent1 / 3;

    //=============== Serial Control Register (SCR) ====================//						
    // Bit[7]         0     :TIE, Transmit Interrupt Enable                
    // Bit[6]         1     :RIE, Receive Interrupt Enable                
    // Bit[5]         0     :TE, Transmit Enable                      
    // Bit[4]         0     :RE, Receive Enable                           
    // Bit[3]         0     :MPIE , Multi-Processor Interrupt Enable          
    // Bit[2]         0     :TEIE, Transmit End Interrupt Enable  							
    // Bit[1-0]     00   :CKE1-0, Internal clock, SCK pin for input pin  
	 SCI3.SCR.BYTE |= 0x40;
  
    //============= Serial Status Register (SSR) ================//
	// Bit[7]	 	0	:ABCS, Asynchronous Basic Clock Select,0:16x clk   	
    // Bit[6-0]     0   :Reserved                                           	
	//SCIF3.SCSEMR.BYTE = 0x00;
    //SCI1.SCSMR.BYTE = 0x00;
	SCI3.SSR.BYTE = 0x00;
    /**** Priority level of Keypad Communication in SCIf3 ********************/
    /*=== Interrupt priority register 14 ====================================*/
    /* Bit[15-12]     0000  :Reserved         	                             */
    /* Bit[11-8]      0000  :Reserved        			                     */
    /* Bit[7-4]       0000  :Reserved        		                         */
    /* Bit[3-0]       1011  :SCIF3 priority level=11                         */    
    //INTC.IPR16.BIT._SCI1 = 11;    	//SCIF3,  //Sean, 01/26/2010, M3A-HS87 Test SCI Test

    IEN(SCI3, RXI3) = 0; /* Disable the interrupt */
    IEN(SCI3, TXI3) = 0; /* Disable the interrupt */
    IEN(SCI3, TEI3) = 0; /* Disable the interrupt */
    IPR(SCI3, ) = 11; /* set the priority level */
    IR(SCI3, RXI3) = 0; /* IR bit clear */
    IR(SCI3, TXI3) = 0; /* IR bit clear */
    IR(SCI3, TEI3) = 0; /* IR bit clear */
	
    SCI3.SCR.BYTE |= 0xF0;	//TE RE Enable	

    //i = SCI1.SCFRDR;   //Bernie mask    
    Rx3BufTmp = SCI3.RDR;
    //copy_status.ub &= 0x07;                 // Clear LCDTEXT, CopyChk, LCDKEY
        
    //Initial communication flag
    com3_status.ub &= 0x01;
    RTU_RXF3 = 1;

    //Initial counter
    RTU_CNT3 = 0;
    Rx3CNT = 0xFF;
    Tx3CNT = 0;
    SendCNT3 = 0;
    Com_WatchDog3 = 0;
    
    IEN(SCI3, RXI3) = 1; /* Disable the interrupt */
    IEN(SCI3, TXI3) = 0; /* Disable the interrupt */
    IEN(SCI3, TEI3) = 1; /* Disable the interrupt */
}

void InitSCI0(void)
{
    UBYTE i; 

    //==== I/O setting ====//
    MPC.P22PFS.BIT.PSEL = 10;
    PORT2.PMR.BIT.B2 = 1; /* I/O port for peripheral functions */
    PORT2.PDR.BIT.B2 = 0; /* RxD2 is input */

    MPC.P23PFS.BIT.PSEL = 10;
    PORT2.PMR.BIT.B3 = 1; /* I/O port for peripheral functions */
    PORT2.PDR.BIT.B3 = 1; /* TxD2 is output */

    PORT3.PMR.BIT.B0 = 0;
    PORT3.PDR.BIT.B0 = 1;
    
    MSTP(SCI0) = 0; /* Enable the module SCI0 */
    
	if (((pr[DEBUG_F1]&0x0018)==0x0008)||	// Bit 3: Enable all ICT test, Asynchronous Series Communication
		((pr[DEBUG_PG]&0x0020)!=0)||
		(pr[PG_TYPE]==SIN_HIPER)||
		(pr[PG_TYPE]==SIN_ENDAT)||
		(pr[PG_TYPE]==SIN_SIN)){ //[For IED PG-Card, Sampo, 02/25/2010]
		
		// [ Hiperface is Slave, Drive is Master, 05/19/2009
		if (((pr[DEBUG_PG]&0x0020)!=0)||
			(pr[PG_TYPE] == SIN_HIPER)||
			((pr[PG_TYPE]==SIN_ENDAT)&&((pr[DEBUG_F1]&0x0008)!=0x0008))||
			(pr[PG_TYPE]==SIN_SIN)){
			SCIDIR0Flag = 0;	// DIR=Transmit
		}
		else{
			SCIDIR0Flag = 1;	// DIR=Receive
		}
		// ]

		/*=== Serial Control Register (SCR) ====================================*/
		/* Bit[7]         0     :TIE, Transmit Interrupt Enable                 */
		/* Bit[6]         0     :RIE, Receive Interrupt Enable                  */
		/* Bit[5]         0     :TE, Transmit Enable                            */
		/* Bit[4]         0     :RE, Receive Enable                             */
		/* Bit[3]         0     :MPIE, Multiprocessor Interrupt Enable          */
		/* Bit[2]         0     :TEIE, Transmit-End Interrupt Enable            */
		/* Bit[1-0]       00    :CKS1-0, Internal clock, SCK pin for I/O        */
		SCI0.SCR.BYTE = 0x00;

		/*=== Serial Mode Register =============================================*/
		/* Bit[7]         0     :C/A, Asynchronous mode                         */
		/* Bit[6]         0     :CHR, 0:8 bit data;  1:7-bit data               */
		/* Bit[5]         0     :PE, Parity bit check, 0: not added; 1:added    */
		/* Bit[4]         0     :O/E, 0:Even Parity; 1:Odd Parity               */
		/* Bit[3]         1     :STOP, 0:1 STOP bit;  1:2 STOP bit              */
		/* Bit[2]         0     :MP, Multiprocessor function disabled           */
		/* Bit[1-0]       00    :CKS1-0, Clock select 1 & 0                     */

        SCI0.SSR.BYTE = 0x00;
        SCI0.SCMR.BYTE  = 0;    
           //SCI0.SCR.BYTE  = 0;
        SCI0.SMR.BYTE   = 0;

        
		ASC_RTU0= 1;				// RTU
		
		if ((pr[DEBUG_F1]&0x0018)==0x0008){	// ICT Test
			SCI0.SMR.BYTE = 0x20;		// 8.E.1, to match Hiperface, Modify by DINO, 10/08/2008
			SCI0.BRR = 155; 			// 9600
		}
		else{
			SCI0.SMR.BYTE = 0x00;		// 8.N.1, to match Hiperface, Modify by DINO, 10/08/2008
			SCI0.BRR = 47;			// 31250		
		}
		
		//SCI4.SCBRR = 77; 			// 19200	

		for (i=0;i<5;i++)
		    nop();

		RTU_Silent0 = 50;           // RTU slient time = 5ms

		/*=== Serial Control Register (SCR) ====================================*/
		/* Bit[7]         0     :TIE, Transmit Interrupt Enable                 */
		/* Bit[6]         1     :RIE, Receive Interrupt Enable                  */
		/* Bit[5]         0     :TE, Transmit Enable                            */
		/* Bit[4]         0     :RE, Receive Enable                             */
		/* Bit[3]         0     :MPIE, Multiprocessor Interrupt Enable          */
		/* Bit[2]         0     :TEIE, Transmit-End Interrupt Enable            */
		/* Bit[1-0]       00    :CKS1-0, Internal clock, SCK pin for I/O        */
		SCI0.SCR.BYTE |= 0x40;

		/*=== Serial Status Register (SSR) =====================================*/
		/* Bit[7]         0     :TDRE,Transmit Data Register Empty              */
		/* Bit[6]         0     :RDRF,Receive Data Register Full                */
		/* Bit[5]         0     :ORER,Overrun Error                             */
		/* Bit[4]         0     :FER,Framing Error                              */
		/* Bit[3]         0     :PER,Parity Error                               */
		/* Bit[2]         0     :TEND,Transmit End                              */
		/* Bit[1]         0     :MPB,Multiprocessor Bit                         */
		/* Bit[0]         0     :MPBT,Multiprocessor Bit Transfer               */
		SCI0.SSR.BYTE = 0x00;

		/**** Priority level of Keypad Communication in SCI1 ********************/
		/*=== Interrupt priority register 17 ====================================*/
		/* Bit[15-12]     0000  :SSU priority level                            */
		/* Bit[11-8]      1011  :SCI4 priority level                            */
		/* Bit[7-4]       0000  :ADI2 priority level=11                         */
		/* Bit[3-0]       0000  :Reserved 			                            */    
		//INTC.IPR17.BIT._SCI4 = 5;    	//SCI1 - ICT Communication    

        IEN(SCI0, RXI0) = 0; /* Disable the interrupt */
        IEN(SCI0, TXI0) = 0; /* Disable the interrupt */
        IEN(SCI0, TEI0) = 0; /* Disable the interrupt */
        IPR(SCI0, ) = 5; /* set the priority level */
        IR(SCI0, RXI0) = 0; /* IR bit clear */
        IR(SCI0, TXI0) = 0; /* IR bit clear */
        IR(SCI0, TEI0) = 0; /* IR bit clear */

		SCI0.SCR.BYTE |= 0xF0;	// RE=1, TE=1		

		//Initial communication flag
		com0_status.ub &= 0x01;
		RTU_RXF0 = 1;

		if ((pr[DEBUG_F1]&0x0018)==0x0008);
		else
			RX_OK0 = 1;		
		//Initial counter
		RTU_CNT0 = 0;
		Rx0CNT = 0xFF;	
		Tx0CNT = 0;
		SendCNT0 = 0;
		Com_WatchDog0 = 0;
		
		//Initial PGHSD1	// fix pghsd1 code, Sean, 06/01/2012
		hsd_ubTxTimCnt = 0;
		hsd_ubTxCnt1 = 0;
		hsd_ubRxTxSta = 0;
		hsd_ubRxCnt = 0;
		for(i=0; i<HSD_RX_MAX_CNT_CONST; i++){ 
			hsd_ubRxBuf[i]=0;
		}		
	}
    IEN(SCI0, RXI0) = 1; /* Enable the interrupt */
    IEN(SCI0, TXI0) = 0; /* Disable the interrupt */
    IEN(SCI0, TEI0) = 1; /* Enable the interrupt */
}           


void InitSCIERI(void){
    
    ICU.IER[IER_ICU_GROUP12].BIT.IEN_ICU_GROUP12 = 1;   
    ICU.IPR[IPR_ICU_GROUP12].BYTE = 11;
    ICU.IR[IR_ICU_GROUP12].BYTE = 0;
    
    ICU.GRP[GRP_SCI2_ERI2].LONG = 0;         
    ICU.GEN[GEN_SCI2_ERI2].LONG |= 0x04;

    ICU.GRP[GRP_SCI3_ERI3].LONG	= 0;	
	ICU.GEN[GEN_SCI3_ERI3].LONG	|= 0x08;
}


void InitPOE2_PROTECT(void)
{
    //==== I/O setting ====//
    //MPC.P70PFS.BIT.PSEL = 0x07;
    //MPC.P96PFS.BIT.PSEL = 0x07;
    //MPC.PB4PFS.BIT.PSEL = 0x07;
    //MPC.PE2PFS.BIT.PSEL = 0x07;
    //MPC.PE3PFS.BIT.PSEL = 0x07;

    //PORT7.PMR.BIT.B0 = 1 ;  // GF
    //PORT9.PMR.BIT.B6 = 1 ;  // OC
    //PORTB.PMR.BIT.B4 = 1 ;  // CC
    //PORTE.PMR.BIT.B2 = 1 ;  // CC
    //PORTE.PMR.BIT.B3 = 1 ;  // CC

    
    //PORT7.PDR.BIT.B0 = 0 ;  // GF
    //PORT9.PDR.BIT.B6 = 0 ;  // OC
    //PORTB.PDR.BIT.B4 = 0 ;  // CC
    //PORTE.PDR.BIT.B2 = 0 ;  // CC
    //PORTE.PDR.BIT.B3 = 0 ;  // CC

    /* Pphi = 48MHz, 16x Pphi/8 = 16x(48/8)MHz =>0.00000266s = 2.66 us        */ 
    /* Pphi = 48MHz, 16x Pphi/16 = 16x(48/16)MHz =>0.00000533s = 5.33 us      */ 
    /* Pphi = 48MHz, 16x Pphi/128 = 16x(48/128)MHz =>0.00004266s = 42.66 us   */ 

     IEN(POE, OEI1) = 0 ;  // Disable the interrupt
     IEN(POE, OEI2) = 0 ;  // Disable the interrupt
     IEN(POE, OEI3) = 0 ;  // Disable the interrupt  // V055D1R0_CC
     IEN(POE, OEI4) = 0 ;  // Disable the interrupt


    //=========== Input Level Control/Status Register 1 (ICSR1) ===========//
    // Bit[15-13]     0     :Reserved                                            
    // Bit[12]        0     :POE0F, POE0 Flag                                    
    // Bit[11-10]     --    :Reserved                                            
    // Bit[9]         0     :POE0E, POE0 High-impdeance Enable                   
    // Bit[8]         0     :PIE1, Port Interrupt Enable                         
    // Bit[7-6]       00    :Reserved                                            
    // Bit[5-4]       00    :Reserved                                            
    // Bit[3-2]       00    :Reserved                                            
    // Bit[1-0]       00    :POE0M, POE0 Mode = 00,falling edge                 
    
    //POE.ICSR1.WORD = 0x0000; 

    POE.ICSR1.WORD = 0x0100 ;  // RX62TH
    /*----- Output Level Control/Status Register 1 (OCSR1) ----------------------*/
    /* Bit[15]        0     :OSF1, Output Short Flag 1                           */
    /* Bit[14-10]     0     :Reserved                                            */
    /* Bit[9]         0     :OCE1, Output Short High-impedance Enable 1          */
    /* Bit[8]         0     :OIE1, Output Short Interrupt Enable 1               */
    /* Bit[7-0]       0     :Reserved                                            */
    POE.OCSR1.WORD = 0x0000;


    /*----- Active Level Setting Register 1 (ALR1) ------------------------------*/
    /* Bit[15-8]      0     :Reserved                                            */
    /* Bit[7]         0     :OLSEN, Active level setting enable                  */
    /* Bit[6]         0     :Reserved                                            */
    /* Bit[5]         0     :OLSG2B, MTIOC4D/GTIOC2B-A active level setting      */
    /* Bit[4]         0     :OLSG2A, MTIOC4B/GTIOC2A-A active level setting      */
    /* Bit[3]         0     :OLSG1B, MTIOC4C/GTIOC1B-A active level setting      */
    /* Bit[2]         0     :OLSG1A, MTIOC4A/GTIOC1A-A active level setting      */
    /* Bit[1]         0     :OLSG0B, MTIOC3D/GTIOC0B-A active level setting      */
    /* Bit[0]         0     :OLSG0A, MTIOC3B/GTIOC0A-A active level setting      */
    POE.ALR1.WORD = 0x0000;


    /*----- Input Level Control/Status Register 2 (ICSR2) -----------------------*/
    /* Bit[15-13]     -     :Reserved                                            */
    /* Bit[12]        0     :POE4F, POE4 Flag                                    */
    /* Bit[11-10]     --    :Reserved                                            */
    /* Bit[9]         0     :POE4E, POE4 High-impdeance Enable                   */
    /* Bit[8]         0     :PIE2, Port Interrupt Enable 2                       */
    /* Bit[7-6]       00    :Reserved                                            */
    /* Bit[5-4]       00    :Reserved                                            */
    /* Bit[3-2]       00    :Reserved                                            */
    /* Bit[1-0]       00    :POE4M, POE4 Mode = 00                               */
    //POE.ICSR2.WORD = 0x0000; 
    POE.ICSR2.WORD = 0x0100 ;  // RX62TH

    
    /*----- Output Level Control/Status Register 2 (OCSR2) ----------------------*/
    /* Bit[15]        0     :OSF2, Output Short Flag 2                           */
    /* Bit[14-10]     0     :Reserved                                            */
    /* Bit[9]         0     :OCE2, Output Short High-impedance Enable 2          */
    /* Bit[8]         0     :OIE2, Output Short Interrupt Enable 2               */
    /* Bit[7-0]       0     :Reserved                                            */
    POE.OCSR2.WORD = 0x0000;

    
    /*----- Input Level Control/Status Register 3 (ICSR3) -----------------------*/
    /* Bit[15-13]     0     :Reserved                                            */
    /* Bit[12]        0     :POE8F, POE8 Flag                                    */
    /* Bit[11-10]     0     :Reserved                                            */
    /* Bit[9]         0     :POE8E, POE8 High-impdeance Enable                   */
    /* Bit[8]         0     :PIE3, Port Interrupt Enable 3                       */
    /* Bit[7-2]       0     :Reserved                                            */
    /* Bit[1-0]       0     :POE8M, POE8 Mode = 00                               */   
    POE.ICSR3.WORD = 0x0100;  // RX62TH


    /*----- Input Level Control/Status Register 4 (ICSR4) -----------------------*/
    /* Bit[15-13]     0     :Reserved                                            */
    /* Bit[12]        0     :POE10F, POE10 Flag                                  */
    /* Bit[11-10]     0     :Reserved                                            */
    /* Bit[9]         0     :POE10E, POE10 High-impdeance Enable                 */
    /* Bit[8]         0     :PIE4, Port Interrupt Enable 4                       */
    /* Bit[7-2]       0     :Reserved                                            */
    /* Bit[1-0]       0     :POE10M, POE10 Mode = 00                             */
    //POE.ICSR4.WORD = 0x0300 ;
    POE.ICSR4.WORD = 0x0100;  //   // V051D0R0_Safety
    
    /*----- Input Level Control/Status Register 5 (ICSR5) -----------------------*/
    /* Bit[15-13]     0     :Reserved                                            */
    /* Bit[12]        0     :POE11F, POE11 Flag                                  */
    /* Bit[11-10]     0     :Reserved                                            */
    /* Bit[9]         0     :POE11E, POE11 High-impdeance Enable                 */
    /* Bit[8]         0     :PIE5, Port Interrupt Enable 5                       */
    /* Bit[7-2]       0     :Reserved                                            */
    /* Bit[1-0]       0     :POE11M, POE11 Mode = 00                             */
    POE.ICSR5.WORD = 0x0100;
  
    /*----- Software Port Output Enable Register (SPOER) -------------------------------*/
    /* Bit[7-5]       0     :Reserved                                                   */
    /* Bit[4]         0     :GPT23HIZ, GPT2 and GPT3 Output High-Impedance Enable       */
    /* Bit[3]         0     :GPT01HIZ, GPT0 and GPT1 Output High-Impedance Enable       */
    /* Bit[2]         0     :MTUCH0HIZ, MTU3 Channel 0 Output High-Impedance Enable     */
    /* Bit[1]         0     :MTUCH67SHIZ, MTU3 Channel 6,7 Output High-Impedance Enable */
    /* Bit[0]         0     :MTUCH34HIZ, MTU3 Channel 3,4 Output High-Impedance Enable  */
    POE.SPOER.BYTE = 0x00;

    /*----- Port Output Enable Control Register (POECR1) ------------------------*/
    /* Bit[7-4]       0     :Reserved                                            */
    /* Bit[0-3]       0     :MTU0PEA-DZE, MTU CH0A~D High-Impedance Enable       */
    POE.POECR1.BYTE = 0x00;


    /*----- Port Output Enable Control Register 2 (POECR2) ----------------------*/
    /* Bit[15-11]    0     :Reserved                                            */
    /* Bit[10]          1     :MTU3BDZE, MTU CH3BD High-Impedance Enable           */
    /* Bit[9]            1     :MTU4ACZE, MTU CH4AC High-Impedance Enable           */
    /* Bit[8]            1     :MTU4BDZE, MTU CH4BD High-Impedance Enable           */
    /* Bit[7-3]        0     :Reserved                                            */
    /* Bit[2]            0     :MTU6BDZE, MTU CH6BD High-Impedance Enable           */
    /* Bit[1]            0     :MTU7ACZE, MTU CH7AC High-Impedance Enable           */
    /* Bit[0]            0     :MTU7BDZE, MTU CH7BD High-Impedance Enable           */
    //POE.POECR2.WORD = 0x0700 ;   //NG1 setting
    POE.POECR2.WORD = 0x0707; 

    /*----- Port Output Enable Control Register 3 (POECR3) ----------------------*/
    /* Bit[15-10]     0     :Reserved                                            */
    /* Bit[9]            0     :GPT3ABZE, GPT CH3AB High-Impedance Enable           */
    /* Bit[8]            0     :GPT2ABZE, GPT CH2AB High-Impedance Enable           */
    /* Bit[7-2]        0     :Reserved                                            */
    /* Bit[1]            0     :GPT1ABZE, GPT CH1AB High-Impedance Enable           */
    /* Bit[0]            0     :GPT0ABZE, GPT CH0AB High-Impedance Enable           */
    POE.POECR3.WORD = 0x0303 ;  // RX62T


    /*----- Port Output Enable Control Register 4 (POECR4) ----------------------*/
    /* Bit[15-14]     0     :Reserved                                            */
    /* Bit[13]        0     :IC5ADDMT67ZE, MTU CH67 High-Impedance POE11F Add    */
    /* Bit[12]        0     :IC4ADDMT67ZE, MTU CH67 High-Impedance POE10F Add    */
    /* Bit[11]        0     :IC3ADDMT67ZE, MTU CH67 High-Impedance POE8F Add     */
    /* Bit[10]        1     :Reserved                                            */
    /* Bit[9]         0     :IC1ADDMT67ZE, MTU CH67 High-Impedance POE0F Add     */
    /* Bit[8]         0     :CMADDMT67ZE, MTU CH67 High-Impedance CFLAG Add      */
    /* Bit[7]        0       :Reserved                                            */
    /* Bit[6]        0      :IC6ADDMT34ZE,  MTU CH34 High-Impedance POE12F Add
       /* Bit[5]         0     :IC5ADDMT34ZE, MTU CH34 High-Impedance POE11F Add    */
    /* Bit[4]         0     :IC4ADDMT34ZE, MTU CH34 High-Impedance POE10F Add    */
    /* Bit[3]         0     :IC3ADDMT34ZE, MTU CH34 High-Impedance POE8F Add     */
    /* Bit[2]         0     :IC2ADDMT34ZE, MTU CH34 High-Impedance POE4F Add     */
    /* Bit[1]         1     :Reserved                                            */
    /* Bit[0]         0     :CMADDMT34ZE, MTU CH34 High-Impedance CFLAG Add      */
    POE.POECR4.WORD = 0x047E;  


    /*----- Port Output Enable Control Register 5 (POECR5) ----------------------*/
    /* Bit[15-6]      0     :Reserved                                            */
    /* Bit[5]         0     :IC5ADDMT0ZE, MTU CH0 High-Impedance POE11F Add      */
    /* Bit[4]         0     :IC4ADDMT0ZE, MTU CH0 High-Impedance POE10F Add      */
    /* Bit[3]         1     :Reserved                                            */
    /* Bit[2]         0     :IC2ADDMT0ZE, MTU CH0 High-Impedance POE4F Add       */
    /* Bit[1]         0     :IC1ADDMT0ZE, MTU CH0 High-Impedance POE0F Add       */
    /* Bit[0]         0     :CMADDMT0ZE,  MTU CH0 High-Impedance CFLAG Add       */
    POE.POECR5.WORD = 0x0008 ;  // RX62T

    /*----- Port Output Enable Control Register 6 (POECR6) ----------------------*/
    /* Bit[15-13]     001   :Reserved                                            */
    /* Bit[12]        0     :IC4ADDGPT23ZE, GPT CH23 High-Impedance POE10F Add   */
    /* Bit[11]        0     :IC3ADDGPT23ZE, GPT CH23 High-Impedance POE8F Add    */
    /* Bit[10]        0     :IC2ADDGPT23ZE, GPT CH23 High-Impedance POE4F Add    */
    /* Bit[9]         0     :IC1ADDGPT23ZE, GPT CH23 High-Impedance POE0F Add    */
    /* Bit[8]         0     :CMADDGPT23ZE, GPT CH23 High-Impedance CFLAG Add     */
    /* Bit[7-6]       0     :Reserved                                            */
    /* Bit[5]         0     :IC5ADDGPT01ZE, GPT CH01 High-Impedance POE11F Add   */
    /* Bit[4]         1     :Reserved                                            */
    /* Bit[3]         0     :IC3ADDGPT01ZE, GPT CH01 High-Impedance POE8F Add    */
    /* Bit[2]         0     :IC2ADDGPT01ZE, GPT CH01 High-Impedance POE4F Add    */
    /* Bit[1]         0     :IC1ADDGPT01ZE, GPT CH01 High-Impedance POE0F Add    */
    /* Bit[0]         0     :CMADDGPT01ZE,  GPT CH01 High-Impedance CFLAG Add    */
    POE.POECR6.WORD = 0x2010 ;  // RX62T


    /*----- Port Output Enable Control Register 7 (POECR7) ----------------------*/
    /* Bit[15-10]    0     :Reserved                                            */
    /* Bit[9]            0     :GPT7ABZE, GPT6ABZE High-Impedance Enable           */
    /* Bit[8]            0     :GPT6ABZE, GPT7ABZE High-Impedance Enable           */
    /* Bit[7-0]        0     :Reserved        */
    POE.POECR7.WORD = 0x0000; 


    /**** Priority level of POE interrupt ***********************************/
    /*=== Interrupt priority register F (OEI1 & OEI2) ======================*/
    /* Bit[15-12]     1011  :_MTU24G priority level                         */
    /* Bit[11-8]      0000  :_MTU24C priority level = 11                    */
    /* Bit[7-4]       1011  :_MTU25 priority level                          */
    /* Bit[3-0]       1011  :_POE priority level=14                         */     
    //INTC.IPR11.BIT._POE2 = 14;		//POE - Hardware Protect, DINO, 03/01/2010
    //IPR(POE, OEI1) = 14 ;  // set the priority level to 15
    //IR(POE,OEI1) = 0 ;  // IR bit clear  
    //IEN(POE, OEI1) = 1 ;  // enable the interrupt



    /*=== Interrupt priority register F (OEI3) =============================*/
    /* Bit[15-12]     0000  :_MTU5S priority level                          */
    /* Bit[11-8]      1110  :_OIE3 priority level = 14                      */
    /* Bit[7-4]       0011  :_IIC3 priority level = 3                       */
    /* Bit[3-0]       ----  :_                                              */     
    //INTC.IPR13.BIT._POE2 = 14;		//POE - Hardware Protect, DINO, 03/01/2010
    IR(POE,OEI1) = 0 ;  // IR bit clear
    IPR(POE, OEI1) = 14 ;  // set the priority level to 14
    IEN(POE, OEI1) = 1 ;  // enable the interrupt
    
    IR(POE,OEI2) = 0 ;  // IR bit clear
    IPR(POE, OEI2) = 14 ;  // set the priority level to 14
    IEN(POE, OEI2) = 1 ;  // enable the interrupt

    IR(POE,OEI3) = 0 ;  // IR bit clear
    IPR(POE, OEI3) = 14 ;  // set the priority level to 14
    IEN(POE, OEI3) = 1 ;  // enable the interrupt
    
    IR(POE,OEI4) = 0 ;  // IR bit clear
    IPR(POE, OEI4) = 14 ;  // set the priority level to 14
    IEN(POE, OEI4) = 1 ;  // enable the interrupt



}

/* RCAN-ET register initialize, Sean, 03/30/2010 */
void InitCAN(void)
{
    //UWORD can_tmo_cnt = MAX_CAN_SW_DELAY;
    UBYTE i,j;
    UWORD wait;

    //I/O setting
    PORTB.PDR.BIT.B6 = 0;
    PORTB.PDR.BIT.B5 = 1;
    
    PORTB.PMR.BIT.B6 = 1;
    PORTB.PMR.BIT.B5 = 1;
    
    MPC.PB6PFS.BYTE = 0x10;
    MPC.PB5PFS.BYTE = 0x10;
    
    
    MSTP(CAN1) = 0;   // exit module stop state 
    
        
    CAN1.CTLR.BIT.SLPM = 0;  // Set to, and ensure that RCAN exits, Sleep mode.
    wait = 0;
    while ((CAN1.STR.BIT.SLPST)/* && DEC_CHK_CAN_SW_TMR*/){
        wait++;
        if(wait==65535){
            CAN_uwErrNo = 0x01;
            Error = CAN_ERR; 
            RCAN_ubErr4Rgst = CAN1.EIFR.BYTE;
  	        break;
        }
    }
    
    CAN1.CTLR.BIT.CANM = 1;  // Reset mode
    wait = 0;
    while ((!CAN1.STR.BIT.RSTST) /*&& DEC_CHK_CAN_SW_TMR*/){
        wait++;
        if(wait==65535){
            CAN_uwErrNo = 0x02;
            Error = CAN_ERR;
            RCAN_ubErr4Rgst = CAN1.EIFR.BYTE;
  	        break;
        }
    }

   
    CAN1.CTLR.BIT.BOM  = 0;     // BOM: Bus Off recovery mode acc. to IEC11898-1 
    CAN1.CTLR.BIT.MBM  = 0;     // MBM: Select normal mailbox mode. 
    
#if 1
	CAN1.CTLR.BIT.IDFM = 0;     // IDFM: Select standard ID mode. 
#else
	CAN1.CTLR.BIT.IDFM = 2; 	// IDFM: Select mixed ID mode. [supt CAN2.0b, Aevin, 2018/02/06]
#endif
	CAN1.CTLR.BIT.MLM  = 0;     // MLM: Message Lost Mode Select*2	
    CAN1.CTLR.BIT.TPM  = 0;	    // TPM: ID priority mode. 
    CAN1.CTLR.BIT.TSRC = 0;     // TSRC: Only to be set to 1 in operation mode 	
    CAN1.CTLR.BIT.TSPS = 3;     // TSPS: Update every 8 bit times 


//===============   Bit Rate Setting ===============//
    if((pr[DEBUG_F1] & 0x0002)==0x0002){       //for ICT
        CAN1.BCR.BIT.BRP = 15;       //set to 125k
        CAN1.BCR.BIT.TSEG1 = 14;
        CAN1.BCR.BIT.TSEG2 = 7;
        CAN1.BCR.BIT.SJW = 1;    
    }
    else{
        switch(pr[CAN_BURD]){
            case 0:  //1Mbps
                CAN1.BCR.BIT.BRP = 3;            //set to 1000k
                CAN1.BCR.BIT.TSEG1 = 7;
                CAN1.BCR.BIT.TSEG2 = 2;
                CAN1.BCR.BIT.SJW = 1;                     
                break;
            case 1:  //500kbps
      	        CAN1.BCR.BIT.BRP = 3;            //set to 500k
                CAN1.BCR.BIT.TSEG1 = 14;
                CAN1.BCR.BIT.TSEG2 = 7;
                CAN1.BCR.BIT.SJW = 1;                     
                break;
            case 2:  //250kbps
      	        CAN1.BCR.BIT.BRP = 7;            //set to 250k
                CAN1.BCR.BIT.TSEG1 = 14;
                CAN1.BCR.BIT.TSEG2 = 7;
                CAN1.BCR.BIT.SJW = 1;                     
                break;
            case 3:  //125kbps
      	        CAN1.BCR.BIT.BRP = 15;       //set to 125k
                CAN1.BCR.BIT.TSEG1 = 14;
                CAN1.BCR.BIT.TSEG2 = 7;
                CAN1.BCR.BIT.SJW = 1;                      
                break;
                
            default:
                break;
        }	
    }
    //CAN1.BCR.BIT.BRP = 19;       //set to 100k
    //CAN1.BCR.BIT.TSEG1 = 14;
    //CAN1.BCR.BIT.TSEG2 = 7;
    //CAN1.BCR.BIT.SJW = 1;


    CAN1.MKIVLR.LONG = 0xFFFFFFFF;   // Mask invalid for all mailboxes by default. 

    IR(CAN1, TXM1) = 0; // IR bit clear 
    IR(CAN1, RXM1) = 0; //IR bit clear 

    IEN(CAN1, TXM1) = 1;            // Interrupt Enable
    IPR(CAN1, TXM1) = 9;//CAN1_INT_LVL;	//priority  //[CAN bus problem, Bernie, 2016/10/28]
	
	// Configure CAN Rx interrupt. //
    IEN(CAN1, RXM1) = 1;
	IPR(CAN1, RXM1) = 9;//CAN1_INT_LVL;             //[CAN bus problem, Bernie, 2016/10/28]


    for (i = 0; i <= 32; i++){
	    CAN1.MB[i].ID.LONG = 0x00;
		CAN1.MB[i].DLC = 0x0008;
		for (j = 0; j < 8; j++)
		    CAN1.MB[i].DATA[j] = 0x00;
		for (j = 0; j < 2; j++)
		    CAN1.MB[i].TS = 0x0000;			
	}	
    
    CAN1.CTLR.BIT.CANM = 0;  // OPERATION mode

    wait = 0;
    while ((CAN1.STR.BIT.RSTST) ){
        wait++;
        if(wait==65535){
            CAN_uwErrNo = 0x03;
            Error = CAN_ERR; 
  	        break;
        }
    }

	CAN1.CTLR.BIT.TSRC = 1; // Time Stamp Counter reset. Set the TSRC bit to 1 in CAN Operation mode.
	wait = 0;
	while ((CAN1.CTLR.BIT.TSRC)){
        wait++;
        if(wait==65535){
            CAN_uwErrNo = 0x04;
            Error = CAN_ERR;
            RCAN_ubErr4Rgst = CAN1.EIFR.BYTE;
  	        break;
        }
    }
    
    //CAN1.EIER.BYTE = 0xFF;
    CAN1.EIFR.BYTE = 0x00;
    CAN1.ECSR.BYTE = 0x00;

    CAN1.MIER.LONG = 0xFFFFFFFF;         //Set mask registers

    //CAN1.CTLR.BIT.MLM = 1;

    //===========  Mail Box setting ===========//
    for(i = 0; i<=32 ;i++){
        CAN1.MCTL[i].BYTE = 0x00;
        wait = 0;
	    while ((CAN1.MCTL[i].BYTE)!= 0){
			CAN1.MCTL[i].BYTE = 0x00;//	GFC CANF issue, James, 2020/08/03
            wait++;
            if(wait==65535){
                CAN_uwErrNo = 0x05;
                Error = CAN_ERR;
                RCAN_ubErr4Rgst = CAN1.EIFR.BYTE;
     	        break;
            }
        }
    }
    if((pr[DEBUG_F1]&0x0002)==0x0002){   //[Modify ICT Testing Method,Lyabryan,2019/07/29]   // for ICT setting
        CAN1.MIER.LONG = 0x0000003F;
        CAN1.MCTL[0].BYTE = 0x80;      //Transmit Mailbox Request 
        
        //CAN1.MKR[0].LONG = 0x00000000;
        CAN1.MB[0].ID.BIT.IDE = 0;
        CAN1.MB[0].ID.BIT.SID = 0x702;
        CAN1.MB[0].DLC = 0x08;
    
        CAN1.MCTL[2].BYTE = 0x80;      //Transmit Mailbox Request 
        
        //CAN1.MKR[2].LONG = 0x00000000;
        CAN1.MB[2].ID.BIT.IDE = 0;
        CAN1.MB[2].ID.BIT.SID = 0x70D;
        CAN1.MB[2].DLC = 0x08;
    
        CAN1.MCTL[4].BYTE = 0x80;      //Transmit Mailbox Request 
        
        //CAN1.MKR[4].LONG = 0x00000000;
        CAN1.MB[4].ID.BIT.IDE = 0;
        CAN1.MB[4].ID.BIT.SID = 0x70F;
        CAN1.MB[4].DLC = 0x08;
    
    
        CAN1.MCTL[1].BYTE = 0x40;      //Receive Mailbox Request 
    
       // CAN1.MKR[1].LONG = 0x00000000;
        CAN1.MB[1].ID.BIT.IDE = 0;
        CAN1.MB[1].ID.BIT.SID = 0x701;
        CAN1.MB[1].DLC = 0x08;
    
        CAN1.MCTL[3].BYTE = 0x40;      //Receive Mailbox Request 
    
        //CAN1.MKR[3].LONG = 0x00000000;
        CAN1.MB[3].ID.BIT.IDE = 0;
        CAN1.MB[3].ID.BIT.SID = 0x70C;
        CAN1.MB[3].DLC = 0x08;
    
    
        CAN1.MCTL[5].BYTE = 0x40;      //Receive Mailbox Request 
        
        //CAN1.MKR[5].LONG = 0x00000000;
        CAN1.MB[5].ID.BIT.IDE = 0;
        CAN1.MB[5].ID.BIT.SID = 0x70E;
        CAN1.MB[5].DLC = 0x08;
    }
    else{
//#if Artemis_ENABLE
            //[btArtemisEnable at pr[00-02]=200, Special.Kung, 2022/12/02]
            if(btArtemisEnable)
            {
                CAN1.MIER.LONG = 0x000007FF;//Artemis DLC modify , James, 2020/06/02
            }
            else
            {
                CAN1.MIER.LONG = 0x000003FF;
            }
//#else
		//CAN1.MIER.LONG = 0x000003FF;
//#endif
#if 1  //[supt CAN2.0b, Aevin, 2018/02/06]
        //========= TX Mail Box =========//
        
        CAN1.MCTL[0].BYTE = 0x00;      //Transmit Mailbox Request for PDO
        
        //CAN1.MKR[0].LONG = 0x00000000;
        CAN1.MB[0].ID.BIT.IDE = 0;
        CAN1.MB[0].ID.BIT.SID = 0x002;
        CAN1.MB[0].DLC = 0x08;
    
        CAN1.MCTL[2].BYTE = 0x00;      //Transmit Mailbox Request for SDO
        
        //CAN1.MKR[2].LONG = 0x00000000;
        CAN1.MB[2].ID.BIT.IDE = 0;
        CAN1.MB[2].ID.BIT.SID = 0x050;
        CAN1.MB[2].DLC = 0x08;
    
        CAN1.MCTL[4].BYTE = 0x00;      //Transmit Mailbox Request for SDO 
        
        //CAN1.MKR[4].LONG = 0x00000000;
        CAN1.MB[4].ID.BIT.IDE = 0;
        CAN1.MB[4].ID.BIT.SID = 0x051;
        CAN1.MB[4].DLC = 0x08;

        CAN1.MCTL[6].BYTE = 0x00;      //Transmit Mailbox Request for SDO
        
        //CAN1.MKR[6].LONG = 0x00000000;
        CAN1.MB[6].ID.BIT.IDE = 0;
        CAN1.MB[6].ID.BIT.SID = 0x052;
        CAN1.MB[6].DLC = 0x08;

        //Gfc DLC modify , Henry, 2018/05/23
        CAN1.MCTL[8].BYTE = 0x00;      //Transmit Mailbox Request for PDO
        //CAN1.MKR[8].LONG = 0x00000000;
        CAN1.MB[8].ID.BIT.IDE = 0;
        CAN1.MB[8].ID.BIT.SID = 0x004;
        CAN1.MB[8].DLC = 0x08;
//#if Artemis_ENABLE
        //[btArtemisEnable at pr[00-02]=200, Special.Kung, 2022/12/02]
        if(btArtemisEnable)
        {
            //Artemis DLC modify , James, 2020/06/02
            CAN1.MCTL[10].BYTE = 0x00;      //Transmit Mailbox Request for PDO
            //CAN1.MKR[10].LONG = 0x00000000;
            CAN1.MB[10].ID.BIT.IDE = 0;
            CAN1.MB[10].ID.BIT.SID = 0x005;
            CAN1.MB[10].DLC = 0x08;
        }
//#endif    
        //========= RX Mail Box =========//
       
        CAN1.MCTL[1].BYTE = 0x40;      //Receive Mailbox Request  for PDO
    
        //CAN1.MKR[0].LONG = 0x00000000;
        CAN1.MB[1].ID.BIT.IDE = 0;
        CAN1.MB[1].ID.BIT.SID = 0x001;
        CAN1.MB[1].DLC = 0x08;
    
        CAN1.MCTL[3].BYTE = 0x40;      //Receive Mailbox Request for SDO
    
        //CAN1.MKR[3].LONG = 0x00000000;
        CAN1.MB[3].ID.BIT.IDE = 0;
        CAN1.MB[3].ID.BIT.SID = 0x060;
        CAN1.MB[3].DLC = 0x08;
    
    
        CAN1.MCTL[5].BYTE = 0x40;      //Receive Mailbox Request for SDO
        
        //CAN1.MKR[5].LONG = 0x00000000;
        //CAN1.MKR[5].BIT.SID = 0x000;
        CAN1.MB[5].ID.BIT.IDE = 0;
        CAN1.MB[5].ID.BIT.SID = 0x061;
        CAN1.MB[5].DLC = 0x08;

        CAN1.MCTL[7].BYTE = 0x40;      //Receive Mailbox Request for SDO
        
        //CAN1.MKR[7].LONG = 0x00000000;
        //CAN1.MKR[7].BIT.SID = 0x000;
        CAN1.MB[7].ID.BIT.IDE = 0;
        CAN1.MB[7].ID.BIT.SID = 0x062;
        CAN1.MB[7].DLC = 0x08;
#else
		//[CAN2.0b MB setting, Aevin, 2018/02/06]
		//      SID(2.0a)   | SID+EID(2.0b) (left shift 18 bits) 
		//      0x02        | 0x0080000
		//      0x50        | 0x1400000
		//      0x51        | 0x1440000
		//      0x52        | 0x1480000
        //      0x04        | 0x0100000
		//========= TX Mail Box =========//
        CAN1.MCTL[0].BYTE = 0x00;      //Transmit Mailbox Request for PDO
		CAN1.MB[0].ID.BIT.IDE = 1;
        CAN1.MB[0].ID.BIT.SID = 0x002;  //standard ID
		CAN1.MB[0].ID.BIT.EID = 0x00000;//extended ID
		CAN1.MB[0].DLC = 0x08;
    
        CAN1.MCTL[2].BYTE = 0x00;      //Transmit Mailbox Request for SDO
        CAN1.MB[2].ID.BIT.IDE = 1;
        CAN1.MB[2].ID.BIT.SID = 0x050;
		CAN1.MB[2].ID.BIT.EID = 0x00000;//extended ID
		CAN1.MB[2].DLC = 0x08;
    
        CAN1.MCTL[4].BYTE = 0x00;      //Transmit Mailbox Request for SDO 
        
        CAN1.MB[4].ID.BIT.IDE = 1;
        CAN1.MB[4].ID.BIT.SID = 0x051;
		CAN1.MB[4].ID.BIT.EID = 0x00000;//extended ID
		CAN1.MB[4].DLC = 0x08;

        CAN1.MCTL[6].BYTE = 0x00;      //Transmit Mailbox Request for SDO
        CAN1.MB[6].ID.BIT.IDE = 1;
        CAN1.MB[6].ID.BIT.SID = 0x052;
		CAN1.MB[6].ID.BIT.EID = 0x00000;//extended ID
        CAN1.MB[6].DLC = 0x08;

        //Gfc DLC modify , Henry, 2018/05/23
        CAN1.MCTL[8].BYTE = 0x00;      //Transmit Mailbox Request for PDO
        CAN1.MB[8].ID.BIT.IDE = 0;
        CAN1.MB[8].ID.BIT.SID = 0x004;
        CAN1.MB[8].ID.BIT.EID = 0x00000;//extended ID
        CAN1.MB[8].DLC = 0x08;

		//      SID(2.0a)   | SID+EID(2.0b) (left shift 18 bits) 
		//      0x01        | 0x0040000
		//      0x60        | 0x1800000
		//      0x61        | 0x1840000
		//      0x62        | 0x1880000    
        //========= RX Mail Box =========//
       
        CAN1.MCTL[1].BYTE = 0x40;      //Receive Mailbox Request  for PDO
        CAN1.MB[1].ID.BIT.IDE = 1;
        CAN1.MB[1].ID.BIT.SID = 0x001;
		CAN1.MB[1].ID.BIT.EID = 0x00000;//extended ID
        CAN1.MB[1].DLC = 0x08;
    
        CAN1.MCTL[3].BYTE = 0x40;      //Receive Mailbox Request for SDO
        CAN1.MB[3].ID.BIT.IDE = 1;
        CAN1.MB[3].ID.BIT.SID = 0x060;
		CAN1.MB[3].ID.BIT.EID = 0x00000;//extended ID
        CAN1.MB[3].DLC = 0x08;
    
    
        CAN1.MCTL[5].BYTE = 0x40;      //Receive Mailbox Request for SDO
        CAN1.MB[5].ID.BIT.IDE = 1;
        CAN1.MB[5].ID.BIT.SID = 0x061;
		CAN1.MB[5].ID.BIT.EID = 0x00000;//extended ID
        CAN1.MB[5].DLC = 0x08;

        CAN1.MCTL[7].BYTE = 0x40;      //Receive Mailbox Request for SDO
        CAN1.MB[7].ID.BIT.IDE = 1;
        CAN1.MB[7].ID.BIT.SID = 0x062;
		CAN1.MB[7].ID.BIT.EID = 0x00000;//extended ID
        CAN1.MB[7].DLC = 0x08;
#endif
    }
    //=========== Interrupt enable ===========//

    ICU.IPR[IER_ICU_GROUP0].BIT.IPR = 0x03;
        
    //CAN1.EIER.BYTE = 0xFF; /* enable all error interrupts within peripheral */
 

}

/* USB initialize, S/W FIFO + Interrupt Setting,Sean, 01/25/2010 */
void InitUSB(void){
	
	/* Pin Function Select */
	//PFC.PBCRL3.WORD |= 0x0050;	/*	PB9:USBPND				*/
	//PFC.PBCRL3.WORD &= 0xf0ff;	/*  PB10:USBEN(IO)			*/
	//PFC.PBIORL.WORD = 0x0600;		/*	PB9/10:Outupt			*/
#if 0   //Sean, 02/22/2010
	/* USB S/W FIFO preparation */
	unsigned long		cnt;
	BulkOutEnableFlag  = 1;
	SerialInEnableFlag = 1;
	/* Control Transfer SetupUp Buffer Data                 		*/
	/* size = 8byte													*/
	contCMDGPtr.writePtr     = &ep0PacketGVar.byteVal[0];			/* gUsbControlBuff[ 0 ]		*/
	contCMDGPtr.readPtr      = &ep0PacketGVar.byteVal[0];
	contCMDGPtr.beginAriaPtr = &ep0PacketGVar.byteVal[0];
	contCMDGPtr.endAriaPtr   = &ep0PacketGVar.byteVal[7];			/* gUsbControlBuff[ 7 ]		*/
	/* Buffer data              */
	/* Endpoint 0               */
	/* size = 64byte			*/
	dataBuffGPtr[ 0 ].readPtr      = &controlBeginGVar;				/* gUsbControlBuff[ 8 ]		*/
	dataBuffGPtr[ 0 ].writePtr     = &controlBeginGVar;
	dataBuffGPtr[ 0 ].beginAriaPtr = &controlBeginGVar;
	dataBuffGPtr[ 0 ].endAriaPtr   = &controlEndGVar;				/* gUsbControlBuff[ 71 ]	*/
	/* BulkOut Transfer         */
	/* Endpoint BULKOUT_IDX = 3 */
	/* size = 512byte			*/
	dataBuffGPtr[ BULKOUT_IDX ].readPtr      = &bulkoutBeginGVar;	/* gUsbBulkOutBufff[ 0 ]	*/
	dataBuffGPtr[ BULKOUT_IDX ].writePtr     = &bulkoutBeginGVar;
	dataBuffGPtr[ BULKOUT_IDX ].beginAriaPtr = &bulkoutBeginGVar;
	dataBuffGPtr[ BULKOUT_IDX ].endAriaPtr   = &bulkoutEndGVar;		/* gUsbBulkOutBufff[ 512 - 1 ]	*/
	/* BulkIn Transfer          */
	/* Endpoint BULKIN_IDX = 4 	*/
	/* size = 512byte			*/
	dataBuffGPtr[ BULKIN_IDX ].readPtr      = &bulkinBeginGVar;		/* gUsbBulkInBufff[ 0 ]		*/
	dataBuffGPtr[ BULKIN_IDX ].writePtr     = &bulkinBeginGVar;
	dataBuffGPtr[ BULKIN_IDX ].beginAriaPtr = &bulkinBeginGVar;
	dataBuffGPtr[ BULKIN_IDX ].endAriaPtr   = &bulkinEndGVar;		/* gUsbBulkInBufff[ 512 - 1 ]	*/
	/* clear FIFO data */
	for( cnt = 0; cnt < (USB_EP0_BUFF_SIZE / sizeof(unsigned long)); cnt++ ){
		gUsbControlBuff[ cnt ] = 0;
	}
	for( cnt = 0; cnt < (USB_BULK_BUFF_SIZE / sizeof(unsigned long)); cnt++ ){
		gUsbBulkInBufff[ cnt ]  = 0;
		gUsbBulkOutBufff[ cnt ] = 0;
	}	
	/* USB Interrupt Register Setting   */
	SetUsbModule( 0x00000000, 0 );		/*	Set:USB			*/
	set_cr(get_cr() & 0xEFFFFF0F);		/*	Set CR			*/
	/* Enable pullup D+					*/
	PB.DR.WORD.L |= 0x0400;				/*	using PB10 port for pull up D+ 	*/	
#else
//	usb_init();	//Sean, 02/22/2010
#endif	
	/* INTC */
	//INTC.IPR18.BIT._USB = 13;	/*	USBF:13 */  // USB FUNCTION BERNIE
}


/* IIC3 Initialize */	//Sean, 01/25/2010
void InitIIC(){
	IIC_Init();	//Sean, 01/25/2010		
	//INTC.IPR13.BIT._IIC3 = 3;		/*  IIC:3 */	
									//no int used now, Sean, 01/25/2010	

#if 0
    IR(SCI3, EEI1) = 0; /* IR bit clear */
    IR(SCI3, RXI1) = 0; /* IR bit clear */
    IR(SCI3, TXI1) = 0; /* IR bit clear */
    IR(SCI3, TEI1) = 0; /* IR bit clear */
    IPR(RIIC1, ) = 3; /* set the priority level */
    IEN(RIIC1, EEI1) = 0; /* Disable the interrupt */
    IEN(RIIC1, RXI1) = 0; /* Disable the interrupt */
    IEN(RIIC1, TXI1) = 0; /* Disable the interrupt */
    IEN(RIIC1, TEI1) = 0; /* Disable the interrupt */
#endif
#if 0
    IPR(RIIC1,EEI1)	= 3;	// EEI1 interrupt level
	IPR(RIIC1,RXI1)	= 3;	// RXI1 interrupt level
	IPR(RIIC1,TXI1)	= 3;	// TXI1 interrupt level
	IPR(RIIC1,TEI1)	= 3;	// TEI1 interrupt level
//----------------------------------------------------------------------------//
	IR(RIIC1,EEI1)	= 0;	// EEI1 clear interrupt flag
	IR(RIIC1,RXI1)	= 0;	// RXI1 clear interrupt flag
	IR(RIIC1,TXI1)	= 0;	// TXI1 clear interrupt flag
	IR(RIIC1,TEI1)	= 0;	// TEI1 clear interrupt flag
//----------------------------------------------------------------------------//
	IEN(RIIC1,EEI1)	= 1;	// EEI1 interrupt enable 
	IEN(RIIC1,RXI1)	= 1;	// RXI1 interrupt enable 
	IEN(RIIC1,TXI1)	= 1;	// TXI1 interrupt enable 
	IEN(RIIC1,TEI1)	= 1;	// TEI1 interrupt enable 
//----------------------------------------------------------------------------//
#endif
	//RIIC1.ICCR1.BIT.ICE = 1;// RIIC1 Bus Interface Enable 

}

void InitWDT(void){		//WDT, Sean, 05/07/2010
/*	WDT.WRITE.WTCSR = 0xa55f;		//wdt,off,~87ms
	WDT.WRITE.WRCSR = 0x5a5f;		//reset, power-on reset
	if (WDT.RD.WRCSR.BIT.WOVF ==1)	//overflow
		WDT.WRITE.WRCSR = 0xa500;	//clear WOVF
	WDT.WRITE.WTCNT = 0x5a00;		//reset WTCNT	
*/

    // Enable the WDT (watchdog timer)
    // 48MHz PCLK -> 43.69 ms Timeout
    WDT.WDTCR.WORD = 0x33f3; 
    // Cause a non-maskable interrupt (not a reset) when the watchdog times
    // out.  Generating an interrupt allows fault data to be logged when a
    // watchdog occurs.  The non-maskable interrupt handler then sits in a loop 
    // which should cause the IWDT to time out and the processor to reset.
    WDT.WDTRCR.BYTE = 0x00;
    
    ICU.NMIER.BIT.WDTEN = 1;  //This bit enables the WDT underflow/refresh error interrupt.

}


void HW_Test(void)
{
    /* Protect I/O Test */

    if (OC_CHK==0)
	    Error = Hd1_ERR;
    else if (OV_CHK==0)
    	Error = Hd2_ERR;
    else if (GFF_CHK==0){
	    if ((pr[PROTBIT]&0x0003)==0x0000)	// Bit 0,1: Control GFF Check by POE
	        Error = Hd3_ERR;
    }  	
    else if (CC_CHK==0)
	    Error = Hd0_ERR;
    else {
		if ((pr[PROTBIT]&0x0200)==0x0000){	// Bit 9: disable cdx_ERR
		    /*------------------------ Modify by dino -------------------------
		    -- where 36045 = 2048*1.1*(2^6)/4, 29491 = 2048*0.9*(2^6)/4      --
		    -- To divide 4 is caued by the total amount is bigger than 65535 --
		    -----------------------------------------------------------------*/
		    if ((AD_uwIA0>36045)||(AD_uwIA0<29491))		
		    	Error = cd1_ERR;
		    else if ((AD_uwIB0>36045)||(AD_uwIB0<29491))
		    	Error = cd2_ERR;
		    else if ((AD_uwIC0>36045)||(AD_uwIC0<29491))
		    	Error = cd3_ERR;
    	    else if (IrmsAD1 >= OCS)  /* dino, 04/17/2007 */
            	Error = cd0_ERR;
    	}
    }

}

void SYSCLK_Init(void)
{
  // [ External Crystal is 12MHz
  /*
  ICLK = 12 * 8 = 96 MHz
  BCLK = 12 * 8 = 96 MHz
  PCLK = 12 * 4 = 48 MHz
  */
  // ]
  UWORD i;


  SYSTEM.PRCR.WORD  = 0x0A503;  // Protect Register Off

  //---stop clock---//
//  SYSTEM.SOSCCR.BYTE = 0x01; // stop sub-clock
//  while ( SYSTEM.SOSCCR.BYTE != 0x01); // check result

//  SYSTEM.HOCOCR.BYTE = 0x01; // b0=1: HOCOis stopped
//  SYSTEM.HOCOPCR.BYTE = 0x01; /* HOCO power supply off */

  //--- configure ---//
  SYSTEM.MOSCWTCR.BYTE = 0x0D; // main clk wait cycle: 131072 * 83.3333ns @12MHz = 10.9227ms (>10ms)
  SYSTEM.PLLWTCR.BYTE = 0x0E; // pll wait cycle: 2097152 * 5.208333ns @192MHz = 10.92267ms (>10ms)
  SYSTEM.SCKCR.LONG = 0x21822222; // ICK=PCKA=PLL/2, FCK=BCK=PCKB=PCKC=PCKD=PLL/4
  SYSTEM.SCKCR2.WORD = 0x0031; // UCK=PLL/4, IEBCK=PLL/2
  
  SYSTEM.PLLCR.WORD = 0x0F00; // PLL: 12 MHz x 16 = 192 MHz

  //--- start ---//
  SYSTEM.MOSCCR.BYTE = 0x00; // Main clock osc is operating
  while ( SYSTEM.MOSCCR.BYTE != 0x00 );

  SYSTEM.PLLCR2.BYTE = 0x00; // PLL is operating
  for (i = 0; i < 2500; i++);

  //--- LOCO -> PLL ---//
  SYSTEM.SCKCR3.WORD = 0x0400; // Clock Source = PLL
  SYSTEM.LOCOCR.BYTE = 0x00; // 0: LOCO is operating.
  SYSTEM.ILOCOCR.BYTE = 0x00; // 0: IWDTLOCO is operating.
//  SYSTEM.SCK1.BYTE = 0x02;
//  SYSTEM.SCK2.BYTE = 0x02;
  SYSTEM.SYSCR0.WORD  = 0x5A01; // external BUS disabled
  SYSTEM.SYSCR1.WORD  = 0x0001;

  for (i = 0; i < 2500; i++);

  MPC.PWPR.BIT.B0WI = 0; // 0: Writing to the PFSWE bit is enabled
  MPC.PWPR.BIT.PFSWE = 1; // 1: Writing to the PFS register is enabled
}


void InitDA(void){

    MSTP(DA) = 0; 

    //I/O Port Setting
    //MPC.P55PFS.BYTE = 0x00;
    //MPC.P54PFS.BYTE = 0x00;

    
    // b7 DAOE1 - D/A Output Enable 1 - enabled. 
    //  b6 DAOE0 - D/A Output Enable1 - enabled. 
    //  b5 DAE - D/A Enable 0 - independent on each channel 
    //  b4:b0 Reserved - Set to 1. 
    DA.DACR.BYTE = 0xDf;    
    
    DA.DADR1 = 0; //Init D/A Data Register. 
    DA.DADR0 = 0; // Init D/A Data Register.           //[AUI2 setting for ED, Bernie, 08/25/2011]
    
}

void InitLED_Keypad(void){

    PORT3.PDR.BIT.B2 = 1;  //DO for Keypad Transmitter Data, DP-Tx
    PORT3.PDR.BIT.B3 = 1;  //DO for Keypad  Chip Select, DP-RCLK
    PORT9.PDR.BIT.B3 = 1;  //DO for Keypad Transmitter Clock, DP-SRCLK
    PORT9.PDR.BIT.B4 = 1;  //Do for Keypad Recive Clock ([ Decoder IC), Key_SRCLK
    PORT9.PDR.BIT.B5 = 0;  //DI for Keypad Recive data, Key-Rx

    MPC.P95PFS.BYTE = 0x00;
    MPC.P94PFS.BYTE = 0x00;
    MPC.P93PFS.BYTE = 0x00;
    MPC.P33PFS.BYTE = 0x00;
    MPC.P32PFS.BYTE = 0x00;
    
}

void InitAFM(void){
   //==== I/O setting ====//
    //PORT9.PDR.BIT.B1 = 1;
    //PORT9.PDR.BIT.B0 = 1;
          
    //PORT9.PMR.BIT.B1 = 1;
    //PORT9.PMR.BIT.B0 = 1;
    
    //MPC.P91PFS.BYTE = 0x06;
    //MPC.P90PFS.BYTE = 0x06;

    MSTP(GPT5) = 0;  // enable Module
    MSTP(GPT6) = 0;  // enable Module

    /*----- General PWM Timer Control Register (GTCR) ---------------------------*/
    /* Bit[15-14]     -     :Reserved                                            */
    /* Bit[13-12]    00     :CCLR, Counter Clear Source Select                   */
    /* Bit[11-10]     -     :Reserved                                            */
    /* Bit[9-8]       0     :TPCS, Timer Prescaler Select                        */
    /* Bit[5-3]       -     :Reserved                                            */
    /* Bit[2-0]       0     :MD, Mode Select                                     */
    GPT5.GTCR.WORD = 0x0000;  // ICLK/4 (system clock/4)
    GPT6.GTCR.WORD = 0x0000;  // ICLK/4 (system clock/4)
    
    /*----- General PWM Timer Count Direction Register (GTUDC) ------------------*/
    /* Bit[15-2]      -     :Reserved                                            */
    /* Bit[2]         0     :UDF, Forc ble Count Direction  Setting              */
    /* Bit[0]         1     :UD, Count Direction Setting                         */
    GPT5.GTUDC.WORD = 0x0001;
    GPT6.GTUDC.WORD = 0x0001;
    /*----- General PWM Timer Cycle Setting Register (GTPR) ---------------------*/
    //===== 4095 setting =====//
    GPT5.GTPR = 2400;  // 24MHz/1200 = 20kHz 
    GPT6.GTPR = 2400;//1200;  // 24MHz/1200 = 20kHz 
    //===== 1200 setting =====//
    //GPT5.GTPR = 1200;  // 24MHz/1200 = 20kHz 
    //GPT6.GTPR = 1200;//1200;  // 24MHz/1200 = 20kHz 
  
    /*----- General PWM Timer Counter (GTCNT) -----------------------------------*/
    GPT5.GTCNT = 0;
    GPT6.GTCNT = 0;
    /*----- General PWM Timer I/O Control Register (GTIOR) ----------------------*/
    /* Bit[15]        0     :OBHLD, Output Retain at GTIOCnB Pin Count Start/Stop*/
    /* Bit[14]        0     :OBDFLT, Output Value at GTIOCnB Pin Count Stop      */
    /* Bit[13-8]      0     :GTIOB, GTIOCnB Pin Function Select                  */
    /* Bit[7]         0     :OAHLD, Output Retain at GTIOCnA Pin Count Start/Stop*/
    /* Bit[6]         0     :OADFLT, Output Value at GTIOCnA Pin Count Stop      */
    /* Bit[5-0]       0     :GTIOA, GTIOCnA Pin Function Select                  */
    GPT5.GTIOR.WORD = 0x5600;
    GPT6.GTIOR.WORD = 0x5600;
  
    /*----- General PWM Timer Output Negate Control Register (GTONCR) -----------*/
    /* Bit[15]        0     :OBE, GTIOCnB Pin Output Enable                      */
    /* Bit[14]        0     :OAE, GTIOCnA Pin Output Enable                      */
    /* Bit[13]        -     :Reserved                                            */
    /* Bit[12]        0     :SWN, Software Negate Control                        */
    /* Bit[11-9]      -     :Reserved                                            */
    /* Bit[8]         0     :NFV, Negate Source Polarity Select                  */
    /* Bit[7-4]       0     :NFS, GTIOC Output Negate Source Select              */
    /* Bit[3]         0     :NVB, GTIOCnB Pin Negate Value Setting               */
    /* Bit[2]         0     :NVA, GTIOCnA Pin Negate Value Setting               */
    /* Bit[1]         0     :NEB, GTIOCnB Pin Negate Control Enable              */
    /* Bit[0]         0     :NEA, GTIOCnA Pin Negate Control Enable              */
    GPT5.GTONCR.WORD = 0x8000;
    GPT6.GTONCR.WORD = 0x8000;
  
    /*----- General PWM Timer Buffer Enable Register (GTBER) --------------------*/
    /* Bit[15]        -     :Reserved                                            */
    /* Bit[14]        0     :ADTDB, GTADTRB Double Buffer Operation              */
    /* Bit[13-12]     0     :ADTTB, GTADTRB Buffer Transfer Timing Select        */
    /* Bit[11]        -     :Reserved                                            */
    /* Bit[10]        0     :ADTDA, GTADTRA Double Buffer Operation              */
    /* Bit[9-8]       0     :ADTTA, GTADTRA Buffer Transfer Timing Select        */
    /* Bit[7]         -     :Reserved                                            */
    /* Bit[6]         0     :CCRSWT, GTCCRA and GTCCRB Forcible Buffer Operation */
    /* Bit[5-4]       0     :PR, GTPR Buffer Operation                           */
    /* Bit[3-2]       0     :CCRB, GTCCRB Buffer Operation                       */
    /* Bit[1-0]       0     :CCRA, GTCCRA Buffer Operation                       */
    GPT5.GTBER.WORD = 0x0004;
    GPT6.GTBER.WORD = 0x0004 ;
  
    /*----- General PWM Timer Cycle Setting Buffer Register (GTPBR) -------------*/
    GPT5.GTPBR = 0x0004;
    GPT6.GTPBR = 0x0004;
  
    /*----- General PWM Timer Compare Capture Register m (GTCCRm) ---------------*/
    GPT5.GTCCRB = 0xFFFF;
    GPT5.GTCCRE = 0xFFFF;
    GPT6.GTCCRB = 0xFFFF;
    GPT6.GTCCRE = 0xFFFF;
    /*----- Pin Definition for SB Function --------------------------------------*/
    //PORTD.DDR.BIT.B4 = 1 ;  // BD_76B  // Dynamic Brake
  
    //GPT.GTSTR.BIT.CST3 = 1 ;
    GPTB.GTSTR.WORD = 0x06 ;  // GPT5 start count
    //GPTB.GTSTR.BIT.CST6 = 1 ;  // GPT6 start count

}


void HardwareSetup(void)
{    
    Initial_Var();   //

    //set_imask(15);
    DINT();
    //--- 02/09/06	Max.SJ.Chang: RST316J = 0;
	USB_vdIniClk();	// modify USB initial section, Sean, 20140812
	
	SYSCLK_Init();
	
    InitIO();

    InitSCI2();
    InitSCI3();

    InitSCIERI();
    
    InitAFM();

    //PORTE.PDR.BIT.B4 = 1;

    //MPC.PG2PFS.BYTE = 0x0A;
    //MPC.PG1PFS.BYTE = 0x0A;
    //MPC.PG0PFS.BYTE = 0x0A;
    //CC_S = 1;

    //--- 02/09/06	Max.SJ.Chang: 
    RST316J = 0;
#if 0 //masked by Bernie (NO USED)
#if NEWIEDCB
    SRY_T = 1;		// SRY_T definition changed, Sean, 06/25/2010
#else
    SRY_T = 0;		// dino, 03/05/2007
#endif
#endif
    //SCI2(13) > WG(12) > ADI2(11) > 100us(10) > 1ms(9) > ADI0/1(8)    
    //Current Priority Setting,Sean, 01/25/2010
	//14:POE2
	//13:USB
	//12:WG
	//11:PG1,PGZ,SCI0,SCI1,SCI2,SCIF3,SCI4,ADC2
	//10:100us
	//7:200us
	//3:IIC
	//2:RCANET
	//1:NMIE
	//0:ADC0,ADC1   

    InitPOE2_PROTECT();
	
    InitMTU234_WG();
	
    InitCMT0_500us();
    InitCMT1_100us();
    InitCMT2();	// 200us for USB routine, Sean, 2014/09/16



    InitMTU21_PG1();
	InitMTU2S4_PGZ();

   
    InitAD_S12B0();
    InitAD_S12B1();
    InitAD_S10();
    ADInitCalib();
    InitDA();
    //InitLED_Keypad();

    SCI0_DIR = 0; 		// Sean, 01/25/2010

	InitIIC();			//Sean, 02/22/2010	
	//Init_USB();		//Sean, 02/22/2010	 //USB FUNCTION BERNIE	
    //InitRCANET();		//Sean, 03/30/2010   // [CAN Protocol for High Cap , Sampo,  2011/09/05]
	
	//InitWDT();	//WDT, Sean, 05/07/2010

    //INTC.ICR0.BIT.NMIE = 0;     /* NMI detected on falling edge, dino, 05/08/2007 */
    
    //ICU.NMICR.BIT.NMIMD = 0;
    //INTC.IRQCR.WORD = 0x0055;   /* IRQ3~IRQ0 detected on falling edge       */
    //INTC.ICR1.WORD = 0x5555;   /* IRQ7~IRQ0 detected on falling edge       */
    //ICU.IRQCR0.BYTE |= 0x04;							//Sean, 01/25/2010
    //ICU.IRQCR1.BYTE |= 0x04;
    //ICU.IRQCR2.BYTE |= 0x04;
    //ICU.IRQCR3.BYTE |= 0x04;
    //ICU.IRQCR4.BYTE |= 0x04;
    //ICU.IRQCR5.BYTE |= 0x04;
    //ICU.IRQCR6.BYTE |= 0x04;
    //ICU.IRQCR7.BYTE |= 0x04;
    
	PWRON = 1;	// Power On Flag, Add by DINO, 12/01/2008
    STtune = 1;
    
    STO_FLAG = 0;

	USB_vdIniVar();	// modify USB initial section, Sean, 20140812
}

#ifdef  _SYSInit_C
    #undef  _SYSInit_C
#endif

/************************************************************************
 Copyright (c) 2005 EMBU DELTA
 All rights reserved.
*************************************************************************
 End of this File (EOF):
 !!!!!!Do not put anything after this part!!!!!!!!!!!
*************************************************************************/
