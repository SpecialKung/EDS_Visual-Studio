/***********************************************************************/
/*                                                                     */
/*  FILE        :MathTool.c                                            */
/*  DATE        :Wed, Aug 24, 2005                                     */
/*  DESCRIPTION :Math Tool                                             */
/*  CPU TYPE    :SH7145F                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.3.0).     */
/*                                                                     */
/***********************************************************************/
#if 0
/* Include File ===============================================*/

#pragma inline_asm U16xU16divU16
/*======== x * y / z ===============================*/
/*	x:R4 (16bits)	
/*	y:R5 (16bits)
/*  Z:R6 (16bits)
/*  R4*R5(32bits) / R6(16bits) = R0(16bits):Unsigend
/*==================================================*/
int U16xU16divU16 (int x,int y,int z)
{ 
        TST             R6,R6       //Zero division check
        BT              ZERO_DIV0
              
        mulu.w          R4,R5     
 	    sts             MACL,R4

        MOV             R6,R0		// round down or up function
        SHLR			R0			// Add by DINO
        ADD				R0,R4		// 09/09/2008

        shll16          R6
	    div0u                        
        .arepeat    	16               
        div1            R6,R4            
        .aendr                       
        rotcl       	R4               
        extu.w      	R4,R0          
        BRA				div16_u_end
        NOP
ZERO_DIV0:                
        MOV				#H'FF,R0		
div16_u_end:
} 
#pragma inline_asm (S16xS16divS16)

/*======== x * y / z ===============================*/
/*	x:R4 (16bits)	
/*	y:R5 (16bits)
/*	z:R6 (16bits)
/*  R4*R5(32bits) / R6(16bits) = R0(16bits):Sigend
/*==================================================*/
int S16xS16divS16 (int x,int y,int z)
{ 
        TST             R6,R6       ;Zero division check
        BT              ZERO_DIV01

        XOR             R0,R0       ; R1 = 0
        CMP/PZ          R4
        BT/S            X_BTS_1     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R4,R4       ;
X_BTS_1:
        CMP/PZ          R5          ; 
        BT/S            Y_BTS_1     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R5,R5       ;
Y_BTS_1:               
        CMP/PZ          R6          ; 
        BT/S            Z_BTS_1     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R6,R6       ;
Z_BTS_1:        
        MOV             R0,R2       ;
       
        mulu.w          R4,R5     
 	    sts             MACL,R4
 	    
        shll16          R6
		div0u                        
        .arepeat        16               
        div1            R6,R4            
        .aendr                       
        rotcl           R4               
        extu.w          R4,R4

 	    EXTS.B          R2,R0
 	    CMP/EQ          #H'01,R0
 	    BF              NO_NEG_1
 	    NOP
 	    NEG             R4,R4
NO_NEG_1 	    
        MOV             R4,R0
        BRA				div16_s1_end
		NOP
ZERO_DIV01:                
        MOV				#H'FF,R0		
div16_s1_end:
}  
#pragma inline_asm (U16xS16shlr16)

/*======== x * y / z ===============================*/
/*	x:R4 (Unsigend 16bits)	
/*	y:R5 (  sigend 16bits)
/*	z:R6 (=65536)
/*  R4*R5(32bits) / R6(16bits) = R0(16bits):Sigend
/*==================================================*/
int U16xS16shlr16 (int x,int y,int z)
{ 
        TST             R6,R6       ;Zero division check
        BT              ZERO_DIV02

        XOR             R0,R0       ; R1 = 0
        CMP/PZ          R5          ; 
        BT/S            Y_BTS_2     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R5,R5       ;
Y_BTS_2:               
//        CMP/PZ          R6          ; 
//        BT/S            Z_BTS_2     ; >= 0
//        NOP
//        XOR             #H'01,R0
//        NEG             R6,R6       ;
//Z_BTS_2:        
        MOV             R0,R2       ;
        
        mulu.w          R4,R5     
 	    sts             MACL,R4
 	    
//		shll16          R6
//		div0u                        
//      .arepeat        16               
//        div1            R6,R4            
//        .aendr                       
//        rotcl           R4               
//        extu.w          R4,R4

		shlr16			R4

 	    EXTS.B          R2,R0
 	    CMP/EQ          #H'01,R0
 	    BF              NO_NEG_2
 	    NOP
 	    NEG             R4,R4
NO_NEG_2 	    
        MOV             R4,R0
        BRA				div16_s2_end
		NOP
ZERO_DIV02:                
        MOV				#H'FF,R0		
div16_s2_end:
} 

#pragma inline_asm (U32remU16)
/*======== x % y ===================================*/
/*	x:R4 (32bits)	
/*	y:R5 (16bits)
/*  R4(32bits) % R5(16bits) = R0(16bits):Unsigend
/*==================================================*/
int U32remU16 (int x,int y)
{ 
        TST             R5,R5       ;Zero division check
        BT              ZERO_DIV03

        shll16          R5
		div0u                        
        .arepeat        16               
        div1            R5,R4            
        .aendr     
        BT				TEquOne01
		ADD				R5,R4
TEquOne01       				                  
        shlr16			R4
        mov             R4,R0
        BRA				rem16_u_end
        NOP
ZERO_DIV03:                
        MOV				#H'FF,R0		
rem16_u_end:
} 
#pragma inline_asm (U32divU16)

/*======== x / y ===================================*/
/*	x:R4 (32bits)	
/*	y:R5 (16bits)
/*  R4(32bits) / R5(16bits) = R0(16bits):Unsigend
/*==================================================*/
int U32divU16 (int x,int y)
{ 
        TST             R5,R5       ;Zero division check
        BT              ZERO_DIV04

		shll16			R5
		div0u                        
	    .arepeat   		16               
	    div1        	R5,R4            
	    .aendr                       
	    rotcl       	R4               
	    extu.w      	R4,R0          

        BRA				div16_uw_end
        NOP
ZERO_DIV04:                
        MOV				#H'FF,R0		
div16_uw_end:
} 
#pragma inline_asm (ul_div64)

/*======== x:y / z ==================================*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*  z:R6(32bits)
/*  R4:R5(64bits) / R6(32bits) = R0(32bits):Unsigned
/*===================================================*/                 
int ul_div64 (int x, int y, int z)				 
{
        TST             R6,R6       ;Zero division check
        BT              ZERO_DIV1
        div0u            
     	.arepeat        32   
 	    rotcl           R4   
 	    div1            R6,R5
 	    .aendr           
 	    rotcl           R4   
	    mov             R4,R0
		bra				div64_end
		nop
ZERO_DIV1:        
		mov				#H'FF,R0
div64_end:
}

#pragma inline_asm (U32xU32divU32)
/*======== x * y / z ================================*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*  z:R6(32bits)
/*  R4*R5(64bits) / R6(32bits) = R0(32bits):Unsigned
/*===================================================*/                 
int U32xU32divU32 (int x, int y, int z)
{
        TST             R6,R6       //Zero division check
        BT              ZERO_DIV2
               
        dmulu.l         R4,R5     
 	    sts             MACH,R4
 	    sts             MACL,R5
 	             
 	    div0u                 
 	    .arepeat        32        
 	    rotcl           R5
 	    div1            R6,R4
 	    .aendr                
 	    rotcl           R5
		bra				xydivz_end
        nop
ZERO_DIV2:        
		mov.l			#H'FFFFFFFF,R5
xydivz_end:
        mov				R5,R0
        
}						  
#pragma inline_asm (S32xS32divS32)

/*======== x * y / z ================================*/
/*	x:R4(32bits) signed value
/*	y:R5(32bits) unsigned value
/*  z:R6(32bits)
/*  R4*R5(64bits) / R6(32bits) = R0(32bits):Signed
/*===================================================*/ 
int S32xS32divS32 (int x, int y, int z)
{
        TST             R6,R6       ;Zero division check
        BT              ZERO_DIV3
     
        XOR             R0,R0       ; R1 = 0
        CMP/PZ          R4
        BT/S            X_BTS_0     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R4,R4       ;
X_BTS_0:
        CMP/PZ          R5          ; 
        BT/S            Y_BTS_0     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R5,R5       ;
Y_BTS_0:               
        CMP/PZ          R6          ; 
        BT/S            Z_BTS_0     ; >= 0
        NOP
        XOR             #H'01,R0
        NEG             R6,R6       ;
Z_BTS_0:        
        MOV             R0,R2       ;
 	
        dmulu.l         R4,R5     
 	    sts             MACH,R4
 	    sts             MACL,R3
		
        div0u                 
 	    .arepeat    32        
 	    rotcl           R3
 	    div1            R6,R4
 	    .aendr         
 	    rotcl           R3
 	       
 	    EXTS.B          R2,R0
 	    CMP/EQ          #H'01,R0
 	    BF              NO_NEG_0
 	    NOP
 	    NEG             R3,R3
NO_NEG_0 	    
        MOV             R3,R0
		bra				sxydivz_end
		NOP
ZERO_DIV3:        
		mov.l			#H'0,R0
sxydivz_end:
 	
}	
#pragma inline_asm (U32xU16shlr16)

/*======== x * y / z ================================*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*  R4*R5(64bits)>>16 = R0(32bits):Unsigned
/*===================================================*/ 
int U32xU16shlr16 (int x, int y)
{
	DMULU.L     R4,R5
 	STS         MACH   ,R4
 	STS         MACL   ,R5
 
 	SHLR16      R5
 	SHLL16      R4
 	ADD         R4,R5
 	MOV			R5,R0 	
}	
#pragma inline_asm (S32xS16shlr16)

/*======== x * y / z ================================*/
/*	x:R4(32bits) 
/*	y:R5(16bits)
/*  R4*R5(48bits)>>16 = R0(32bits):signed
/*===================================================*/ 
int S32xS16shlr16 (int x, int y)
{

	DMULS.L     R4,R5
 	STS         MACH   ,R4
 	STS         MACL   ,R5

 
 	SHLR16      R5
 	SHLL16      R4
 	ADD         R4,R5
 	MOV			R5,R0 	
}	
#pragma inline_asm (S32xS32shlr31)

/*======== x * y / z ================================*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*  R4*R5(64bits)>>31 = R0(32bits):signed
/*===================================================*/ 
int S32xS32shlr31 (int x, int y)
{

	DMULS.L     R4,R5
 	STS         MACH   ,R0
 	STS         MACL   ,R5

 	ROTCL		R5
 	ROTCL		R0
}	

#pragma inline_asm (U32xU32getlo)
int U32xU32getlo (int x, int y)
{
	DMULU.L     R4,R5
 	STS         MACH   ,R4
 	STS         MACL   ,R0

}
#pragma inline_asm (S32xS32shlr32)

int S32xS32shlr32 (int x, int y)
{
	DMULS.L     R4,R5
 	STS         MACH   ,R0
 	STS         MACL   ,R5

}
#pragma inline_asm (U32xU32shlr32)

int U32xU32shlr32 (int x, int y)
{
	DMULU.L     R4,R5
 	STS         MACH   ,R0
 	STS         MACL   ,R5

}

#pragma inline_asm (uw_Sqrt32a)
int uw_Sqrt32a (int x)
{

}
//#pragma inline_asm (memadd_rd,sl_limit,ulAplusB_Over,ulAminusB_Under)
#pragma inline_asm (memadd_rd)


/*======== Memory Read ===========*/
int memadd_rd (int x)
{
	mov.l		#H'00008000,R5

	CMP/GT		R5,R4			// R4 > R4 ?
	BT/S		AddressErr
	NOP								// R4| > R5
	MOV.l		#H'00000001,R0
	AND		R4,R0
    	CMP/EQ          #H'01,R0
    	BT/S            AddressErr
	NOP

	mov.l          #H'FFF80000,R0
	mov.w           @(R0,R4),R0
	BRA		end_memadd_rd
	NOP
AddressErr	
	mov.l		#H'00000000,R0
	nop
end_memadd_rd
}

// [ Read SFR DATA, Add by DINO, 03/01/2010
//#pragma inline_asm (memadd1_rd,sl_limit,ulAplusB_Over,ulAminusB_Under)
#pragma inline_asm (memadd1_rd)


/*======== Memory Read ===========*/
int memadd1_rd (int x)
{
	mov.l		#H'00001000,R5

	CMP/GT		R4,R5			// R5 > R4 ?
	BT/S		AddressErr
	NOP								// R4| > R5
	MOV.l		#H'00000001,R0
	AND		R4,R0
    	CMP/EQ          #H'01,R0
    	BT/S            AddressErr1
	NOP

	mov.l           #H'FFFE0000,R0
	mov.w           @(R0,R4),R0
	BRA		end_memadd1_rd
	NOP
AddressErr1	
	mov.l		#H'00000000,R0
	nop
end_memadd1_rd
}


#pragma inline_asm (memadd2_rd)

/*======== Memory Read ===========*/
int memadd2_rd (int x)
{
	mov.l		#H'00008000,R5

	CMP/GT		R4,R5			// R5 > R4 ?
	BT/S		AddressErr2
	NOP								// R4| > R5
	MOV.l		#H'00000001,R0
	AND		R4,R0
    	CMP/EQ          #H'01,R0
    	BT/S            AddressErr
	NOP

	mov.l           #H'FFFF0000,R0
	mov.w           @(R0,R4),R0
	BRA		end_memadd2_rd
	NOP
AddressErr2	
	mov.l		#H'00000000,R0
	nop
end_memadd2_rd
}
// ]
#pragma inline_asm (sl_limit)

/*==========  limit	 ================================*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*  z:R6(32bits)
/*	R4+R5 = R5, overflow -> T = 1
/* 	if (T == 1){ 
/*		if(R4 > 0)
/*			R0 = R6
/*		else
/*			R0 = -R6
/*	}
/*  else{
/*		if (abs(R5) > R6){
/*			if (R5 > 0)
/*				R0 = R6
/*			else
/*				R0 = -R6
/*		}
/*		else
/*			R0 = R5
/*	}
/*===================================================*/ 
int sl_limit(int x,int y, int z)
{
		ADDV			R4,R5		; R5 = R4+R5
		BF/S			NO_OVER_1
		NOP

        CMP/PZ          R4
 	    BT/S            PosValue1	; >= 0
		NOP
		NEG				R6,R0
		BRA				LimitEnd_2
		NOP
PosValue1		
		MOV				R6,R0
		BRA				LimitEnd_2
		NOP

NO_OVER_1
		MOV				R5,R4		; R4 = R5

        XOR             R0,R0       ; R0 = 0
        CMP/PZ          R5
        BT/S            X_BTS_2     ; >= 0
        NOP
        XOR             #H'01,R0	; R0 = 1
        NEG             R5,R5       ;
X_BTS_2:
		
		CMP/GT			R5,R6		; |R5| > R6 ?
		BT/S			LimitEnd_1
		NOP							; |R5| > R6

 	    CMP/EQ          #H'01,R0
 	    BF/S            PosValue2
 	    NOP							; R5 < 0
		NEG				R6,R0		; R0 = -R6
		BRA				LimitEnd_2	; END
		NOP
PosValue2							; R5 > 0	
		MOV				R6,R0		; R0 = R6
		BRA				LimitEnd_2	; END
		NOP
LimitEnd_1							; |R5| < R6
		MOV				R4,R0		; END
LimitEnd_2
		
}
#pragma inline_asm(ulAplusB_Over)

/*= ul X + Y, if Overflow, return 0xFFFFFFFF ========*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*	R4+R5 = R5, overflow -> T = 1
/* 	if (T == 1){ 
/*		R0 = 0xFFFFFFFF
/*	}
/*  else{
/*		R5 = R4 + R5
/*		R0 = R5
/*	}
/*===================================================*/ 
unsigned int ulAplusB_Over(unsigned int x, unsigned int y)
{
		ADDV			R4,R5		; R5 = R4+R5
		BF/S			AB_NoOver
		NOP

		MOV.L			#H'FFFFFFFF,R0
		NOP
		BRA				AB_OverEnd
		NOP
AB_NoOver
		MOV				R5,R0		; R0 = R5
AB_OverEnd
}

/*= ul X - Y, if Underflow, return 0 ================*/
/*	x:R4(32bits) 
/*	y:R5(32bits)
/*	R4-R5 = R4, Underflow -> T = 1
/* 	if (T == 1){ 
/*		R0 = 0;
/*	}
/*  else{
/*		R4 = R4 - R5
/*		R0 = R4
/*	}
/*===================================================*/ 
#pragma inline_asm(ulAminusB_Under)


unsigned int ulAminusB_Under(unsigned int x, unsigned int y)
{
		CMP/GT			R5,R4		; R4 > R5 ?
		BF/S			AB_Under
		NOP

		SUB				R5,R4		; R4 = R4 - R5
		MOV				R4,R0		
		BRA				AB_UnderEnd
		NOP
AB_Under
		MOV.L			#H'00000000,R0
AB_UnderEnd
}



#endif
