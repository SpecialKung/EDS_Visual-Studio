/***********************************************************************/
/*                                                                     */
/*  FILE        :MathTool.c                                            */
/*  DATE        :Wed, Aug 24, 2005                                     */
/*  DESCRIPTION :Math Tool                                             */
/*  CPU TYPE    :SH7145F                                                */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.3.0).     */
/*                                                                     */
/***********************************************************************/
#ifndef _mathtool_C
	#define _mathtool_C
#endif

/* Include File ===============================================*/
#include "ProgHeader.h"
#include "PR_SinTable.h"
/*
SLONG S32xS32divS32_c(int x, int y, int z)
{ 
    SBYTE sf = 0;
    
    if (x < 0){
        sf = 1;
        x = abs(x);
    }
    if (y < 0){
        sf = sf ^ 1;
        y = abs(y);
} 
    if (z < 0){
        sf = sf ^ 1;
        z = abs(z);
    }
    x = U32xU32divU32(x,y,z);
    if (sf == 1)
     x = -x;
    return x; 

}
*/

//******************************************************************
// @Function:   LowPass(UWORD ak, SWORD xn, SLONG yn)
//------------------------------------------------------------------
// @Description: Y(n)=Y(n-1)+K(X(n)-Y(n-1))
//               K=65535/(filter time*time base),control yn_ul low word 
//               carry to hi word speed.
//------------------------------------------------------------------
// @Returnvalue:  
//------------------------------------------------------------------
// @Parameters:    None
//------------------------------------------------------------------
// Note:  
//******************************************************************
SLONG LowPass(ULONG ak, SLONG xn, SLONG yn)
{    

    if(ak==65535){
      yn = xn;
    }
    else{
//      if(ak == 0)
//        ak = 1;

    //2*pi*2^13 = 51472
    ak = ((ULONG)ak * 51472)>>16; //Q13 = Q(16+13-16)

	if(xn > yn)
      yn = yn + 8*(SLONG)(U32xU16shlr16((ULONG)ak, (xn-yn))); //Q31 = Q31 + Q3*Q(13+31-16)
    else
      yn = yn - 8*(SLONG)(U32xU16shlr16((ULONG)ak, (yn-xn))); //Q31 = Q31 + Q3*Q(13+31-16)   
    }
    
    return yn;

}

SLONG lowpass_sl(UWORD ak, SWORD xn, SLONG yn)
{
	SWORD an;
    if(ak==65535){
        yn = xn << 16;
    }
    else{
        an = (yn>>16);
         
        if(xn > an)
            yn = yn + (ULONG)ak*(UWORD)(xn - an); 
        else
            yn = yn - (ULONG)ak*(UWORD)(an - xn);
    }
    return yn;
}

ULONG lowpass_ul(UWORD ak, UWORD xn, ULONG yn)
{
	UWORD an;
	
    if(ak==65535){
        yn = xn << 16;
    }
    else{
        an = (yn>>16);
         
        if(xn > an)
            yn = yn + (ULONG)ak*(UWORD)(xn - an); 
        else
            yn = yn - (ULONG)ak*(UWORD)(an - xn);
    }
    return yn;
}

SLONG LowPass_Hz(ULONG ak, SLONG xn, SLONG yn)
{    
	SLONG zn;

    if(ak==51471){ //51471=2*pi*2^13
      yn = xn;
    }
    else{
        zn = (ULONG)ak * ((xn-yn)>>13); //Q31 = Q31 + Q(13+(31-13))
        if (zn == 0)
            yn = xn;
        else
            yn = yn + zn;
    }
    
    return yn;

}

/************************************************************************
     SQRT FUNCTION
     INPUT  X (32 BIT)
************************************************************************/
SLONG uw_Sqrt32c(ULONG x)
{    
    ULONG xlow,xhigh;
    UWORD xmid;
    
    if ((ULONG)x>=(1<<30)){
    	xlow  = 32768;
    	xhigh = 65535;
        xmid  = (3<<14);  /* 15  */
    }
    else{  
        xlow  = 0;
        xhigh = 32768;
        xmid  = (1<<14);       /*  15 */
    }    
    if((ULONG)x>=(xmid*xmid)) 
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /* 14 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /* 13 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /* 12 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
        
    xmid  = (xlow+xhigh)>>1;   /* 11 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /* 10 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  9 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  8 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  7 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  6 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  5 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  4 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  3 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  2 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  1 */
    if( (ULONG) x>= (xmid*xmid) )
        xlow  = xmid;
    else
        xhigh = xmid;
    
    xmid  = (xlow+xhigh)>>1;   /*  0 */
    if( (ULONG) x>= (xmid*xmid) )
        return  (xmid+xhigh)>>1;
    else
        return  (xlow+xmid )>>1;
    
}

/************************************************************************
     SQRT FUNCTION
     INPUT  X (32 BIT)
************************************************************************/
UWORD uw_Sqrt32c_1(ULONG x)
{
    UWORD s, last;
    
    if (x>=0xfffd0002)
        return 65535;
    else {
        if (x>=16384*16384)
            s = 16384;
        else{
            if (x>=4096*4096)
                s = 4096;
            else {
                if (x>=1024*1024)
                    s = 1024;
                else{
                    if (x>=256*256)
                        s = 256;
                    else{
                        if (x>=64*64)
                            s=64;
                        else{
                            if (x>=16*16)
                                s = 16;
                            else{
                                if (x>=4*4)
                                    s = 4;
                                else
                                    s = 2;
                            }
                        }    
                    }
                }    
            }
        }    
    }
    do {
        last = s;
        s = ((ULONG)(x / s) + s) >> 1;
    } while (!((s <= (last+1))&&(s >= (last-1))));
    return last;
}
UWORD arccos(SWORD c)
{
    UWORD  small = 0;
    UWORD  large = 125;
    SWORD  guess = 62;
    SBYTE negative;

    if(c < 0){
       c = -c;
       negative = 1;
    }
    else{
       negative = 0;
    }
    
    do{
       if (cos[guess] >= c){
          small = guess;
       }
       else {
          large = guess;
       }
       guess = (large  + small) >> 1;
    }while(large > small + 1);

    if (negative) // Current lead Voltage
       guess = 250 - guess;

    return (guess);
}

/************************************************************************
     Notch Filter, run in 2kHz(500us)
     INPUT  X (16 BIT)
     wn = 2*pi*Hz
     damp_z = 1/(10^(x/20)),Q15
     damp_p = 1
************************************************************************/

void Init_Notch(void)
{
    Nh_sltmp4 = 0;
    Nh_sltmp5 = 0;
    Nh_sltmp4_Old = 0;
    Nh_sltmp6_Old = 0;

}

SWORD Notch(int xn, int wn, int damp_z)
{
    SWORD yn;
    SLONG sltmp3,sltmp7,sltmp9;

    sltmp9 = (Nh_sltmp5<<1); //Q31
    sltmp9 = sltmp9 * wn; //Q31
    
    sltmp3 = (xn<<16) - Nh_sltmp4 - sltmp9; //Q31
    Nh_sltmp4 = (S32xS16shlr16(sltmp3, 262))>>4; //Q31=Q(31+20-20),262=500us/2*2^20
    Nh_sltmp4 = Nh_sltmp4 + Nh_sltmp4_Old; //Q31
    Nh_sltmp5 = Nh_sltmp4 + Nh_sltmp4_Old; //Q31
    Nh_sltmp4_Old = Nh_sltmp4;
    
    Nh_sltmp4 = (S32xS16shlr16(Nh_sltmp5, 262))>>4; //Q31=Q(31+20-20),262=500us/2*2^20
    Nh_sltmp4 = Nh_sltmp4 + Nh_sltmp6_Old; //Q31
    sltmp7 = Nh_sltmp4 + Nh_sltmp6_Old; //Q31
    Nh_sltmp6_Old = Nh_sltmp4;
    
    Nh_sltmp4 = sltmp7 * wn * wn; //Q31
//    sltmp9 = ((Nh_sltmp5<<1) * damp_z)>>15; //Q31=Q(31+1-15)
    sltmp9 = S32xS16shlr16((Nh_sltmp5<<2), damp_z); //Q31=Q(31+1-15)
    sltmp9 = sltmp9 * wn; //Q31
    yn = (Nh_sltmp4 + sltmp9 + sltmp3)>>16;
    
    return yn;
}

UWORD U16xU16divU16(UWORD x, UWORD y, UWORD z)
{	// modified rounding before saturation by JOSH, 2016/08/02
	ULONG ul_temp;
	UWORD uw_result;

	if(z){
		ul_temp = (ULONG)x*y + (z>>1);		// rounding Q(16+16) = Q32
		if((ul_temp>>16) < z)				// saturation in UWORD
			uw_result = (UWORD)(ul_temp/z);	// Q(32-16) = Q16
		else
			uw_result = 0xFFFF;
	}
	else
		uw_result = 0xFFFF;

	return uw_result;			
}

/*

SWORD S16xS16divS16(SWORD x, SWORD y, SWORD z){  

 SLONG sl_temp;
 SWORD sw_result;
 
 if (z != 0){//sl_temp 
   sl_temp = ((SLONG)(x * y)) / z;             // Q(15+15) = Q30 // [delete rounding by Lyabryan, 2015/02/10]
   if (sl_temp>0x7FFF) sw_result = 0x7FFF; // [add output limit by Lyabryan, 2015/02/10]
   else if (sl_temp<-0x7FFF) sw_result = -0x7FFF; // [add output limit by Lyabryan, 2015/02/10]
   else sw_result = (SWORD)(sl_temp);   // Q(30-15) = Q15
 }
 else {sw_result = 0x7FFF;}
 
 return sw_result;		
}

*/

SWORD S16xS16divS16(SWORD x, SWORD y, SWORD z)
{	// modified output saturate and output sign by JOSH 2016/08/02
	ULONG ul_temp, X;
	UWORD Y, Z;
	SWORD sw_result;
	
	if(z){	
		X = abs(x);	Y = abs(y);	Z = abs(z);	// same sign for rounding
		ul_temp = X*Y + (Z>>1);				// rounding Q(15+15) = Q30
		if((ul_temp>>15) < Z)				// saturation in SWORD
			sw_result = (SWORD)(ul_temp/Z);	//  Q(30-15) = Q15
		else
			sw_result = 0x7FFF;	 
		if((x^y^z)&0x8000)					// check sign bit of x*y/z
			sw_result *= -1;
	}
	else	// check sign bit of x*y and saturate (x*y/0) in SLONG
		sw_result = ((x^y)&0x8000) ? -0x7FFF : 0x7FFF;

	return sw_result;	       
}

UWORD U32divU16(ULONG x, UWORD y)
{	// add rounding and saturation by JOSH, 2016/08/02
	UDOUBLE udl_temp;
	UWORD uw_result;

	if(y){
		udl_temp = (UDOUBLE)x + (y>>1);		// rounding Q(32+32) = Q64
		if((udl_temp>>16) < y)				// saturate in UWORD
			uw_result = (UWORD)(udl_temp/y);// Q(64-32) = Q32 //[fix DD CE2 error, Lyabryan, 2015/05/04] DD datecode 15191
		else
			uw_result = 0xFFFF;
	}
	else
		uw_result = 0xFFFF;

	return uw_result;	
}

ULONG U32xU32divU32(ULONG x, ULONG y, ULONG z)
{	// modified rounding before saturation by JOSH, 2016/08/02
	UDOUBLE udl_temp;
	ULONG ul_result;
	
	if(z){
		udl_temp = (UDOUBLE)x*y + (z>>1);		// rounding Q(32+32) = Q64
		if((udl_temp>>32) < z)					// saturate in ULONG
			ul_result = (ULONG)(udl_temp/z);	// Q(64-32) = Q32
		else 
			ul_result = 0xFFFFFFFF;
	}
	else
		ul_result = 0xFFFFFFFF;

	return ul_result;	
}

SLONG S32xS32divS32(SLONG x, SLONG y, SLONG z)
{	// modified output saturate and output sign by JOSH, 2016/08/02
	UDOUBLE udl_temp, X;
	ULONG Y, Z;
	SLONG sl_result;
	
	if(z){	
		X = abs(x); Y = abs(y); Z = abs(z);	// same sign for rounding
		udl_temp = X*Y + (Z>>1);			// rounding Q(31+31) = Q62
		if((udl_temp>>31) < Z)				// saturation in SLONG
			sl_result = (SLONG)(udl_temp/Z);// Q(62-31) = Q31
		else
			sl_result = 0x7FFFFFFF;
		if((x^y^z)&0x80000000)				// check sign bit of x*y/z
			sl_result *= -1;
	}
	else	// check sign bit of x*y and saturate (x*y/0) in SLONG
		sl_result = ((x^y)&0x80000000) ? -0x7FFFFFFF : 0x7FFFFFFF;

	return sl_result;	
}

ULONG U32xU16shlr16 (ULONG x, UWORD y){

  UDOUBLE Udl_temp;
  ULONG ul_result;
		  
  Udl_temp = (UDOUBLE)x * y;
  ul_result = (ULONG)(Udl_temp >> 16);
	  
  return ul_result;
}


int S32xS16shlr16 (int x, int y){   

 UBYTE ubSIGN1,ubSIGN2;
 UDOUBLE sdcalcul;
 SLONG slTemp;
 
   if(x<0){
     x = (0xFFFFFFFF-x+1);
     ubSIGN1 = 1;
    }
    else
     ubSIGN1 = 0;
     
   if(y<0){
   	  ubSIGN2 = 1;
   	  y = (0xFFFFFFFF-y+1);
   }
   else
     ubSIGN2 = 0;
     

   	 sdcalcul = ((UDOUBLE)x*y>>16);
   	 slTemp = (ULONG)(sdcalcul&0x7FFFFFFF);
   
  
     
   if((ubSIGN1==1 && ubSIGN2==1)||(ubSIGN1==0 && ubSIGN2==0)){
   }
   else
       slTemp = (SLONG)(-sdcalcul);
   
   
    
 return slTemp;
}


ULONG U32xU32shlr32 (ULONG x, ULONG y){

  UDOUBLE Udl_temp;
  ULONG ul_result;
		  
  Udl_temp = (UDOUBLE)x * y;
  ul_result = (ULONG)(Udl_temp >> 32);
	  
  return ul_result;
}


ULONG U32xU32getlo (ULONG x, ULONG y)
{
  UDOUBLE udcalcul;
			  
  udcalcul =(UDOUBLE) x * y;
  udcalcul &= 0xFFFFFFFF;
  
		  
  return udcalcul;
}

/*int S32xS32shlr31 (int x, int y)
{
  SDOUBLE sdcalcul;
	
  sdcalcul = (SDOUBLE) x * y;
  sdcalcul = sdcalcul >> 31;
		
  return sdcalcul;
}*/

SLONG S32xS32shlr31 (SLONG x, SLONG y){   // added by Justin
		

  SDOUBLE sdl_temp;
  UDOUBLE Udl_temp;
  SLONG sl_result;
  
  sdl_temp = (SDOUBLE)x * y;           // Q(31+31) = Q62
  //sl_result = (SLONG)(sdl_temp>>31);  // Q(62-31) = Q31
  
  if (sdl_temp >= 0){
  	sl_result = (SLONG)(sdl_temp>>31);
  }
  else{
  	Udl_temp = (UDOUBLE)(0 - sdl_temp);
  	Udl_temp >>= 31;
  	sl_result = ((SLONG)0) - ((SLONG)Udl_temp);
  }
 
  return sl_result;	

}


/*int S32xS32shlr32 (int x, int y)
{
  SDOUBLE sdcalcul;
		
  sdcalcul = (SDOUBLE) x * y;
  sdcalcul = sdcalcul >> 32;
			
  return sdcalcul;

}*/
SLONG S32xS32shlr32 (SLONG x, SLONG y){   // added by Justin
		
  SDOUBLE sdl_temp;
  UDOUBLE Udl_temp;
  SLONG sl_result;
  
  sdl_temp = (SDOUBLE)x * y;           // Q(31+31) = Q62
  //sl_result = (SLONG)(sdl_temp>>32);  // Q(62-32) = Q30
  
  if (sdl_temp >= 0){
  	sl_result = (SLONG)(sdl_temp>>32);
  }
  else{
  	Udl_temp = (UDOUBLE)(0 - sdl_temp);
  	Udl_temp >>= 32;
  	sl_result = ((SLONG)0) - ((SLONG)Udl_temp);
  }
 
  return sl_result;	

}


SLONG sl_limit(SLONG x, SLONG y, SLONG z){
    
  SDOUBLE sdcalcul;

  sdcalcul = (SDOUBLE)x + y;

  if( sdcalcul >= 0 ){                       //sdcalcul >= 0
    if( sdcalcul > 0x7FFFFFFF ){             
		sdcalcul = 0x7FFFFFFF;
        if(sdcalcul >= z) sdcalcul = z;
    }
    else{
        if(sdcalcul >= z) sdcalcul = z;
        }
  }
  else{                                       //sdcalcul  <  0
    if( sdcalcul < -0x7FFFFFFF ){
        sdcalcul = -0x7FFFFFFF;
        if(sdcalcul >= z) sdcalcul = z;
    }
    else{
        if(sdcalcul >= z) sdcalcul = z;
    }
		
  }

  return sdcalcul;
}

SLONG sl_limit_modify(SLONG x, SLONG y, SLONG z){  // revise negative limit by JOSH 2017/03/15

    SDOUBLE sdcalcul = (SDOUBLE)x + y,
            sd_z     = (SDOUBLE)abs(z);
    
    if(sd_z > 0x7FFFFFFF)
        sd_z = 0x7FFFFFFF;

    if( sdcalcul >= 0 ){    //sdcalcul >= 0
        if(sdcalcul > sd_z)
            sdcalcul = sd_z;
    }
    else{                   //sdcalcul  <  0
        if(sdcalcul < -sd_z)
            sdcalcul = -sd_z;
    }
    return (SLONG)sdcalcul;
}

UWORD ReadRamData(UWORD uwAddr){

	UWORD uwData;
	if (uwAddr < 0x2000){		// On-chip RAM, DINO, 07/05/2010
		uwData = memadd_rd(uwAddr);
	}
	
	else{						// ADC0, ADC1, ADC2
		uwData = memadd_rd1(uwAddr);
	}
}

UWORD memadd_rd(UWORD x)
{
  UWORD yn;
  ULONG *mptr;
  ULONG Bmap;
  ULONG Read_Address_ptr;
  UWORD *data_ptr;
  UWORD ubVariable;
  
  Read_Address_ptr = 0x00000000+x;


  data_ptr = (UWORD *)Read_Address_ptr;
  ubVariable = *data_ptr;

//uwtest8 = *mptr;
//uwtest9 = (UWORD)((ULONG*)Bmap);

  return ubVariable;
}

UWORD memadd_rd1(UWORD x)
{
  UWORD yn;
  ULONG *mptr;
  ULONG Bmap;
  ULONG Read_Address_ptr;
  UWORD *data_ptr;
  UWORD ubVariable;
  
  Read_Address_ptr = 0x00080000+x;


  data_ptr = (UWORD *)Read_Address_ptr;
  ubVariable = *data_ptr;

//uwtest8 = *mptr;
//uwtest9 = (UWORD)((ULONG*)Bmap);

  return ubVariable;
}




#ifdef _mathtool_C
    #undef _mathtool_C
#endif
